// 1.0.143
(function(){"use strict";(function(i,a){try{if(typeof document<"u"){const e=document.createElement("style");e.id="d-id-agent-style";for(const t in a.attributes)e.setAttribute(t,a.attributes[t]);e.appendChild(document.createTextNode(i)),document.head.appendChild(e)}}catch(e){console.error("vite-plugin-css-injected-by-js",e)}})('@import"https://fonts.googleapis.com/css2?family=Inter:wght@200;300;400;500;600;700;800";.didagent__info_message_agent_unavailable_container{height:100%}.didagent__info_message_agent_unavailable_danger{width:100%;height:100%;z-index:2;margin-bottom:-4px;color:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-weight:500;font-size:12px;opacity:.85;background-color:var(--did-secondary-main);border-radius:8px;padding:0 8px;gap:8px;overflow:auto}.didagent__info_message_agent_unavailable_danger svg{color:var(--did-danger-main);display:-webkit-box;display:-ms-flexbox;display:flex;width:16px;height:16px;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.didagent__info_message_agent_unavailable_danger pre{margin:0 0 2px;white-space:pre-wrap}.didagent__info_message_agent_unavailable_message{display:-webkit-box;display:-ms-flexbox;display:flex;margin:0;-ms-flex-negative:0;flex-shrink:0;white-space:break-spaces;word-wrap:break-word;font-size:12px;-webkit-box-sizing:border-box;box-sizing:border-box;background:var(--did-secondary-main);opacity:.8;border-radius:4px;padding:4px;color:#fff;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center}.didagent__info_message_indication{background:var(--did-secondary-main);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;color:#fff;margin:0;border-radius:8px;padding-left:10px;max-width:70%}.didagent__info_message_indication pre{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;font-size:14px;white-space:pre-wrap;padding:10px 10px 10px 8px;width:90%}.didagent__info_message_indication svg{margin-left:8px}@-webkit-keyframes fadeIn{0%{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}to{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}}@keyframes fadeIn{0%{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}to{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}}@-webkit-keyframes fadeOut{0%{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}}@keyframes fadeOut{0%{opacity:.8;-webkit-transform:translateY(0);transform:translateY(0)}to{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}}.fade-in{-webkit-animation:fadeIn .5s forwards;animation:fadeIn .5s forwards}.fade-out{-webkit-animation:fadeOut .5s forwards;animation:fadeOut .5s forwards}.didagent__maskedicon{-webkit-mask:var(--mask-url) no-repeat center;mask:var(--mask-url) no-repeat center;background-color:var(--color);-webkit-mask-size:contain;mask-size:contain;width:var(--width, var(--size, 24px));height:var(--size, var(--height, 24px));padding:var(--padding);margin:var(--margin);-webkit-transform:rotate(var(--rotation, 0deg));-ms-transform:rotate(var(--rotation, 0deg));transform:rotate(var(--rotation, 0deg));display:block;-webkit-transition:background-color .1s ease-in-out,-webkit-transform .2s ease-in-out;transition:background-color .1s ease-in-out,-webkit-transform .2s ease-in-out;transition:transform .2s ease-in-out,background-color .1s ease-in-out;transition:transform .2s ease-in-out,background-color .1s ease-in-out,-webkit-transform .2s ease-in-out}.didagent__banner{width:100%;height:34px;z-index:2;margin-bottom:-4px;color:#fff;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;font-weight:400;font-size:12px;opacity:.85;background-color:var(--did-secondary-main)}.didagaent__send__button{height:100%;aspect-ratio:1;color:#fff;border:none;outline:none;cursor:pointer;padding:0;background:#2b2a28;border-radius:100vmax;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-shadow:0px 3px 3px 0px rgba(0,0,0,.07);box-shadow:0 3px 3px #00000012;-webkit-transition:background-color .1s ease-out;transition:background-color .1s ease-out}.didagaent__send__button:disabled{cursor:not-allowed;-webkit-backdrop-filter:blur(60px);backdrop-filter:blur(60px)}.didagent__send__button__disabled{opacity:.5}.didagaent__send__button_actions:hover{background:#2b2a28;opacity:.8}.didagaent__send__button_actions:active{opacity:.5}.didagaent__send__button__loader,.didagaent__send__button__record{background:#fff9}.didagaent__send__button__record:hover{background-color:#fff}.didagaent__send__button__record:disabled{opacity:.5}.didagaent__send__button__reload{background:var(--did-secondary-main)}\
.didagent__branding_footer{width:100%;display:-webkit-box;display:-ms-flexbox;display:none;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;z-index:2;gap:8px;margin-top:-4px;color:#fff;padding:4px;font-weight:300;font-size:12px;opacity:.8;background-color:var(--did-secondary-main)}\
.didagent__header{width:100%;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:justify;-ms-flex-pack:justify;\
justify-content:space-between;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:0 12px;-webkit-user-select:none;\
-moz-user-select:none;-ms-user-select:none;user-select:none;-webkit-box-flex:1;-ms-flex:1;flex:1;background:\
-webkit-gradient(linear,left top,left bottom,from(rgba(9,6,4,.3)),to(rgba(9,6,4,0)));background:linear-gradient(180deg,#0906044d,#09060400);\
z-index:2;gap:8px;max-height:54px}\
.didagent__header .didagent__header-bg{border-radius:100vmax;background-color:var(--did-primary-black-00050);display:-webkit-box;\
display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-box-pack:center;\
-ms-flex-pack:center;justify-content:center;border:none;outline:none}\
.didagent__header .didagent__header-left{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;\
-ms-flex-align:center;align-items:center;gap:8px;height:32px}\
.didagent__header .didagent__header-left>button{cursor:pointer;border:none;outline:none;aspect-ratio:1;width:32px;color:#fff;\
-webkit-transition:background-color .2s;transition:background-color .2s;z-index:10000;height:100%}\
.didagent__header .didagent__header-left>button:hover{background-color:var(--did-secondary-hover)!important}\
.didagent__header .didagent__header-left button.didagent__header__menu__item-active{background-color:#fff;color:var(--did-secondary-900)}\
.didagent__header .didagent__header-left button.didagent__header__menu__item-active:hover{background-color:#fff!important}\
.didagent__header .didagent__header-left .didagent__header__name{font-size:.875em;font-weight:500;margin:0;color:var(--color, white);\
height:100%;padding:0 8px}\
.didagent__header .didagent__header-left .didagent__header__name img{max-height:64px;height:100%;-o-object-fit:contain;object-fit:contain;display:block}\
.didagent__header .didagent__header-center{display:-webkit-box;display:-ms-flexbox;display:flex;gap:8px;height:32px;margin:0 auto}\
.didagent__header .didagent__header__menu__item{cursor:pointer;color:var(--did-secondary-main);height:100%;aspect-ratio:1;border:none}\
.didagent__header .didagent__header__menu__item:disabled{cursor:not-allowed;opacity:.5}\
.didagent__header .didagent__header__menu__item:active:not(:disabled){border:1px solid var(--did-primary-black-300)}\
.didagent__header .didagent__header__menu__item-rotate{-webkit-animation:rotate 1s linear infinite;animation:rotate 1s linear infinite}\
@-webkit-keyframes rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}\
@keyframes rotate{0%{-webkit-transform:rotate(0deg);transform:rotate(0)}to{-webkit-transform:rotate(360deg);transform:rotate(360deg)}}\
.didagent__thumb__container{--flip-y: 1;--hover-color: var(--did-primary-black-00030);--color: var(--did-primary-black-00012);--cursor: pointer;\
cursor:var(--cursor);-webkit-transform:scaleY(var(--flip-y));-ms-transform:scaleY(var(--flip-y));transform:scaleY(var(--flip-y));\
width:32px;height:32px;border-radius:100%;background-color:var(--color);display:-webkit-box;display:-ms-flexbox;display:flex;\
-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;line-height:1}\
.didagent__thumb__container:hover{background-color:var(--hover-color)}\
.didagent__thumb__container:active{background-color:var(--did-primary-black-00040)}.appear-animation{opacity:1}.appear-animation span{opacity:0;-webkit-animation:character-appear .3s ease-out forwards;animation:character-appear .3s ease-out forwards}@-webkit-keyframes character-appear{0%{opacity:0}to{opacity:1}}@keyframes character-appear{0%{opacity:0}to{opacity:1}}.didagent__messages__container{display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;gap:8px;overflow:auto;min-height:50px;max-height:200px;padding-top:80px;padding-bottom:8px;-webkit-box-sizing:border-box;box-sizing:border-box;-webkit-mask-image:-webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(50%,black),color-stop(97%,black),to(transparent));-webkit-mask-image:linear-gradient(to bottom,transparent,black 50%,black 97%,transparent);mask-image:-webkit-gradient(linear,left top,left bottom,from(transparent),color-stop(50%,black),color-stop(97%,black),to(transparent));mask-image:linear-gradient(to bottom,transparent,black 50%,black 97%,transparent);z-index:2;-ms-flex-item-align:center;align-self:center}.didagent__messages__container::-webkit-scrollbar{display:none}.didagent__messages__container .didagent__message__container{position:relative;min-width:50px;max-width:75%;-webkit-user-select:auto;-moz-user-select:auto;-ms-user-select:auto;user-select:auto;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;gap:8px}.didagent__messages__container .didagent__message__container .didagent__message{-webkit-box-sizing:border-box;box-sizing:border-box;padding:10px;font-family:inherit;margin:0;-ms-flex-negative:0;flex-shrink:0;white-space:break-spaces;word-wrap:break-word;font-size:.875em;max-width:100%}.didagent__messages__container .didagent__message__container .didagent__message__user{background:#5a5a5ae6;opacity:.8;border-radius:16px 0 16px 16px;color:#fff}.didagent__messages__container .didagent__message__container .didagent__message__assistant{background:#000000e6;opacity:.8;border-radius:0 16px 16px;color:#fff}.didagent__messages__container .didagent__message__container .didagent__message__assistant__loader{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding-left:14px;gap:8px}.didagent__messages__container .didagent__message__container .didagent__message__url{color:#497cff}.didagent__messages__container .didagent__message__container:hover .didagent__message__rating{opacity:1}.didagent__messages__container .didagent__message__container .didagent__message__rating{opacity:0;display:-webkit-box;display:-ms-flexbox;display:flex;-ms-flex-item-align:end;align-self:flex-end;gap:12px;-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out;padding-bottom:4px}.didagent__messages__container .didagent__message__container__assistant{margin-right:auto}.didagent__messages__container .didagent__message__container__user{margin-left:auto}.didagent__starter_messages__container{display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;gap:8px;width:100%;padding:0 16px 8px;max-height:180px;overflow:auto;-webkit-transition:max-height .6s ease-out,margin-bottom .6s ease-out,padding-bottom .6s ease-out,opacity .6s ease-out;transition:max-height .6s ease-out,margin-bottom .6s ease-out,padding-bottom .6s ease-out,opacity .6s ease-out;z-index:2}.didagent__starter_messages__container::-webkit-scrollbar{display:none}.didagent__starter_messages__container .didagent__starter_message__container{padding:10px 16px;border-radius:8px;width:100%;height:46px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);background:var(--did-primary-black-00050);color:#fff;cursor:pointer;-webkit-user-select:none;-moz-user-select:none;-ms-user-select:none;user-select:none;font-weight:400;-webkit-box-flex:1;-ms-flex:1 0 auto;flex:1 0 auto}.didagent__starter_messages__container .didagent__starter_message__container .didagent__starter_message__arrow{rotate:270deg;margin-left:auto}.didagent__starter_messages__container .didagent__starter_message__container:hover{background:var(--did-primary-black-00040)}.didagent__starter_messages__container .didagent__starter_message__container:active{background:var(--did-primary-black-00050)}.didagent__starter_messages__container .didagent__starter_message__container.disabled{background:#78787829;cursor:not-allowed;pointer-events:none}.didagent__starter_messages__container .didagent__starter_message__container_text{text-overflow:ellipsis;overflow:hidden;white-space:normal;padding-right:8px;-webkit-box-flex:1;-ms-flex:1;flex:1;display:-webkit-box;line-clamp:2;-webkit-line-clamp:2;-webkit-box-orient:vertical}.didagent__embedded__video__container{position:absolute;top:0;width:100%;height:100%;aspect-ratio:1/1.5;margin:0 auto}.didagent__embedded__video__container[data-blur=true]{-webkit-filter:blur(7px);filter:blur(7px)}.didagent__embedded__video__container video{-o-object-fit:cover;object-fit:cover;position:absolute;display:block;height:100%;width:100%}\
@media (min-width: 1280px){\
.didagent__embedded__video__container[data-orientation=horizontal] video{-o-object-fit:contain;object-fit:contain}}\
.didagent__embedded__video__container .didagent__video__skeleton{height:100%;aspect-ratio:1;margin:auto}:host{--did-primary-black-50: #f1f2f6;--did-primary-black-70: #c0bfbd;--did-primary-black-80: #5a5a5a;--did-primary-black-90: #1d1d1d;--did-primary-black-9060: #1d1d1d99;--did-primary-black-9080: #1d1d1dcc;--did-primary-black-100: #242625;--did-primary-black-10090: #242625ba;--did-primary-black-200: #ebebeb;--did-primary-black-300: #dbdbdb;--did-primary-black-400: #b8b8b8;--did-primary-black-500: #989898;--did-primary-black-700: #5c5c5c;--did-primary-black-00012: rgba(0, 0, 0, .125);--did-primary-black-00030: rgba(0, 0, 0, .3);--did-primary-black-00040: rgba(0, 0, 0, .4);--did-primary-black-00050: rgba(0, 0, 0, .5);--did-primary-50: #fffee9;--did-primary-100: #fffac7;--did-primary-200: #fff6a0;--did-primary-300: #fff17b;--did-primary-400: #ffec5c;--did-primary-500: #fee640;--did-primary-600: #ffdd45;--did-primary-700: #ffc941;--did-primary-800: #ffb13a;--did-primary-900: #ff882e;--did-primary-950: #ed7921;--did-primary-main: #ff882e;--did-primary-light: #fff6ef;--did-primary-bg: #ff882e1f;--did-primary-bgDark: #493021;--did-primary-hover: #ed7921;--did-primary-disabled: #94979c;--did-secondary-50: #f8f5f4;--did-secondary-60: #f3f3f3;--did-secondary-100: #eceae8;--did-secondary-200: #dedcda;--did-secondary-300: #c9c7c6;--did-secondary-400: #a4a1a0;--did-secondary-500: #82807e;--did-secondary-550: #707070;--did-secondary-600: #5b5958;--did-secondary-700: #494745;--did-secondary-800: #2b2a28;--did-secondary-900: #090604;--did-secondary-main: #090604;--did-secondary-hover: #2b2a28;--did-secondary-shades-800: rgba(43, 42, 40, 1);--did-success-main: #29cc6a;--did-danger-main: #ed254e;--did-danger-light: #fef2f2;--did-danger-dark: #cc0037}.didagent__embedded__container__loading{width:100%;height:100%;-webkit-backdrop-filter:var(--backdrop-filter);backdrop-filter:var(--backdrop-filter);background-color:var(--background-color);display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;-webkit-box-align:center;-ms-flex-align:center;align-items:center;pointer-events:none;opacity:1;-webkit-transition:opacity .3s ease;transition:opacity .3s ease;position:absolute;z-index:3}.didagent__embedded__container__loading>span{color:var(--did-secondary-60);font-weight:500}.didagent__fullscreen{position:fixed!important;top:0;right:0;bottom:0;left:0;z-index:99999}.didagent__embedded__container{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;width:100%;height:100%;position:relative;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column;gap:4px;overflow:hidden;min-width:250px;font-size:16px;background:#373636;isolation:isolate}.didagent__embedded__container .didagent__filler{-webkit-box-flex:1;-ms-flex:1;flex:1;width:100%;pointer-events:none}.didagent__embedded__container .didagent__close__button{display:none}.didagent__embedded__container *{-webkit-box-sizing:border-box;box-sizing:border-box}.didagent__background{width:100%;height:100%;position:absolute;top:0;left:0;background-size:cover!important;-webkit-filter:blur(15px);filter:blur(15px);scale:105%}\
.didagent__main__container{padding-left:12px;padding-right:12px;margin:0 auto;display:-webkit-box;display:-ms-flexbox;display:flex;width:100%;max-width:80vw;-webkit-box-orient:vertical;-webkit-box-direction:normal;-ms-flex-direction:column;flex-direction:column}.didagent__main__input{margin-bottom:12px;width:100%;-ms-flex-item-align:center;align-self:center;margin-top:0;position:relative;height:52px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;gap:12px;background-color:var(--focus, rgba(255, 255, 255, .6));-webkit-backdrop-filter:blur(16px);backdrop-filter:blur(16px);z-index:4;border-radius:8px;-webkit-box-align:center;-ms-flex-align:center;align-items:center;padding:8px 16px;-webkit-transition:height .3s ease,background-color .3s ease;transition:height .3s ease,background-color .3s ease}.didagent__main__input .didagent__main__input-send{height:36px}.didagent__main__input>textarea{position:relative;border:none;outline:none;resize:none;font-family:inherit;text-align:left;width:100%;height:100%;background:transparent;font-size:16px;color:var(--did-secondary-shades-800);margin-top:10px;-webkit-transition:margin-top .2s ease;transition:margin-top .2s ease;line-height:20px}.didagent__main__input>textarea::-webkit-input-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::-moz-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea:-ms-input-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::-ms-input-placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::placeholder{color:var(--did-primary-black-700);opacity:1;font-size:14px}.didagent__main__input>textarea::-webkit-scrollbar{display:none}\
.didagent__fabio{font-family:Inter,system-ui,Avenir,Helvetica,Arial,sans-serif;position:fixed;aspect-ratio:1;\
    -webkit-transition:opacity .6s ease-in-out,width .6s ease-in-out,height .6s ease-in-out;transition:opacity .6s \
    ease-in-out,width .6s ease-in-out,height .6s ease-in-out;aspect-ratio:.6s ease-in-out;z-index:99999;isolation:isolate;bottom:0px}\
.didagent__fabio[data-enabled=false]{width:240px}\
.didagent__fabio[data-enabled=true]{width:240px}\
.didagent__fabio[data-position=left]{left:2%; bottom:2%}\
.didagent__fabio[data-position=right][data-enabled=false]{right:2%; bottom:2%}\
.didagent__fabio[data-position=right][data-enabled=true]{right:2%; bottom:2%}\
\
@media (max-height: 550px){\
.didagent__fabio{display:none}}\
.didagent__fabio *{-webkit-box-sizing:border-box;box-sizing:border-box}\
.didagent__fabio>button{width:100%;height:100%;border-radius:50%;padding:0;cursor:pointer;outline:0;position:relative;border:none;\
    -webkit-box-shadow:1px 3px 4px 1px #bbbbbb42;box-shadow:1px 3px 4px 1px #bbbbbb42;-webkit-transition:bottom .6s \
    ease-in-out,opacity .8s ease-in-out,scale .2s ease-in-out;transition:bottom .6s ease-in-out,opacity .8s ease-in-out,scale .2s \
    ease-in-out;overflow:hidden}\
.didagent__fabio>button>video,.didagent__fabio>button img{border-radius:100%;position:absolute;top:50%;left:50%;translate:-50% -50%;\
    -o-object-fit:cover;object-fit:cover;-webkit-transition:opacity .2s ease-in-out;transition:opacity .2s ease-in-out}\
.didagent__fabio>button>video{width:100%;height:100%}\
.didagent__fabio>button:hover{background:#494949;scale:1.1}\
.didagent__fabio>button:after{content:"";position:absolute;top:0;left:0;width:100%;height:100%;background:#0000001a;border-radius:50%}\
.didagent__fabio .didagent__fabio__speak_with{z-index:-1;position:absolute;top:50%;right:110%;background:#494949e6;font-size:14px;\
    text-align:center;border-radius:10px 10px 0;translate:0px -50%;width:90px;-webkit-transition:all .5s ease-in-out;transition:all .5s \
    ease-in-out;height:50px;display:-webkit-box;display:-ms-flexbox;display:flex;-webkit-box-align:center;-ms-flex-align:center;\
    align-items:center;-webkit-box-pack:center;-ms-flex-pack:center;justify-content:center;cursor:pointer;pointer-events:none}\
.didagent__fabio .didagent__fabio__speak_with>div{overflow:hidden;white-space:nowrap;text-overflow:ellipsis;font-weight:400;color:#fff}\
.didagent__fabio .didagent__fabio__speak_with:after{position:absolute;top:0;left:100%;width:30px;height:100%;background:inherit}\
.didagent__fabio .didagent__transition_out{-webkit-transition:all .4s ease-in-out;transition:all .4s ease-in-out}\
.didagent__fabio .didagent__fabio__container{overflow:hidden;-webkit-transition:height .2s ease-in-out,opacity .2s ease-in-out;\
    transition:height .2s ease-in-out,opacity .2s ease-in-out;position:absolute;bottom:0;border-radius:16px}\
\
@media (orientation: portrait) {\
.didagent__fabio .didagent__fabio__container{position:fixed;border-radius:0;width:96vw;height:96vh;\
    bottom:0;left:0}}\
\
.didagent__fabio .didagent__fabio__container .didagent__close__button{display:-webkit-box;display:-ms-flexbox;display:flex}\
.didagent__fabio .didagent__fabio__container[data-position=left]{left:0}\
.didagent__fabio .didagent__fabio__container[data-position=right]{right:0}\
\
.didagent__fabio .didagent__fabio__container[data-enabled=true]{opacity:1;pointer-events:auto;z-index:100}\
\
@media (orientation: portrait) {\
.didagent__fabio .didagent__fabio__container[data-enabled=true]{position:fixed;border-radius:0;width:96vw;height:96vh;\
    bottom:0;left:0}}\
\
@media (orientation: landscape) {\
.didagent__fabio .didagent__fabio__container[data-enabled=true]{width:96vw;height:96vh;aspect-ratio:4 / 3}}\
\
@media (min-width: 1280px){\
.didagent__fabio .didagent__fabio__container[data-enabled=true][data-orientation=horizontal]{width:96vw;height:96vh;aspect-ratio:4 / 3}}\
\
.didagent__fabio .didagent__fabio__container[data-enabled=false]{opacity:0;pointer-events:none;z-index:-1;height:0}',{})})();

var Io = /* @__PURE__ */ ((e) => (e.TRIAL = "trial", e.BASIC = "basic", e.ENTERPRISE = "enterprise", e.LITE = "lite", e.ADVANCED = "advanced", e))(Io || {}), Mo = /* @__PURE__ */ ((e) => (e.TRIAL = "deid-trial", e.PRO = "deid-pro", e.ENTERPRISE = "deid-enterprise", e.LITE = "deid-lite", e.ADVANCED = "deid-advanced", e.BUILD = "deid-api-build", e.LAUNCH = "deid-api-launch", e.SCALE = "deid-api-scale", e))(Mo || {}), me = /* @__PURE__ */ ((e) => (e.Unrated = "Unrated", e.Positive = "Positive", e.Negative = "Negative", e))(me || {}), C = /* @__PURE__ */ ((e) => (e.Functional = "Functional", e.TextOnly = "TextOnly", e.Maintenance = "Maintenance", e.Playground = "Playground", e.DirectPlayback = "DirectPlayback", e))(C || {}), st = /* @__PURE__ */ ((e) => (e.Embed = "embed", e.Query = "query", e.Partial = "partial", e.Answer = "answer", e.Complete = "done", e))(st || {}), kt = /* @__PURE__ */ ((e) => (e.Clip = "clip", e.Talk = "talk", e))(kt || {}), Ze = /* @__PURE__ */ ((e) => (e.Start = "START", e.Stop = "STOP", e))(Ze || {}), Sr = /* @__PURE__ */ ((e) => (e.ChatAnswer = "chat/answer", e.ChatPartial = "chat/partial", e.StreamDone = "stream/done", e.StreamStarted = "stream/started", e.StreamFailed = "stream/error", e.StreamReady = "stream/ready", e.StreamCreated = "stream/created", e.StreamVideoCreated = "stream-video/started", e.StreamVideoDone = "stream-video/done", e.StreamVideoError = "stream-video/error", e.StreamVideoRejected = "stream-video/rejected", e))(Sr || {}), P = /* @__PURE__ */ ((e) => (e.New = "new", e.Fail = "fail", e.Connected = "connected", e.Connecting = "connecting", e.Closed = "closed", e.Completed = "completed", e.Disconnected = "disconnected", e))(P || {});
const En = "https://api.d-id.com", va = "wss://notifications.d-id.com", Sa = "79f81a83a67430be2bc0fd61042b8faa", fn = () => Math.random().toString(16).slice(2);
function No() {
  let e = window.localStorage.getItem("did_external_key_id");
  return e || (e = Math.random().toString(16).slice(2), window.localStorage.setItem("did_external_key_id", e)), e;
}
let ba = fn();
function Ao(e) {
  if (e.type === "bearer")
    return `Bearer ${e.token}`;
  if (e.type === "basic")
    return `Basic ${btoa(`${e.username}:${e.password}`)}`;
  if (e.type === "key")
    return `Client-Key ${e.clientKey}.${No()}_${ba}`;
  throw new Error(`Unknown auth type: ${e}`);
}
function br(e, t = En, n) {
  const r = async (i, o) => {
    const s = await fetch(t + (i != null && i.startsWith("/") ? i : `/${i}`), {
      ...o,
      headers: {
        ...o == null ? void 0 : o.headers,
        Authorization: Ao(e),
        "Content-Type": "application/json"
      }
    });
    if (!s.ok) {
      let a = await s.text().catch(() => "Failed to fetch");
      throw n && n(new Error(a), {
        url: i,
        options: o,
        headers: s.headers
      }), new Error(a);
    }
    return s.json();
  };
  return {
    get(i, o) {
      return r(i, {
        ...o,
        method: "GET"
      });
    },
    post(i, o, s) {
      return r(i, {
        ...s,
        body: JSON.stringify(o),
        method: "POST"
      });
    },
    delete(i, o, s) {
      return r(i, {
        ...s,
        body: JSON.stringify(o),
        method: "DELETE"
      });
    },
    patch(i, o, s) {
      return r(i, {
        ...s,
        body: JSON.stringify(o),
        method: "PATCH"
      });
    }
  };
}
function Ea(e, t = En, n) {
  const r = br(e, `${t}/agents`, n);
  return {
    create(i, o) {
      return r.post("/", i, o);
    },
    getAgents(i, o) {
      return r.get(`/${i ? `?tag=${i}` : ""}`, o).then((s) => s ?? []);
    },
    getById(i, o) {
      return r.get(`/${i}`, o);
    },
    delete(i, o) {
      return r.delete(`/${i}`, void 0, o);
    },
    update(i, o, s) {
      return r.patch(`/${i}`, o, s);
    },
    newChat(i, o, s) {
      return r.post(`/${i}/chat`, o, s);
    },
    chat(i, o, s, a) {
      return r.post(`/${i}/chat/${o}`, s, a);
    },
    createRating(i, o, s, a) {
      return r.post(`/${i}/chat/${o}/ratings`, s, a);
    },
    updateRating(i, o, s, a, c) {
      return r.patch(`/${i}/chat/${o}/ratings/${s}`, a, c);
    },
    deleteRating(i, o, s, a) {
      return r.delete(`/${i}/chat/${o}/ratings/${s}`, a);
    }
  };
}
const wa = (e) => new Promise((t) => setTimeout(t, e));
function Ta(e) {
  return new Promise((t, n) => {
    const {
      callbacks: r,
      host: i,
      auth: o
    } = e, {
      onMessage: s = null,
      onOpen: a = null,
      onClose: c = null,
      onError: d = null
    } = r || {}, l = new WebSocket(`${i}?authorization=${Ao(o)}`);
    l.onmessage = s, l.onclose = c, l.onerror = (u) => {
      console.error(u), d == null || d("Websocket failed to connect", u), n(u);
    }, l.onopen = (u) => {
      a == null || a(u), t(l);
    };
  });
}
async function Ca(e) {
  const {
    retries: t = 1
  } = e;
  let n = null;
  for (let r = 0; (n == null ? void 0 : n.readyState) !== WebSocket.OPEN; r++)
    try {
      n = await Ta(e);
    } catch (i) {
      if (r === t)
        throw i;
      await wa(r * 500);
    }
  return n;
}
async function ka(e, t, n) {
  const r = n != null && n.onMessage ? [n.onMessage] : [], i = await Ca({
    auth: e,
    host: t,
    callbacks: {
      onError: n == null ? void 0 : n.onError,
      onMessage: (o) => {
        const s = JSON.parse(o.data);
        r.forEach((a) => a(s.event, s));
      }
    }
  });
  return {
    socket: i,
    disconnect: () => i.close(),
    subscribeToEvents: (o) => r.push(o)
  };
}
const Ia = "X-Playground-Chat";
function Ma(e, t, n, r) {
  const i = br(e, `${t}/agents/${n}`, r);
  return {
    createStream(o) {
      return i.post("/streams", {
        compatibility_mode: o.compatibility_mode,
        stream_warmup: o.stream_warmup,
        session_timeout: o.session_timeout
      });
    },
    startConnection(o, s, a) {
      return i.post(`/streams/${o}/sdp`, {
        session_id: a,
        answer: s
      });
    },
    addIceCandidate(o, s, a) {
      return i.post(`/streams/${o}/ice`, {
        session_id: a,
        ...s
      });
    },
    sendStreamRequest(o, s, a) {
      return i.post(`/streams/${o}`, {
        session_id: s,
        ...a
      });
    },
    close(o, s) {
      return i.delete(`/streams/${o}`, {
        session_id: s
      });
    }
  };
}
function Na(e, t, n, r) {
  const i = br(e, `${t}/agents/${n}`, r);
  return {
    createStream(o, s) {
      return i.post("/streams", {
        driver_url: o.driver_url,
        face: o.face,
        config: o.config,
        compatibility_mode: o.compatibility_mode,
        stream_warmup: o.stream_warmup,
        output_resolution: o.output_resolution,
        session_timeout: o.session_timeout
      }, s);
    },
    startConnection(o, s, a, c) {
      return i.post(`/streams/${o}/sdp`, {
        session_id: a,
        answer: s
      }, c);
    },
    addIceCandidate(o, s, a, c) {
      return i.post(`/streams/${o}/ice`, {
        session_id: a,
        ...s
      }, c);
    },
    sendStreamRequest(o, s, a, c) {
      return i.post(`/streams/${o}`, {
        session_id: s,
        ...a
      }, c);
    },
    close(o, s, a) {
      return i.delete(`/streams/${o}`, {
        session_id: s
      }, a);
    }
  };
}
let xo = !1;
const Re = (e, t) => xo && console.log(e, t), Aa = (window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection).bind(window);
function ti(e) {
  switch (e) {
    case "connected":
      return P.Connected;
    case "checking":
      return P.Connecting;
    case "failed":
      return P.Fail;
    case "new":
      return P.New;
    case "closed":
      return P.Closed;
    case "disconnected":
      return P.Disconnected;
    case "completed":
      return P.Completed;
    default:
      return P.New;
  }
}
function xa() {
  let e = 0;
  return (t) => {
    for (const n of t.values())
      if (n && n.type === "inbound-rtp" && n.kind === "video") {
        const r = n.bytesReceived, i = r - e > 0;
        return e = r, i;
      }
    return !1;
  };
}
function Ra(e, t) {
  const n = Math.max(Math.ceil(10), 1);
  let r = 0, i = !1;
  const o = xa();
  return setInterval(async () => {
    const s = await e.getStats();
    o(s) ? (r = 0, i || (t == null || t(Ze.Start), i = !0)) : i && (r++, r >= n && (t == null || t(Ze.Stop), i = !1));
  }, 100);
}
async function La(e, t, {
  debug: n = !1,
  callbacks: r,
  auth: i,
  baseURL: o = En,
  warmup: s
}) {
  xo = n;
  let a;
  const {
    startConnection: c,
    sendStreamRequest: d,
    close: l,
    createStream: u,
    addIceCandidate: p
  } = t.videoType === kt.Clip ? Ma(i, o, e, r.onError) : Na(i, o, e, r.onError), {
    id: f,
    offer: _,
    ice_servers: S,
    session_id: b
  } = await u(t), E = new Aa({
    iceServers: S
  });
  if (!b)
    throw new Error("Could not create session_id");
  const h = Ra(E, r.onVideoStateChange);
  E.onicecandidate = (T) => {
    Re("peerConnection.onicecandidate", T), T.candidate && T.candidate.sdpMid && T.candidate.sdpMLineIndex !== null ? p(f, {
      candidate: T.candidate.candidate,
      sdpMid: T.candidate.sdpMid,
      sdpMLineIndex: T.candidate.sdpMLineIndex
    }, b) : p(f, {
      candidate: null
    }, b);
  }, E.oniceconnectionstatechange = () => {
    var T;
    Re("peerConnection.oniceconnectionstatechange => " + E.iceConnectionState);
    const w = ti(E.iceConnectionState);
    w === P.Connected ? a = setTimeout(() => {
      var m;
      return (m = r.onConnectionStateChange) == null ? void 0 : m.call(r, P.Connected);
    }, s ? 5e3 : 0) : (clearTimeout(a), (T = r.onConnectionStateChange) == null || T.call(r, w));
  }, E.ontrack = (T) => {
    var w;
    Re("peerConnection.ontrack", T), (w = r.onSrcObjectReady) == null || w.call(r, T.streams[0]);
  }, await E.setRemoteDescription(_), Re("set remote description OK");
  const y = await E.createAnswer();
  return Re("create answer OK"), await E.setLocalDescription(y), Re("set local description OK"), await c(f, y, b), Re("start connection OK"), {
    /**
     * Method to send request to server to get clip or talk depend on you payload
     * @param payload
     */
    speak(T) {
      return d(f, b, T);
    },
    /**
     * Method to close RTC connection
     */
    async disconnect() {
      var T, w;
      if (f) {
        const m = ti(E.iceConnectionState);
        if (E) {
          if (m === P.New) {
            (T = r.onVideoStateChange) == null || T.call(r, Ze.Stop), clearInterval(h);
            return;
          }
          E.close(), E.oniceconnectionstatechange = null, E.onnegotiationneeded = null, E.onicecandidate = null, E.ontrack = null;
        }
        try {
          m === P.Connected && await l(f, b).catch((k) => {
          });
        } catch (k) {
          Re("Error on close stream connection", k);
        }
        (w = r.onVideoStateChange) == null || w.call(r, Ze.Stop), clearInterval(h);
      }
    },
    /**
     * Session identifier information, should be returned in the body of all streaming requests
     */
    sessionId: b,
    /**
     * Id of current RTC stream
     */
    streamId: f
  };
}
let On = {};
function Oa(e) {
  const t = window != null && window.hasOwnProperty("DID_AGENTS_API") ? "agents-ui" : "agents-sdk", n = e.agent.presenter, r = {
    token: e.token || "testKey",
    distinct_id: e.distinctId || No(),
    agentId: e.agent.id,
    agentType: n.type === "clip" && n.presenter_id.startsWith("v2_") ? "clip_v2" : n.type,
    owner_id: e.agent.owner_id ?? ""
  };
  return {
    ...r,
    isEnabled: e.isEnabled ?? !0,
    getRandom: () => Math.random().toString(16).slice(2),
    track(i, o) {
      if (!this.isEnabled)
        return Promise.reject("MixPanel analytics is disabled on creation");
      const {
        audioPath: s,
        ...a
      } = o || {}, c = {
        method: "POST",
        headers: {
          "Content-Type": "application/x-www-form-urlencoded"
        },
        body: new URLSearchParams({
          data: JSON.stringify([{
            event: i,
            properties: {
              ...a,
              ...r,
              source: t,
              time: Date.now(),
              $insert_id: this.getRandom(),
              origin: window.location.href,
              "Screen Height": window.screen.height || window.innerWidth,
              "Screen Width": window.screen.width || window.innerHeight,
              "User Agent": navigator.userAgent
            }
          }])
        })
      };
      return fetch("https://api-js.mixpanel.com/track/?verbose=1&ip=1", c).then((d) => d.json()).catch((d) => console.error(d));
    },
    linkTrack(i, o, s, a) {
      On[i] || (On[i] = {
        events: {},
        resolvedDependencies: []
      }), a.includes(s) || a.push(s);
      const c = On[i];
      if (c.events[s] = {
        props: o
      }, c.resolvedDependencies.push(s), a.every((d) => c.resolvedDependencies.includes(d))) {
        const d = a.reduce((l, u) => c.events[u] ? {
          ...l,
          ...c.events[u].props
        } : l, {});
        this.track(i, d), c.resolvedDependencies = c.resolvedDependencies.filter((l) => !a.includes(l)), a.forEach((l) => {
          delete c.events[l];
        });
      }
    }
  };
}
function Pa(e) {
  var t, n, r, i;
  const o = () => /Mobi|Android/i.test(navigator.userAgent) ? "Mobile" : "Desktop", s = () => {
    const c = navigator.platform;
    return c.toLowerCase().includes("win") ? "Windows" : c.toLowerCase().includes("mac") ? "Mac OS X" : c.toLowerCase().includes("linux") ? "Linux" : "Unknown";
  }, a = e.presenter;
  return {
    $os: `${s()}`,
    isMobile: `${o() == "Mobile"}`,
    browser: navigator.userAgent,
    origin: window.location.origin,
    agentType: a.type === "clip" && a.presenter_id.startsWith("v2_") ? "clip_v2" : a.type,
    agentVoice: {
      voiceId: (n = (t = e.presenter) == null ? void 0 : t.voice) == null ? void 0 : n.voice_id,
      provider: (i = (r = e.presenter) == null ? void 0 : r.voice) == null ? void 0 : i.type
    }
  };
}
function $a(e, t, n) {
  var r, i;
  const {
    event: o,
    ...s
  } = e, {
    template: a
  } = (t == null ? void 0 : t.llm) || {}, {
    language: c
  } = ((r = t == null ? void 0 : t.presenter) == null ? void 0 : r.voice) || {}, {
    stitch: d
  } = (t == null ? void 0 : t.presenter) || {};
  return {
    ...s,
    llm: {
      ...s.llm,
      template: a
    },
    script: {
      ...s.script,
      provider: {
        ...(i = s == null ? void 0 : s.script) == null ? void 0 : i.provider,
        language: c
      }
    },
    stitch: d,
    ...n
  };
}
let qe = 0;
function Da(e, t) {
  var n, r, i, o, s, a, c;
  return e.presenter.type === kt.Clip ? {
    videoType: kt.Clip,
    session_timeout: (n = t == null ? void 0 : t.streamOptions) == null ? void 0 : n.sessionTimeout,
    stream_warmup: (r = t == null ? void 0 : t.streamOptions) == null ? void 0 : r.streamWarmup,
    compatibility_mode: (i = t == null ? void 0 : t.streamOptions) == null ? void 0 : i.compatibilityMode
  } : {
    videoType: kt.Talk,
    session_timeout: (o = t == null ? void 0 : t.streamOptions) == null ? void 0 : o.sessionTimeout,
    stream_warmup: (s = t == null ? void 0 : t.streamOptions) == null ? void 0 : s.streamWarmup,
    compatibility_mode: (a = t == null ? void 0 : t.streamOptions) == null ? void 0 : a.compatibilityMode,
    output_resolution: (c = t == null ? void 0 : t.streamOptions) == null ? void 0 : c.outputResolution
  };
}
function Ro(e) {
  return e === C.Playground ? {
    headers: {
      [Ia]: "true"
    }
  } : {};
}
async function Lo(e, t, n, r) {
  try {
    const i = await t.newChat(e, {
      persist: !0
    }, Ro(r));
    return n.track("agent-chat", {
      event: "created",
      chat_id: i.id,
      agent_id: e,
      mode: r
    }), i;
  } catch (i) {
    try {
      console.error(i);
      const o = JSON.parse(i.message);
      if ((o == null ? void 0 : o.kind) === "InsufficientCreditsError")
        throw new Error("InsufficientCreditsError");
    } catch (o) {
      console.error("Error parsing the error message:", o);
    }
    throw new Error("Cannot create new chat");
  }
}
function Fa(e, t, n, r, i) {
  return new Promise(async (o, s) => {
    var a;
    qe = 0;
    const c = await La(e.id, Da(e, t), {
      ...t,
      analytics: r,
      warmup: (a = t.streamOptions) == null ? void 0 : a.streamWarmup,
      callbacks: {
        ...t.callbacks,
        onConnectionStateChange: async (d) => {
          var l, u;
          d === P.Connected && (!i && t.mode !== C.DirectPlayback && (i = await Lo(e.id, n, r, t.mode).catch((p) => {
            s(p);
          })), c ? o({
            chat: i,
            streamingManager: c
          }) : i && s(new Error("Something went wrong while initializing the manager"))), (u = (l = t.callbacks).onConnectionStateChange) == null || u.call(l, d);
        },
        onVideoStateChange(d) {
          var l, u;
          (u = (l = t.callbacks).onVideoStateChange) == null || u.call(l, d), qe > 0 && d === Ze.Start && r.linkTrack("agent-video", {
            event: "start",
            latency: Date.now() - qe
          }, "start", [Sr.StreamVideoCreated]);
        }
      }
    }).catch(s);
  });
}
function ni(e, t) {
  if (t && t.length > 0)
    return t;
  let n = "";
  if (e.greetings && e.greetings.length > 0) {
    const r = Math.floor(Math.random() * e.greetings.length);
    n = e.greetings[r];
  } else
    n = `Hi! I'm ${e.preview_name || "My Agent"}. How can I help you?`;
  return [{
    content: n,
    id: fn(),
    role: "assistant",
    created_at: (/* @__PURE__ */ new Date()).toISOString()
  }];
}
function Ha(e) {
  if (e.answer !== void 0)
    return e.answer;
  let t = 0, n = "";
  for (; t in e; )
    n += e[t], t++;
  return n;
}
function Ua(e, t, n, r, i) {
  if (!(e === st.Partial || e === st.Answer))
    return;
  const o = r.messages[r.messages.length - 1];
  if ((o == null ? void 0 : o.role) !== "assistant")
    return;
  const {
    content: s,
    sequence: a
  } = t;
  e === st.Partial ? n[a] = s : n.answer = s;
  const c = Ha(n);
  (o.content !== c || e === st.Answer) && (o.content = c, i == null || i([...r.messages], e));
}
async function Ba(e, t) {
  var n, r, i;
  let o = {}, s = !0;
  const a = {
    messages: [],
    chatMode: t.mode || C.Functional
  }, c = t.baseURL || En, d = t.wsURL || va, l = t.mixpanelKey || Sa, u = Ea(t.auth, c, t.callbacks.onError), p = await u.getById(e);
  a.messages = ni(p, t.initialMessages), (r = (n = t.callbacks).onNewMessage) == null || r.call(n, [...a.messages], "answer");
  const f = Oa({
    token: l,
    agent: p,
    ...t
  });
  f.track("agent-sdk", {
    event: "loaded",
    ...Pa(p)
  });
  const _ = {
    onMessage: (h, y) => {
      var T, w;
      if ("content" in y)
        Ua(h, y, o, a, t.callbacks.onNewMessage), h === st.Answer && f.track("agent-message-received", {
          messages: a.messages.length,
          mode: a.chatMode
        });
      else {
        const m = Sr, k = [m.StreamVideoDone, m.StreamVideoError, m.StreamVideoRejected], N = [m.StreamFailed, m.StreamVideoError, m.StreamVideoRejected], R = $a(y, p, {
          mode: a.chatMode
        });
        if (h = h, h === m.StreamVideoCreated)
          f.linkTrack("agent-video", R, m.StreamVideoCreated, ["start"]);
        else if (k.includes(h)) {
          const D = h.split("/")[1];
          f.track("agent-video", {
            ...R,
            event: D
          });
        }
        N.includes(h) && ((w = (T = t.callbacks).onError) == null || w.call(T, new Error(`Stream failed with event ${h}`), {
          data: y
        })), y.event === m.StreamDone && b();
      }
    }
  };
  async function S(h) {
    var y, T, w, m, k, N, R;
    (T = (y = t.callbacks).onConnectionStateChange) == null || T.call(y, P.Connecting), qe = 0, h && !s && (delete a.chat, a.messages = ni(p), (m = (w = t.callbacks).onNewMessage) == null || m.call(w, [...a.messages], "answer"));
    const D = t.mode === C.DirectPlayback ? Promise.resolve(void 0) : ka(t.auth, d, _), z = Fa(p, t, u, f, a.chat).catch((G) => {
      var j, re;
      throw E(C.Maintenance), (re = (j = t.callbacks).onConnectionStateChange) == null || re.call(j, P.Fail), G;
    }), [Z, {
      streamingManager: q,
      chat: M
    }] = await Promise.all([D, z]);
    M && M.id !== ((k = a.chat) == null ? void 0 : k.id) && ((R = (N = t.callbacks).onNewChat) == null || R.call(N, M.id)), a.streamingManager = q, a.socketManager = Z, a.chat = M, s = !1, E((M == null ? void 0 : M.chat_mode) ?? t.mode ?? C.Functional);
  }
  async function b() {
    var h, y, T, w;
    (h = a.socketManager) == null || h.disconnect(), await ((y = a.streamingManager) == null ? void 0 : y.disconnect()), delete a.streamingManager, delete a.socketManager, (w = (T = t.callbacks).onConnectionStateChange) == null || w.call(T, P.Disconnected);
  }
  async function E(h) {
    var y, T;
    h !== a.chatMode && (f.track("agent-mode-change", {
      mode: h
    }), a.chatMode = h, a.chatMode !== C.Functional && await b(), (T = (y = t.callbacks).onModeChange) == null || T.call(y, h));
  }
  return {
    agent: p,
    starterMessages: ((i = p.knowledge) == null ? void 0 : i.starter_message) || [],
    changeMode: E,
    async connect() {
      var h;
      await S(!0), f.track("agent-chat", {
        event: "connect",
        chatId: (h = a.chat) == null ? void 0 : h.id,
        agentId: p.id,
        mode: a.chatMode
      });
    },
    async reconnect() {
      var h;
      await b(), await S(!1), f.track("agent-chat", {
        event: "reconnect",
        chatId: (h = a.chat) == null ? void 0 : h.id,
        agentId: p.id,
        mode: a.chatMode
      });
    },
    async disconnect() {
      var h;
      await b(), f.track("agent-chat", {
        event: "disconnect",
        chatId: (h = a.chat) == null ? void 0 : h.id,
        agentId: p.id,
        mode: a.chatMode
      });
    },
    async chat(h) {
      var y, T, w, m, k, N;
      const R = fn();
      o = {};
      try {
        if (qe = Date.now(), t.mode === C.DirectPlayback)
          throw new Error("Direct playback is enabled, chat is disabled");
        if (h.length >= 800)
          throw new Error("Message cannot be more than 800 characters");
        if (h.length === 0)
          throw new Error("Message cannot be empty");
        if (a.chatMode === C.Maintenance)
          throw new Error("Chat is in maintenance mode");
        if (![C.TextOnly, C.Playground].includes(a.chatMode))
          if (a.streamingManager) {
            if (!a.chat)
              throw new Error("Chat is not initialized");
          } else
            throw new Error("Streaming manager is not initialized");
        a.messages.push({
          id: fn(),
          role: "user",
          content: h,
          created_at: new Date(qe).toISOString()
        }), (T = (y = t.callbacks).onNewMessage) == null || T.call(y, [...a.messages], "user"), a.chat || (a.chat = await Lo(p.id, u, f, a.chatMode), (m = (w = t.callbacks).onNewChat) == null || m.call(w, a.chat.id));
        const D = {
          id: R,
          role: "assistant",
          content: "",
          created_at: (/* @__PURE__ */ new Date()).toISOString(),
          matches: []
        }, z = [...a.messages];
        a.messages.push(D);
        const Z = (M) => {
          var G, j;
          return u.chat(p.id, M, {
            sessionId: (G = a.streamingManager) == null ? void 0 : G.sessionId,
            streamId: (j = a.streamingManager) == null ? void 0 : j.streamId,
            chatMode: a.chatMode,
            messages: z.map(({
              matches: re,
              ...te
            }) => te)
          }, Ro(a.chatMode));
        }, q = await Z(a.chat.id).catch(async (M) => {
          var G;
          if (!((G = M == null ? void 0 : M.message) != null && G.includes("missing or invalid session_id")))
            throw M;
          return await b(), await S(!1), Z(a.chat.id);
        });
        return f.track("agent-message-send", {
          event: "success",
          mode: a.chatMode,
          messages: a.messages.length + 1
        }), D.context = q.context, D.matches = q.matches, q.result && (D.content = q.result, f.track("agent-message-received", {
          latency: Date.now() - qe,
          mode: a.chatMode,
          messages: a.messages.length
        }), (N = (k = t.callbacks).onNewMessage) == null || N.call(k, [...a.messages], "answer")), q;
      } catch (D) {
        throw a.messages[a.messages.length - 1].id === R && a.messages.pop(), f.track("agent-message-send", {
          event: "error",
          mode: a.chatMode,
          messages: a.messages.length
        }), D;
      }
    },
    rate(h, y, T) {
      var w, m, k, N;
      const R = a.messages.find((z) => z.id === h);
      if (a.chat) {
        if (!R)
          throw new Error("Message not found");
      } else
        throw new Error("Chat is not initialized");
      const D = ((w = R.matches) == null ? void 0 : w.map((z) => [z.document_id, z.id])) ?? [];
      return f.track("agent-rate", {
        event: T ? "update" : "create",
        thumb: y === 1 ? "up" : "down",
        knowledge_id: ((m = p.knowledge) == null ? void 0 : m.id) ?? "",
        mode: a.chatMode,
        matches: D,
        score: y
      }), T ? u.updateRating(p.id, a.chat.id, T, {
        knowledge_id: ((k = p.knowledge) == null ? void 0 : k.id) ?? "",
        message_id: h,
        matches: D,
        score: y
      }) : u.createRating(p.id, a.chat.id, {
        knowledge_id: ((N = p.knowledge) == null ? void 0 : N.id) ?? "",
        message_id: h,
        matches: D,
        score: y
      });
    },
    deleteRate(h) {
      var y;
      if (!a.chat)
        throw new Error("Chat is not initialized");
      return f.track("agent-rate-delete", {
        type: "text",
        chat_id: (y = a.chat) == null ? void 0 : y.id,
        id: h,
        mode: a.chatMode
      }), u.deleteRating(p.id, a.chat.id, h);
    },
    speak(h) {
      if (!a.streamingManager)
        throw new Error("Please connect to the agent first");
      function y() {
        if (typeof h == "string") {
          if (!p.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: p.presenter.voice,
            input: h,
            ssml: !1
          };
        }
        if (h.type === "text" && !h.provider) {
          if (!p.presenter.voice)
            throw new Error("Presenter voice is not initialized");
          return {
            type: "text",
            provider: p.presenter.voice,
            input: h.input,
            ssml: h.ssml
          };
        }
        return h;
      }
      const T = y();
      return f.track("agent-speak", T), a.streamingManager.speak({
        script: T
      });
    }
  };
}
var wn, x, Oo, je, ri, Po, qn, Er, Gn, Wn, $o, Nt = {}, Do = [], ja = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, Tn = Array.isArray;
function Oe(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}
function Fo(e) {
  var t = e.parentNode;
  t && t.removeChild(e);
}
function At(e, t, n) {
  var r, i, o, s = {};
  for (o in t)
    o == "key" ? r = t[o] : o == "ref" ? i = t[o] : s[o] = t[o];
  if (arguments.length > 2 && (s.children = arguments.length > 3 ? wn.call(arguments, 2) : n), typeof e == "function" && e.defaultProps != null)
    for (o in e.defaultProps)
      s[o] === void 0 && (s[o] = e.defaultProps[o]);
  return on(e, s, r, i, null);
}
function on(e, t, n, r, i) {
  var o = { type: e, props: t, key: n, ref: r, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: i ?? ++Oo, __i: -1, __u: 0 };
  return i == null && x.vnode != null && x.vnode(o), o;
}
function Fe(e) {
  return e.children;
}
function Ie(e, t) {
  this.props = e, this.context = t;
}
function Ye(e, t) {
  if (t == null)
    return e.__ ? Ye(e.__, e.__i + 1) : null;
  for (var n; t < e.__k.length; t++)
    if ((n = e.__k[t]) != null && n.__e != null)
      return n.__e;
  return typeof e.type == "function" ? Ye(e) : null;
}
function Ho(e) {
  var t, n;
  if ((e = e.__) != null && e.__c != null) {
    for (e.__e = e.__c.base = null, t = 0; t < e.__k.length; t++)
      if ((n = e.__k[t]) != null && n.__e != null) {
        e.__e = e.__c.base = n.__e;
        break;
      }
    return Ho(e);
  }
}
function zn(e) {
  (!e.__d && (e.__d = !0) && je.push(e) && !pn.__r++ || ri !== x.debounceRendering) && ((ri = x.debounceRendering) || Po)(pn);
}
function pn() {
  var e, t, n, r, i, o, s, a;
  for (je.sort(qn); e = je.shift(); )
    e.__d && (t = je.length, r = void 0, o = (i = (n = e).__v).__e, s = [], a = [], n.__P && ((r = Oe({}, i)).__v = i.__v + 1, x.vnode && x.vnode(r), wr(n.__P, r, i, n.__n, n.__P.namespaceURI, 32 & i.__u ? [o] : null, s, o ?? Ye(i), !!(32 & i.__u), a), r.__v = i.__v, r.__.__k[r.__i] = r, jo(s, r, a), r.__e != o && Ho(r)), je.length > t && je.sort(qn));
  pn.__r = 0;
}
function Uo(e, t, n, r, i, o, s, a, c, d, l) {
  var u, p, f, _, S, b = r && r.__k || Do, E = t.length;
  for (n.__d = c, Va(n, t, b), c = n.__d, u = 0; u < E; u++)
    (f = n.__k[u]) != null && typeof f != "boolean" && typeof f != "function" && (p = f.__i === -1 ? Nt : b[f.__i] || Nt, f.__i = u, wr(e, f, p, i, o, s, a, c, d, l), _ = f.__e, f.ref && p.ref != f.ref && (p.ref && Tr(p.ref, null, f), l.push(f.ref, f.__c || _, f)), S == null && _ != null && (S = _), 65536 & f.__u || p.__k === f.__k ? (c && !c.isConnected && (c = Ye(p)), c = Bo(f, c, e)) : typeof f.type == "function" && f.__d !== void 0 ? c = f.__d : _ && (c = _.nextSibling), f.__d = void 0, f.__u &= -196609);
  n.__d = c, n.__e = S;
}
function Va(e, t, n) {
  var r, i, o, s, a, c = t.length, d = n.length, l = d, u = 0;
  for (e.__k = [], r = 0; r < c; r++)
    s = r + u, (i = e.__k[r] = (i = t[r]) == null || typeof i == "boolean" || typeof i == "function" ? null : typeof i == "string" || typeof i == "number" || typeof i == "bigint" || i.constructor == String ? on(null, i, null, null, null) : Tn(i) ? on(Fe, { children: i }, null, null, null) : i.constructor === void 0 && i.__b > 0 ? on(i.type, i.props, i.key, i.ref ? i.ref : null, i.__v) : i) != null ? (i.__ = e, i.__b = e.__b + 1, a = qa(i, n, s, l), i.__i = a, o = null, a !== -1 && (l--, (o = n[a]) && (o.__u |= 131072)), o == null || o.__v === null ? (a == -1 && u--, typeof i.type != "function" && (i.__u |= 65536)) : a !== s && (a === s + 1 ? u++ : a > s ? l > c - s ? u += a - s : u-- : a < s ? a == s - 1 && (u = a - s) : u = 0, a !== r + u && (i.__u |= 65536))) : (o = n[s]) && o.key == null && o.__e && !(131072 & o.__u) && (o.__e == e.__d && (e.__d = Ye(o)), Zn(o, o, !1), n[s] = null, l--);
  if (l)
    for (r = 0; r < d; r++)
      (o = n[r]) != null && !(131072 & o.__u) && (o.__e == e.__d && (e.__d = Ye(o)), Zn(o, o));
}
function Bo(e, t, n) {
  var r, i;
  if (typeof e.type == "function") {
    for (r = e.__k, i = 0; r && i < r.length; i++)
      r[i] && (r[i].__ = e, t = Bo(r[i], t, n));
    return t;
  }
  e.__e != t && (n.insertBefore(e.__e, t || null), t = e.__e);
  do
    t = t && t.nextSibling;
  while (t != null && t.nodeType === 8);
  return t;
}
function _n(e, t) {
  return t = t || [], e == null || typeof e == "boolean" || (Tn(e) ? e.some(function(n) {
    _n(n, t);
  }) : t.push(e)), t;
}
function qa(e, t, n, r) {
  var i = e.key, o = e.type, s = n - 1, a = n + 1, c = t[n];
  if (c === null || c && i == c.key && o === c.type && !(131072 & c.__u))
    return n;
  if (r > (c != null && !(131072 & c.__u) ? 1 : 0))
    for (; s >= 0 || a < t.length; ) {
      if (s >= 0) {
        if ((c = t[s]) && !(131072 & c.__u) && i == c.key && o === c.type)
          return s;
        s--;
      }
      if (a < t.length) {
        if ((c = t[a]) && !(131072 & c.__u) && i == c.key && o === c.type)
          return a;
        a++;
      }
    }
  return -1;
}
function ii(e, t, n) {
  t[0] === "-" ? e.setProperty(t, n ?? "") : e[t] = n == null ? "" : typeof n != "number" || ja.test(t) ? n : n + "px";
}
function Yt(e, t, n, r, i) {
  var o;
  e:
    if (t === "style")
      if (typeof n == "string")
        e.style.cssText = n;
      else {
        if (typeof r == "string" && (e.style.cssText = r = ""), r)
          for (t in r)
            n && t in n || ii(e.style, t, "");
        if (n)
          for (t in n)
            r && n[t] === r[t] || ii(e.style, t, n[t]);
      }
    else if (t[0] === "o" && t[1] === "n")
      o = t !== (t = t.replace(/(PointerCapture)$|Capture$/i, "$1")), t = t.toLowerCase() in e || t === "onFocusOut" || t === "onFocusIn" ? t.toLowerCase().slice(2) : t.slice(2), e.l || (e.l = {}), e.l[t + o] = n, n ? r ? n.u = r.u : (n.u = Er, e.addEventListener(t, o ? Wn : Gn, o)) : e.removeEventListener(t, o ? Wn : Gn, o);
    else {
      if (i == "http://www.w3.org/2000/svg")
        t = t.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
      else if (t != "width" && t != "height" && t != "href" && t != "list" && t != "form" && t != "tabIndex" && t != "download" && t != "rowSpan" && t != "colSpan" && t != "role" && t in e)
        try {
          e[t] = n ?? "";
          break e;
        } catch {
        }
      typeof n == "function" || (n == null || n === !1 && t[4] !== "-" ? e.removeAttribute(t) : e.setAttribute(t, n));
    }
}
function oi(e) {
  return function(t) {
    if (this.l) {
      var n = this.l[t.type + e];
      if (t.t == null)
        t.t = Er++;
      else if (t.t < n.u)
        return;
      return n(x.event ? x.event(t) : t);
    }
  };
}
function wr(e, t, n, r, i, o, s, a, c, d) {
  var l, u, p, f, _, S, b, E, h, y, T, w, m, k, N, R = t.type;
  if (t.constructor !== void 0)
    return null;
  128 & n.__u && (c = !!(32 & n.__u), o = [a = t.__e = n.__e]), (l = x.__b) && l(t);
  e:
    if (typeof R == "function")
      try {
        if (E = t.props, h = (l = R.contextType) && r[l.__c], y = l ? h ? h.props.value : l.__ : r, n.__c ? b = (u = t.__c = n.__c).__ = u.__E : ("prototype" in R && R.prototype.render ? t.__c = u = new R(E, y) : (t.__c = u = new Ie(E, y), u.constructor = R, u.render = Wa), h && h.sub(u), u.props = E, u.state || (u.state = {}), u.context = y, u.__n = r, p = u.__d = !0, u.__h = [], u._sb = []), u.__s == null && (u.__s = u.state), R.getDerivedStateFromProps != null && (u.__s == u.state && (u.__s = Oe({}, u.__s)), Oe(u.__s, R.getDerivedStateFromProps(E, u.__s))), f = u.props, _ = u.state, u.__v = t, p)
          R.getDerivedStateFromProps == null && u.componentWillMount != null && u.componentWillMount(), u.componentDidMount != null && u.__h.push(u.componentDidMount);
        else {
          if (R.getDerivedStateFromProps == null && E !== f && u.componentWillReceiveProps != null && u.componentWillReceiveProps(E, y), !u.__e && (u.shouldComponentUpdate != null && u.shouldComponentUpdate(E, u.__s, y) === !1 || t.__v === n.__v)) {
            for (t.__v !== n.__v && (u.props = E, u.state = u.__s, u.__d = !1), t.__e = n.__e, t.__k = n.__k, t.__k.forEach(function(D) {
              D && (D.__ = t);
            }), T = 0; T < u._sb.length; T++)
              u.__h.push(u._sb[T]);
            u._sb = [], u.__h.length && s.push(u);
            break e;
          }
          u.componentWillUpdate != null && u.componentWillUpdate(E, u.__s, y), u.componentDidUpdate != null && u.__h.push(function() {
            u.componentDidUpdate(f, _, S);
          });
        }
        if (u.context = y, u.props = E, u.__P = e, u.__e = !1, w = x.__r, m = 0, "prototype" in R && R.prototype.render) {
          for (u.state = u.__s, u.__d = !1, w && w(t), l = u.render(u.props, u.state, u.context), k = 0; k < u._sb.length; k++)
            u.__h.push(u._sb[k]);
          u._sb = [];
        } else
          do
            u.__d = !1, w && w(t), l = u.render(u.props, u.state, u.context), u.state = u.__s;
          while (u.__d && ++m < 25);
        u.state = u.__s, u.getChildContext != null && (r = Oe(Oe({}, r), u.getChildContext())), p || u.getSnapshotBeforeUpdate == null || (S = u.getSnapshotBeforeUpdate(f, _)), Uo(e, Tn(N = l != null && l.type === Fe && l.key == null ? l.props.children : l) ? N : [N], t, n, r, i, o, s, a, c, d), u.base = t.__e, t.__u &= -161, u.__h.length && s.push(u), b && (u.__E = u.__ = null);
      } catch (D) {
        t.__v = null, c || o != null ? (t.__e = a, t.__u |= c ? 160 : 32, o[o.indexOf(a)] = null) : (t.__e = n.__e, t.__k = n.__k), x.__e(D, t, n);
      }
    else
      o == null && t.__v === n.__v ? (t.__k = n.__k, t.__e = n.__e) : t.__e = Ga(n.__e, t, n, r, i, o, s, c, d);
  (l = x.diffed) && l(t);
}
function jo(e, t, n) {
  t.__d = void 0;
  for (var r = 0; r < n.length; r++)
    Tr(n[r], n[++r], n[++r]);
  x.__c && x.__c(t, e), e.some(function(i) {
    try {
      e = i.__h, i.__h = [], e.some(function(o) {
        o.call(i);
      });
    } catch (o) {
      x.__e(o, i.__v);
    }
  });
}
function Ga(e, t, n, r, i, o, s, a, c) {
  var d, l, u, p, f, _, S, b = n.props, E = t.props, h = t.type;
  if (h === "svg" ? i = "http://www.w3.org/2000/svg" : h === "math" ? i = "http://www.w3.org/1998/Math/MathML" : i || (i = "http://www.w3.org/1999/xhtml"), o != null) {
    for (d = 0; d < o.length; d++)
      if ((f = o[d]) && "setAttribute" in f == !!h && (h ? f.localName === h : f.nodeType === 3)) {
        e = f, o[d] = null;
        break;
      }
  }
  if (e == null) {
    if (h === null)
      return document.createTextNode(E);
    e = document.createElementNS(i, h, E.is && E), o = null, a = !1;
  }
  if (h === null)
    b === E || a && e.data === E || (e.data = E);
  else {
    if (o = o && wn.call(e.childNodes), b = n.props || Nt, !a && o != null)
      for (b = {}, d = 0; d < e.attributes.length; d++)
        b[(f = e.attributes[d]).name] = f.value;
    for (d in b)
      if (f = b[d], d != "children") {
        if (d == "dangerouslySetInnerHTML")
          u = f;
        else if (d !== "key" && !(d in E)) {
          if (d == "value" && "defaultValue" in E || d == "checked" && "defaultChecked" in E)
            continue;
          Yt(e, d, null, f, i);
        }
      }
    for (d in E)
      f = E[d], d == "children" ? p = f : d == "dangerouslySetInnerHTML" ? l = f : d == "value" ? _ = f : d == "checked" ? S = f : d === "key" || a && typeof f != "function" || b[d] === f || Yt(e, d, f, b[d], i);
    if (l)
      a || u && (l.__html === u.__html || l.__html === e.innerHTML) || (e.innerHTML = l.__html), t.__k = [];
    else if (u && (e.innerHTML = ""), Uo(e, Tn(p) ? p : [p], t, n, r, h === "foreignObject" ? "http://www.w3.org/1999/xhtml" : i, o, s, o ? o[0] : n.__k && Ye(n, 0), a, c), o != null)
      for (d = o.length; d--; )
        o[d] != null && Fo(o[d]);
    a || (d = "value", _ !== void 0 && (_ !== e[d] || h === "progress" && !_ || h === "option" && _ !== b[d]) && Yt(e, d, _, b[d], i), d = "checked", S !== void 0 && S !== e[d] && Yt(e, d, S, b[d], i));
  }
  return e;
}
function Tr(e, t, n) {
  try {
    typeof e == "function" ? e(t) : e.current = t;
  } catch (r) {
    x.__e(r, n);
  }
}
function Zn(e, t, n) {
  var r, i;
  if (x.unmount && x.unmount(e), (r = e.ref) && (r.current && r.current !== e.__e || Tr(r, null, t)), (r = e.__c) != null) {
    if (r.componentWillUnmount)
      try {
        r.componentWillUnmount();
      } catch (o) {
        x.__e(o, t);
      }
    r.base = r.__P = null;
  }
  if (r = e.__k)
    for (i = 0; i < r.length; i++)
      r[i] && Zn(r[i], t, n || typeof e.type != "function");
  n || e.__e == null || Fo(e.__e), e.__c = e.__ = e.__e = e.__d = void 0;
}
function Wa(e, t, n) {
  return this.constructor(e, n);
}
function hn(e, t, n) {
  var r, i, o, s;
  x.__ && x.__(e, t), i = (r = typeof n == "function") ? null : t.__k, o = [], s = [], wr(t, e = (!r && n || t).__k = At(Fe, null, [e]), i || Nt, Nt, t.namespaceURI, !r && n ? [n] : i ? null : t.firstChild ? wn.call(t.childNodes) : null, o, !r && n ? n : i ? i.__e : t.firstChild, r, s), jo(o, e, s);
}
function Cr(e, t) {
  var n = { __c: t = "__cC" + $o++, __: e, Consumer: function(r, i) {
    return r.children(i);
  }, Provider: function(r) {
    var i, o;
    return this.getChildContext || (i = [], (o = {})[t] = this, this.getChildContext = function() {
      return o;
    }, this.shouldComponentUpdate = function(s) {
      this.props.value !== s.value && i.some(function(a) {
        a.__e = !0, zn(a);
      });
    }, this.sub = function(s) {
      i.push(s);
      var a = s.componentWillUnmount;
      s.componentWillUnmount = function() {
        i.splice(i.indexOf(s), 1), a && a.call(s);
      };
    }), r.children;
  } };
  return n.Provider.__ = n.Consumer.contextType = n;
}
wn = Do.slice, x = { __e: function(e, t, n, r) {
  for (var i, o, s; t = t.__; )
    if ((i = t.__c) && !i.__)
      try {
        if ((o = i.constructor) && o.getDerivedStateFromError != null && (i.setState(o.getDerivedStateFromError(e)), s = i.__d), i.componentDidCatch != null && (i.componentDidCatch(e, r || {}), s = i.__d), s)
          return i.__E = i;
      } catch (a) {
        e = a;
      }
  throw e;
} }, Oo = 0, Ie.prototype.setState = function(e, t) {
  var n;
  n = this.__s != null && this.__s !== this.state ? this.__s : this.__s = Oe({}, this.state), typeof e == "function" && (e = e(Oe({}, n), this.props)), e && Oe(n, e), e != null && this.__v && (t && this._sb.push(t), zn(this));
}, Ie.prototype.forceUpdate = function(e) {
  this.__v && (this.__e = !0, e && this.__h.push(e), zn(this));
}, Ie.prototype.render = Fe, je = [], Po = typeof Promise == "function" ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, qn = function(e, t) {
  return e.__v.__b - t.__v.__b;
}, pn.__r = 0, Er = 0, Gn = oi(!1), Wn = oi(!0), $o = 0;
const za = "https://a4cf74d1408b08300392573972263164@o226878.ingest.us.sentry.io/4507283201064960", Za = "prod", Ya = "https://api.d-id.com", Ka = "wss://notifications.d-id.com", Xa = "1.0.143", Yn = {
  mixpanelKey: "79f81a83a67430be2bc0fd61042b8faa"
};
function Vo() {
  return Math.random().toString(16).slice(2);
}
function Ja() {
  const e = localStorage.getItem("tracking_id") ?? Vo();
  return localStorage.setItem("tracking_id", e), e;
}
const qo = {
  token: Yn.mixpanelKey,
  $insert_id: Vo(),
  origin: window.location.href,
  "Screen Height": window.screen.height || window.innerWidth,
  "Screen Width": window.screen.width || window.innerHeight,
  "User Agent": navigator.userAgent
};
function si(e) {
  Object.assign(qo, e);
}
function De(e, t) {
  if (window.localStorage.getItem("track_enabled") === "false")
    return;
  const n = {
    method: "POST",
    headers: {
      "Content-Type": "application/x-www-form-urlencoded"
    },
    body: new URLSearchParams({
      data: JSON.stringify([{
        event: e,
        properties: {
          ...t,
          time: Date.now(),
          distinct_id: Ja(),
          ...qo,
          agent_ui_version: Xa
        }
      }])
    })
  };
  return fetch("https://api-js.mixpanel.com/track/?verbose=1&ip=1", n).then((r) => r.json()).catch((r) => console.error(r));
}
var He, B, Pn, ai, xt = 0, Go = [], sn = [], K = x, ci = K.__b, ui = K.__r, di = K.diffed, li = K.__c, fi = K.unmount, pi = K.__;
function gt(e, t) {
  K.__h && K.__h(B, e, xt || t), xt = 0;
  var n = B.__H || (B.__H = { __: [], __h: [] });
  return e >= n.__.length && n.__.push({ __V: sn }), n.__[e];
}
function L(e) {
  return xt = 1, Qa(Wo, e);
}
function Qa(e, t, n) {
  var r = gt(He++, 2);
  if (r.t = e, !r.__c && (r.__ = [n ? n(t) : Wo(void 0, t), function(a) {
    var c = r.__N ? r.__N[0] : r.__[0], d = r.t(c, a);
    c !== d && (r.__N = [d, r.__[1]], r.__c.setState({}));
  }], r.__c = B, !B.u)) {
    var i = function(a, c, d) {
      if (!r.__c.__H)
        return !0;
      var l = r.__c.__H.__.filter(function(p) {
        return !!p.__c;
      });
      if (l.every(function(p) {
        return !p.__N;
      }))
        return !o || o.call(this, a, c, d);
      var u = !1;
      return l.forEach(function(p) {
        if (p.__N) {
          var f = p.__[0];
          p.__ = p.__N, p.__N = void 0, f !== p.__[0] && (u = !0);
        }
      }), !(!u && r.__c.props === a) && (!o || o.call(this, a, c, d));
    };
    B.u = !0;
    var o = B.shouldComponentUpdate, s = B.componentWillUpdate;
    B.componentWillUpdate = function(a, c, d) {
      if (this.__e) {
        var l = o;
        o = void 0, i(a, c, d), o = l;
      }
      s && s.call(this, a, c, d);
    }, B.shouldComponentUpdate = i;
  }
  return r.__N || r.__;
}
function J(e, t) {
  var n = gt(He++, 3);
  !K.__s && kr(n.__H, t) && (n.__ = e, n.i = t, B.__H.__h.push(n));
}
function ec(e, t) {
  var n = gt(He++, 4);
  !K.__s && kr(n.__H, t) && (n.__ = e, n.i = t, B.__h.push(n));
}
function Te(e) {
  return xt = 5, Cn(function() {
    return { current: e };
  }, []);
}
function Cn(e, t) {
  var n = gt(He++, 7);
  return kr(n.__H, t) ? (n.__V = e(), n.i = t, n.__h = e, n.__V) : n.__;
}
function Rt(e, t) {
  return xt = 8, Cn(function() {
    return e;
  }, t);
}
function fe(e) {
  var t = B.context[e.__c], n = gt(He++, 9);
  return n.c = e, t ? (n.__ == null && (n.__ = !0, t.sub(B)), t.props.value) : e.__;
}
function tc(e) {
  var t = gt(He++, 10), n = L();
  return t.__ = e, B.componentDidCatch || (B.componentDidCatch = function(r, i) {
    t.__ && t.__(r, i), n[1](r);
  }), [n[0], function() {
    n[1](void 0);
  }];
}
function nc() {
  for (var e; e = Go.shift(); )
    if (e.__P && e.__H)
      try {
        e.__H.__h.forEach(an), e.__H.__h.forEach(Kn), e.__H.__h = [];
      } catch (t) {
        e.__H.__h = [], K.__e(t, e.__v);
      }
}
K.__b = function(e) {
  B = null, ci && ci(e);
}, K.__ = function(e, t) {
  e && t.__k && t.__k.__m && (e.__m = t.__k.__m), pi && pi(e, t);
}, K.__r = function(e) {
  ui && ui(e), He = 0;
  var t = (B = e.__c).__H;
  t && (Pn === B ? (t.__h = [], B.__h = [], t.__.forEach(function(n) {
    n.__N && (n.__ = n.__N), n.__V = sn, n.__N = n.i = void 0;
  })) : (t.__h.forEach(an), t.__h.forEach(Kn), t.__h = [], He = 0)), Pn = B;
}, K.diffed = function(e) {
  di && di(e);
  var t = e.__c;
  t && t.__H && (t.__H.__h.length && (Go.push(t) !== 1 && ai === K.requestAnimationFrame || ((ai = K.requestAnimationFrame) || rc)(nc)), t.__H.__.forEach(function(n) {
    n.i && (n.__H = n.i), n.__V !== sn && (n.__ = n.__V), n.i = void 0, n.__V = sn;
  })), Pn = B = null;
}, K.__c = function(e, t) {
  t.some(function(n) {
    try {
      n.__h.forEach(an), n.__h = n.__h.filter(function(r) {
        return !r.__ || Kn(r);
      });
    } catch (r) {
      t.some(function(i) {
        i.__h && (i.__h = []);
      }), t = [], K.__e(r, n.__v);
    }
  }), li && li(e, t);
}, K.unmount = function(e) {
  fi && fi(e);
  var t, n = e.__c;
  n && n.__H && (n.__H.__.forEach(function(r) {
    try {
      an(r);
    } catch (i) {
      t = i;
    }
  }), n.__H = void 0, t && K.__e(t, n.__v));
};
var _i = typeof requestAnimationFrame == "function";
function rc(e) {
  var t, n = function() {
    clearTimeout(r), _i && cancelAnimationFrame(t), setTimeout(e);
  }, r = setTimeout(n, 100);
  _i && (t = requestAnimationFrame(n));
}
function an(e) {
  var t = B, n = e.__c;
  typeof n == "function" && (e.__c = void 0, n()), B = t;
}
function Kn(e) {
  var t = B;
  e.__c = e.__(), B = t;
}
function kr(e, t) {
  return !e || e.length !== t.length || t.some(function(n, r) {
    return n !== e[r];
  });
}
function Wo(e, t) {
  return typeof t == "function" ? t(e) : t;
}
var ic = 0;
function g(e, t, n, r, i, o) {
  t || (t = {});
  var s, a, c = t;
  if ("ref" in c)
    for (a in c = {}, t)
      a == "ref" ? s = t[a] : c[a] = t[a];
  var d = { type: e, props: c, key: n, ref: s, __k: null, __: null, __b: 0, __e: null, __d: void 0, __c: null, constructor: void 0, __v: --ic, __i: -1, __u: 0, __source: i, __self: o };
  if (typeof e == "function" && (s = e.defaultProps))
    for (a in s)
      c[a] === void 0 && (c[a] = s[a]);
  return x.vnode && x.vnode(d), d;
}
const zo = {
  mode: "fabio",
  visible: !0,
  agentId: "",
  track: !0,
  chatMode: C.Functional,
  loaderConfig: {
    show: !0,
    style: "opaque",
    text: "Loading..."
  },
  orientation: "vertical",
  position: "right"
}, Be = Cr({
  configure: () => {
  },
  configurations: zo
}), oc = ({
  children: e,
  initialConfigurations: t
}) => {
  const [n, r] = L({
    ...zo,
    ...t
  }), i = Rt((o) => r((s) => ({
    ...s,
    ...o
  })), [r]);
  return J(() => {
    window.DID_AGENTS_API.configure = i;
  }, [i]), J(() => {
    window.DID_AGENTS_API.showLoader = (o, s) => {
      const a = {
        ...n.loaderConfig,
        show: !0
      };
      s && (a.style = s), o !== void 0 && (a.text = o), i({
        loaderConfig: a
      });
    }, window.DID_AGENTS_API.hideLoader = () => {
      i({
        loaderConfig: {
          ...n.loaderConfig,
          show: !1
        }
      });
    };
  }, [i, n.loaderConfig]), g(Be.Provider, {
    value: {
      configurations: n,
      configure: i
    },
    children: e
  });
};
var X = /* @__PURE__ */ ((e) => (e[e.New = 0] = "New", e[e.Loading = 1] = "Loading", e[e.Buffering = 2] = "Buffering", e[e.Start = 3] = "Start", e[e.Fail = 4] = "Fail", e))(X || {});
const Dt = Cr({
  authenticate: () => {
  },
  auth: {},
  host: "",
  wsHost: "",
  isAuthenticated: !1
});
Dt.displayName = "DidFetch";
function sc({
  children: e,
  auth: t,
  didApiUrl: n,
  didSocketApiUrl: r
}) {
  const [i, o] = L(t), s = async (a) => {
    o((c) => JSON.stringify(a) === JSON.stringify(c) ? c : a);
  };
  return g(Dt.Provider, {
    value: {
      auth: i,
      host: n,
      wsHost: r,
      authenticate: s,
      isAuthenticated: !!i
    },
    children: e
  });
}
const Ft = Cr({
  connectionState: P.New,
  streamState: X.New,
  connect: async () => {
  },
  reconnect: async () => {
  },
  disconnect: async () => {
  },
  setStreamState: () => {
  },
  streamedMessage: "",
  messages: [],
  error: "",
  setError: () => {
  },
  terminating: !1
});
Ft.displayName = "Streaming Manager";
function ac({
  agentId: e,
  children: t,
  enabled: n,
  onAgentReady: r,
  onError: i
}) {
  const [o, s] = L(P.New), [a, c] = L(X.New), [d, l] = L(), [u, p] = L(""), [f, _] = L(), [S, b] = L(""), [E, h] = L(!1), [y, T] = L([]), {
    configurations: w,
    configure: m
  } = fe(Be), {
    auth: k,
    host: N,
    wsHost: R
  } = fe(Dt), D = Rt(async () => {
    f && (h(!0), await f.disconnect().catch(), h(!1));
  }, [f]);
  async function z() {
    var q;
    if (b(""), f && ![C.TextOnly, C.Playground].includes(w.chatMode))
      return f;
    if (k && N && R) {
      let M;
      try {
        M = await Ba(e, {
          mode: w.chatMode,
          auth: k,
          baseURL: N,
          wsURL: R,
          streamOptions: {
            streamWarmup: !0
          },
          callbacks: {
            onVideoStateChange(j) {
              const re = j === Ze.Start ? X.Start : X.New;
              c(re);
            },
            onConnectionStateChange: (j) => {
              s((re) => j === P.Disconnected ? re === P.Connected ? j : re : j);
            },
            onNewMessage: T,
            onSrcObjectReady: l,
            onModeChange: (j) => m({
              chatMode: j
            }),
            onNewChat: (j) => si({
              chat_id: j
            }),
            onError: i
          },
          initialMessages: y
        }), si({
          agentId: M.agent.id,
          agentType: M.agent.presenter.type
        });
        const G = {
          ...M,
          chat: async (j) => {
            var re;
            if (window.dataLayer.push({
              event: "agent_interaction",
              message: j
            }), !M)
              throw new Error("Manager is not initialized");
            return [C.TextOnly, C.Playground].includes(w.chatMode) ? (p(""), M.chat(j).catch((te) => {
              throw (te == null ? void 0 : te.kind) === "InsufficientCreditsError" && (M == null || M.changeMode(C.TextOnly)), te;
            })) : (re = M.agent.presenter) != null && re.voice ? (p(""), await M.chat(j).catch((te) => {
              throw (te == null ? void 0 : te.kind) === "InsufficientCreditsError" && (M == null || M.changeMode(C.TextOnly)), te;
            })) : Promise.reject(new Error("Agent has no voice, can not chat"));
          }
        };
        return (q = G.agent.presenter) != null && q.idle_video || (w.chatMode === C.Playground ? G.changeMode(w.chatMode) : G.changeMode(C.TextOnly)), _(G), r == null || r(G.agent), G;
      } catch (G) {
        console.error(G), G instanceof TypeError && c(X.Fail), M == null || M.changeMode(C.Maintenance), b("Agent is unavailable at the moment");
      }
    }
  }
  async function Z(q = !1) {
    p("");
    const M = await z();
    if (M)
      return w.chatMode === C.Maintenance && M.changeMode(C.Functional), q ? M.reconnect() : M.connect();
  }
  return J(() => {
    const q = z();
    window.DID_AGENTS_API.updateAgent = () => {
      if (![C.TextOnly, C.Playground].includes(w.chatMode)) {
        console.log("updateAgent only in textOnly mode, change config chatMode to TextOnly");
        return;
      }
      z();
    }, n && [C.Functional, C.Maintenance].includes(w.chatMode) && q.then(async (M) => {
      M && o !== P.Connected && await M.reconnect();
    });
  }, [k, N, R, n, w.chatMode]), J(() => (window.addEventListener("beforeunload", () => {
    D();
  }), () => D()), [D]), g(Ft.Provider, {
    value: {
      streamedMessage: u,
      srcObject: d,
      streamState: a,
      connectionState: o,
      setStreamState: c,
      disconnect: D,
      connect: () => Z(!1),
      reconnect: () => Z(!0),
      error: S,
      setError: b,
      agentManager: f,
      messages: y,
      terminating: E
    },
    children: t
  });
}
const Zo = "data:image/svg+xml,%3csvg%20version='1.1'%20id='L9'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%20100%20100'%20enable-background='new%200%200%200%200'%20xml:space='preserve'%3e%3cpath%20fill='%23fff'%20d='M73,50c0-12.7-10.3-23-23-23S27,37.3,27,50%20M30.9,50c0-10.5,8.5-19.1,19.1-19.1S69.1,39.5,69.1,50'%3e%3canimateTransform%20attributeName='transform'%20attributeType='XML'%20type='rotate'%20dur='1s'%20from='0%2050%2050'%20to='360%2050%2050'%20repeatCount='indefinite'%20/%3e%3c/path%3e%3c/svg%3e", Xn = [P.Fail, P.Disconnected, P.Completed];
function cc(e) {
  const t = e.style.height;
  e.style.height = "0";
  const n = e.scrollHeight / parseInt(getComputedStyle(e).lineHeight);
  return e.style.height = t, parseInt(n + "");
}
function Yo() {
  try {
    return /iPhone|iPad|iPod/i.test(navigator.userAgent);
  } catch (e) {
    console.error("Error occurred while detecting iOS:", e);
  }
  return !1;
}
function Ko() {
  const e = navigator.userAgent.match(/OS (\d+)_\d+(_\d+)? like Mac OS X/i);
  return e ? parseInt(e[1], 10) === 17 : !1;
}
const Xo = "data:image/svg+xml,%3c?xml%20version='1.0'%20encoding='iso-8859-1'?%3e%3c!--%20Uploaded%20to:%20SVG%20Repo,%20www.svgrepo.com,%20Generator:%20SVG%20Repo%20Mixer%20Tools%20--%3e%3csvg%20height='800px'%20width='800px'%20version='1.1'%20id='Capa_1'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20viewBox='0%200%20199.943%20199.943'%20xml:space='preserve'%3e%3cg%3e%3cg%3e%3cpath%20style='fill:%23010002;'%20d='M99.972,0.004C44.85,0.004,0,44.847,0,99.968c0,55.125,44.847,99.972,99.972,99.972%20s99.972-44.847,99.972-99.972C199.943,44.847,155.093,0.004,99.972,0.004z%20M99.972,190.957c-50.168,0-90.996-40.813-90.996-90.989%20c0-50.172,40.828-90.992,90.996-90.992c50.175,0,91.003,40.817,91.003,90.992S150.147,190.957,99.972,190.957z'/%3e%3cpath%20style='fill:%23010002;'%20d='M99.324,67.354c-3.708,0-6.725,3.01-6.725,6.728v75.979c0,3.722,3.017,6.739,6.725,6.739%20c3.722,0,6.739-3.017,6.739-6.739V74.082C106.063,70.364,103.042,67.354,99.324,67.354z'/%3e%3ccircle%20style='fill:%23010002;'%20cx='99.746'%20cy='48.697'%20r='8.178'/%3e%3c/g%3e%3c/g%3e%3c/svg%3e";
function de({
  src: e,
  size: t,
  color: n = "currentcolor",
  padding: r = "0",
  rotated: i,
  margin: o = "0",
  width: s,
  className: a = ""
}) {
  return g("svg", {
    className: "didagent__maskedicon " + a,
    style: {
      "--mask-url": `url("${e}")`,
      "--color": n,
      "--width": s,
      "--size": t,
      "--padding": r,
      "--margin": o,
      "--rotation": i ? "180deg" : "0deg"
    }
  });
}
const uc = ({
  text: e,
  hide: t
}) => t ? null : g("div", {
  className: "didagent__info_message_agent_unavailable_container",
  children: g("div", {
    className: "didagent__info_message_agent_unavailable_danger",
    children: [g(de, {
      src: Xo,
      size: "20px"
    }), g("div", {
      children: e
    })]
  })
});
function dc({
  content: e,
  display: t
}) {
  const [n, r] = L(!1), [i, o] = L("");
  return J(() => {
    if (!t)
      r(!1);
    else {
      r(!0), o("fade-in");
      const s = setTimeout(() => {
        o("fade-out");
        const a = setTimeout(() => r(!1), 500);
        return () => clearTimeout(a);
      }, 3e3);
      return () => clearTimeout(s);
    }
  }, [t]), n ? g("div", {
    className: `didagent__info_message_indication ${i}`,
    children: [g(de, {
      src: Xo,
      size: "16px"
    }), g("pre", {
      className: "didagent__info_message_agent_unavailable_message",
      children: e
    })]
  }) : null;
}
function lc({
  content: e,
  hide: t
}) {
  return t || !e ? null : g("div", {
    className: "didagent__banner",
    children: e
  });
}
const fc = "data:image/svg+xml,%3csvg%20width='32'%20height='32'%20viewBox='0%200%2032%2032'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M10.4453%2011.5556C10.4453%208.48731%2012.9326%206%2016.0009%206C19.0691%206%2021.5564%208.48731%2021.5564%2011.5556V14.8889C21.5564%2017.9571%2019.0691%2020.4444%2016.0009%2020.4444C12.9326%2020.4444%2010.4453%2017.9571%2010.4453%2014.8889V11.5556Z'%20fill='white'%20stroke='white'%20stroke-width='1.66667'/%3e%3cpath%20d='M24.8911%2013.7812V14.8924C24.8911%2019.8016%2020.9114%2023.7813%2016.0022%2023.7813C11.093%2023.7813%207.11328%2019.8016%207.11328%2014.8924V13.7812'%20stroke='white'%20stroke-width='1.66667'%20stroke-linecap='round'/%3e%3cpath%20d='M16%2023.7812V27.1146'%20stroke='white'%20stroke-width='1.66667'%20stroke-linecap='round'/%3e%3c/svg%3e", pc = "data:image/svg+xml,%3csvg%20width='23'%20height='24'%20viewBox='0%200%2023%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M9.68322%2018.9259L14.3358%2016.4985C18.4002%2014.3779%2020.4324%2013.3176%2020.4324%2011.6386C20.4324%209.95953%2018.4002%208.89925%2014.3358%206.77869L9.68324%204.35127C6.40287%202.63977%204.76268%201.78403%203.81181%202.0467C2.90723%202.29659%202.20074%203.0338%201.96126%203.97771C1.70953%204.96992%202.52962%206.68142%204.1698%2010.1044C4.37307%2010.5286%204.78866%2010.8108%205.24318%2010.813L12.6703%2010.8491C13.0882%2010.8511%2013.4253%2011.2062%2013.4234%2011.6423C13.4214%2012.0783%2013.0811%2012.4301%2012.6633%2012.428L5.35607%2012.3926C4.8551%2012.3901%204.39385%2012.7052%204.1698%2013.1728C2.52963%2016.5957%201.70953%2018.3072%201.96126%2019.2994C2.20074%2020.2434%202.90723%2020.9806%203.81181%2021.2305C4.76268%2021.4931%206.40287%2020.6374%209.68322%2018.9259Z'%20fill='white'/%3e%3c/svg%3e", _c = "data:image/svg+xml,%3csvg%20id='wave'%20data-name='Layer%201'%20xmlns='http://www.w3.org/2000/svg'%20viewBox='0%200%2050%2038.05'%3e%3cstyle%3e%20%23Line_1%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.15s;%20}%20%23Line_2%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.3s;%20}%20%23Line_3%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.45s;%20}%20%23Line_4%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.6s;%20}%20%23Line_5%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.75s;%20}%20%23Line_6%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%200.9s;%20}%20%23Line_7%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%201.05s;%20}%20%23Line_8%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%201.2s;%20}%20%23Line_9%20{%20animation:%20pulse%201s%20infinite;%20animation-delay:%201.35s;%20}%20@keyframes%20pulse%20{%200%25%20{%20transform:%20scaleY(1);%20transform-origin:%2050%25%2050%25;%20}%2050%25%20{%20transform:%20scaleY(0.7);%20transform-origin:%2050%25%2050%25;%20}%20100%25%20{%20transform:%20scaleY(1);%20transform-origin:%2050%25%2050%25;%20}%20}%20%3c/style%3e%3cpath%20id='Line_1'%20data-name='Line%201'%20d='M0.91,15L0.78,15A1,1,0,0,0,0,16v6a1,1,0,1,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H0.91Z'%20/%3e%3cpath%20id='Line_2'%20data-name='Line%202'%20d='M6.91,9L6.78,9A1,1,0,0,0,6,10V28a1,1,0,1,0,2,0s0,0,0,0V10A1,1,0,0,0,7,9H6.91Z'%20/%3e%3cpath%20id='Line_3'%20data-name='Line%203'%20d='M12.91,0L12.78,0A1,1,0,0,0,12,1V37a1,1,0,1,0,2,0s0,0,0,0V1a1,1,0,0,0-1-1H12.91Z'%20/%3e%3cpath%20id='Line_4'%20data-name='Line%204'%20d='M18.91,10l-0.12,0A1,1,0,0,0,18,11V27a1,1,0,1,0,2,0s0,0,0,0V11a1,1,0,0,0-1-1H18.91Z'%20/%3e%3cpath%20id='Line_5'%20data-name='Line%205'%20d='M24.91,15l-0.12,0A1,1,0,0,0,24,16v6a1,1,0,0,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H24.91Z'%20/%3e%3cpath%20id='Line_6'%20data-name='Line%206'%20d='M30.91,10l-0.12,0A1,1,0,0,0,30,11V27a1,1,0,1,0,2,0s0,0,0,0V11a1,1,0,0,0-1-1H30.91Z'%20/%3e%3cpath%20id='Line_7'%20data-name='Line%207'%20d='M36.91,0L36.78,0A1,1,0,0,0,36,1V37a1,1,0,1,0,2,0s0,0,0,0V1a1,1,0,0,0-1-1H36.91Z'%20/%3e%3cpath%20id='Line_8'%20data-name='Line%208'%20d='M42.91,9L42.78,9A1,1,0,0,0,42,10V28a1,1,0,1,0,2,0s0,0,0,0V10a1,1,0,0,0-1-1H42.91Z'%20/%3e%3cpath%20id='Line_9'%20data-name='Line%209'%20d='M48.91,15l-0.12,0A1,1,0,0,0,48,16v6a1,1,0,1,0,2,0s0,0,0,0V16a1,1,0,0,0-1-1H48.91Z'%20/%3e%3c/svg%3e", Jo = "data:image/svg+xml,%3csvg%20width='24'%20height='24'%20viewBox='0%200%2024%2024'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M16.9399%206.96684L6.87207%2017.0347M6.87203%206.9668L16.9399%2017.0346'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'/%3e%3c/svg%3e";
function hc() {
  return navigator.userAgent.toLowerCase().match(/(android|windows).+chrome|(iphone|mac).+safari/) && (window.SpeechRecognition || window.webkitSpeechRecognition);
}
function gc({
  onstart: e,
  onend: t,
  onresult: n,
  onerror: r,
  interimResults: i = !1
}) {
  const o = hc();
  if (!o)
    return null;
  const s = new o();
  return s.interimResults = i, s.onstart = () => e == null ? void 0 : e(), s.onresult = (a) => {
    n(a), Yo() && Ko() && s.stop();
  }, s.onerror = (a) => r == null ? void 0 : r(a), s.onend = () => {
    t == null || t(), s.stop();
  }, {
    start: () => s.start(),
    stop: () => s.stop(),
    abort: () => s.abort()
  };
}
function mc({
  text: e,
  onSend: t,
  onTranscript: n,
  isSttSendDisabled: r,
  isMessageSendDisabled: i,
  className: o
}) {
  const [s, a] = L(!1), {
    connectionState: c,
    reconnect: d
  } = fe(Ft), {
    isAuthenticated: l
  } = fe(Dt), u = Te();
  if (u.current = Cn(() => gc({
    onresult(p) {
      const f = [...p.results].map((_) => [..._].map((S) => S.transcript.trim()).join(" ")).join(" ");
      n(f);
    },
    onstart: () => {
      De("agent-stt", {
        event: "start",
        engine: "native"
      }), a(!0);
    },
    onend: () => {
      var p;
      (p = document.activeElement) == null || p.blur(), a(!1);
    },
    onerror: (p) => De("agent-stt", {
      event: "error",
      error: p.error,
      engine: "native"
    })
  }), [n]), l && !s && c === P.Connecting)
    return g("button", {
      className: "didagaent__send__button didagaent__send__button__loader " + o,
      disabled: !0,
      "data-testid": "send_loader",
      children: g(de, {
        src: Zo,
        size: "60%",
        color: "var(--did-primary-black-700)"
      })
    });
  if (e.length === 0) {
    const p = async () => {
      if (u.current) {
        const f = s ? "stop" : "start";
        Xn.includes(c) && await d(), setTimeout(() => {
          var _;
          return (_ = u.current) == null ? void 0 : _[f]();
        }), De("agent-stt", {
          event: f,
          engine: "native"
        });
      }
    };
    return g(Fe, {
      children: [s && g("button", {
        disabled: r,
        className: "didagaent__send__button didagaent__send__button__record " + o,
        onClick: () => {
          var f;
          (f = u.current) == null || f.abort(), a(!1);
        },
        children: g(de, {
          src: Jo,
          size: "60%",
          color: "var(--did-primary-black-700)"
        })
      }), g("button", {
        className: `didagaent__send__button ${s ? "" : "didagaent__send__button__record"} ${o}`,
        onClick: p,
        disabled: r,
        "data-testid": "send_record",
        children: g(de, {
          src: s ? _c : fc,
          size: "60%",
          color: s ? "white" : "var(--did-primary-black-700)"
        })
      })]
    });
  }
  return g("button", {
    className: "didagaent__send__button  didagaent__send__button_actions " + o + (i ? " didagent__send__button__disabled" : ""),
    onClick: t,
    disabled: i,
    "data-testid": "send_text",
    children: g(de, {
      src: pc,
      size: "60%",
      color: "white"
    })
  });
}
const yc = "data:image/svg+xml,%3csvg%20width='20'%20height='17'%20viewBox='0%200%2020%2017'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cg%20clip-path='url(%23clip0_28862_37001)'%3e%3cpath%20d='M1.70818%202.20585H0V13.5604H1.70818C4%2013.5604%204.95455%2012.9913%204.95455%2010.5359V5.22767C4.95455%202.74313%204.00091%202.20312%201.70818%202.20312V2.20494V2.20585ZM3.53091%2010.5359C3.53091%2011.9268%203.10455%2012.1395%201.72182%2012.1395H1.42182V3.62403H1.72182C3.10273%203.62403%203.53091%203.83676%203.53091%205.22767V10.5359Z'%20fill='white'/%3e%3cpath%20d='M5.68652%208.09375V9.2292H7.82107V8.09375H5.68652Z'%20fill='white'/%3e%3cpath%20d='M8.63477%204.33594V13.5605H10.0584V4.33594H8.63477Z'%20fill='white'/%3e%3cpath%20d='M12.5793%202.20585H10.8711V13.5604H12.5793C14.8711%2013.5604%2015.8265%2012.9913%2015.8265%2010.5359V5.22767C15.8265%202.74313%2014.8729%202.20312%2012.5793%202.20312V2.20494V2.20585ZM14.402%2010.5359C14.402%2011.9268%2013.9756%2012.1395%2012.5929%2012.1395H12.2929V3.62403H12.5929C13.9738%203.62403%2014.402%203.83676%2014.402%205.22767V10.5359Z'%20fill='white'/%3e%3cpath%20d='M9.34634%203.49178C9.77762%203.49178%2010.1272%203.14296%2010.1272%202.71268C10.1272%202.2824%209.77762%201.93359%209.34634%201.93359C8.91505%201.93359%208.56543%202.2824%208.56543%202.71268C8.56543%203.14296%208.91505%203.49178%209.34634%203.49178Z'%20fill='white'/%3e%3cpath%20d='M10.9818%201.28396C11.219%201.28396%2011.4118%201.09214%2011.4118%200.854872C11.4118%200.617599%2011.219%200.425781%2010.9818%200.425781C10.7445%200.425781%2010.5518%200.617599%2010.5518%200.854872C10.5518%201.09214%2010.7445%201.28396%2010.9818%201.28396Z'%20fill='white'/%3e%3cpath%20d='M12.8296%200.690511C13.0077%200.690511%2013.1523%200.545966%2013.1523%200.368693C13.1523%200.19142%2013.0077%200.046875%2012.8296%200.046875C12.6514%200.046875%2012.5068%200.19142%2012.5068%200.368693C12.5068%200.545966%2012.6514%200.690511%2012.8296%200.690511Z'%20fill='white'/%3e%3cpath%20d='M14.5678%201.01473C14.746%201.01473%2014.8906%200.870185%2014.8906%200.692912C14.8906%200.515639%2014.746%200.371094%2014.5678%200.371094C14.3897%200.371094%2014.2451%200.515639%2014.2451%200.692912C14.2451%200.870185%2014.3897%201.01473%2014.5678%201.01473Z'%20fill='white'/%3e%3cpath%20d='M17.048%2016.3167C16.6853%2016.3167%2016.378%2016.2012%2016.1562%2016.1176L16.0744%2016.0876C15.7035%2015.953%2015.3453%2015.8185%2015.0107%2015.6876C14.8253%2015.6149%2014.7335%2015.4058%2014.8062%2015.2203C14.8789%2015.0349%2015.0889%2014.9439%2015.2744%2015.0167C15.6035%2015.1458%2015.9562%2015.2776%2016.3225%2015.4103C16.3516%2015.4212%2016.3816%2015.4321%2016.4116%2015.4439C16.6598%2015.5376%2016.9416%2015.6439%2017.2507%2015.5749C17.5271%2015.513%2017.6989%2015.4076%2017.7889%2015.2449C17.8735%2015.0921%2017.8471%2014.9839%2017.7889%2014.7885C17.7398%2014.6249%2017.6798%2014.4212%2017.758%2014.2003C17.8453%2013.953%2018.0225%2013.8321%2018.1525%2013.7439C18.2716%2013.6621%2018.2962%2013.6403%2018.3098%2013.5712C18.3398%2013.4185%2018.2544%2013.3385%2018.2244%2013.3158C18.0889%2013.2667%2017.9925%2013.1394%2017.9871%2012.9903C17.9807%2012.8139%2018.1025%2012.6594%2018.2753%2012.6239C18.3062%2012.6176%2018.3998%2012.5985%2018.4753%2012.5221C18.5144%2012.483%2018.5816%2012.4012%2018.588%2012.2912C18.5935%2012.1903%2018.5398%2012.1076%2018.4516%2011.9849C18.3535%2011.8494%2018.1707%2011.5967%2018.3398%2011.313C18.4735%2011.0885%2018.7562%2010.9712%2018.9835%2010.8767C19.0307%2010.8567%2019.0735%2010.8394%2019.1062%2010.8239C19.2425%2010.7567%2019.3025%2010.6821%2019.2735%2010.443C19.2644%2010.3712%2019.2307%2010.3139%2019.2089%2010.283C18.9062%209.89394%2018.6244%209.50303%2018.348%209.08849C18.1044%208.72121%2017.9407%208.45121%2017.8771%208.06758C17.8125%207.68303%2018.0144%206.98031%2018.038%206.90121C18.2789%206.08303%2018.2898%205.46031%2017.7035%204.13394C17.2607%203.13394%2016.5771%202.4494%2016.0816%202.05121C15.9262%201.92667%2015.9016%201.6994%2016.0271%201.54485C16.1525%201.3894%2016.3798%201.36485%2016.5353%201.49031C17.3353%202.13303%2017.9671%202.94667%2018.3644%203.84303C18.9671%205.20576%2019.0562%205.99849%2018.7316%207.10394C18.6462%207.39394%2018.568%207.81212%2018.5907%207.9494C18.628%208.17394%2018.7135%208.33121%2018.9507%208.69031C19.218%209.09121%2019.4907%209.4694%2019.7844%209.84576C19.7871%209.8494%2019.7898%209.85212%2019.7916%209.85576C19.8671%209.9594%2019.9625%2010.1303%2019.9907%2010.3549C20.0689%2011.0076%2019.7271%2011.3212%2019.4271%2011.4694C19.3835%2011.4912%2019.3253%2011.5158%2019.2616%2011.5421C19.2162%2011.5612%2019.1453%2011.5903%2019.0807%2011.6212C19.1889%2011.7758%2019.3289%2012.0103%2019.3107%2012.3303C19.2962%2012.5894%2019.1816%2012.8385%2018.988%2013.0312C18.9725%2013.0467%2018.9562%2013.0621%2018.9389%2013.0767C19.0344%2013.2685%2019.0635%2013.4876%2019.0207%2013.7076C18.9489%2014.0739%2018.7062%2014.2394%2018.5616%2014.3376C18.4998%2014.3794%2018.4589%2014.4085%2018.4453%2014.4303C18.448%2014.4621%2018.4689%2014.5303%2018.4835%2014.5812C18.5489%2014.8003%2018.658%2015.1676%2018.4235%2015.5912C18.2316%2015.9385%2017.8907%2016.1685%2017.4116%2016.2758C17.2862%2016.3039%2017.1653%2016.3158%2017.0498%2016.3158L17.048%2016.3167Z'%20fill='white'/%3e%3c/g%3e%3cdefs%3e%3cclipPath%20id='clip0_28862_37001'%3e%3crect%20width='20'%20height='16.3636'%20fill='white'/%3e%3c/clipPath%3e%3c/defs%3e%3c/svg%3e";
function vc({
  show: e
}) {
  return e ? g("footer", {
    className: "didagent__branding_footer",
    children: ["Powered by:", g(de, {
      src: yc,
      size: "20px"
    })]
  }) : null;
}
const Sc = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M15.3035%206.70851L14.7142%206.11925C12.1107%203.51576%207.88961%203.51576%205.28612%206.11925C2.68262%208.72275%202.68262%2012.9438%205.28612%2015.5473C7.88961%2018.1508%2012.1107%2018.1508%2014.7142%2015.5473C16.2282%2014.0333%2016.8618%2011.9723%2016.6149%2010.0004M15.3035%206.70851H11.7679M15.3035%206.70851V3.17297'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e", bc = "data:image/svg+xml,%3csvg%20width='20'%20height='21'%20viewBox='0%200%2020%2021'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M13.5417%2010.2484C13.5417%209.90318%2013.2618%209.62336%2012.9167%209.62336C12.5715%209.62336%2012.2917%209.90318%2012.2917%2010.2484H13.5417ZM5.84683%206.04679L5.9509%206.66307L5.84683%206.04679ZM7.1661%205.43188L6.82206%204.91009L6.82206%204.91009L7.1661%205.43188ZM6.43996%205.86885L6.69231%206.44064L6.43996%205.86885ZM2.78323%2014.184L2.5208%2014.7512L2.78323%2014.184ZM1.27899%2011.1054L0.655149%2011.1434L1.27899%2011.1054ZM1.63212%2013.1009L2.18233%2012.8044L1.63212%2013.1009ZM11.4167%2016.9775L11.2149%2016.3859L11.4167%2016.9775ZM12.8439%2012.4195L13.4683%2012.4485L12.8439%2012.4195ZM11.8997%2016.7317L12.2591%2017.243L11.8997%2016.7317ZM7.34855%205.31159L7.69258%205.83338L7.69258%205.83338L7.34855%205.31159ZM11.4167%203.51926L11.2149%204.11077L11.4167%203.51926ZM11.8997%203.76506L12.2591%203.25371L11.8997%203.76506ZM2.78323%206.31276L2.5208%205.74553L2.78323%206.31276ZM1.27899%209.39136L0.655149%209.35333L1.27899%209.39136ZM1.63212%207.39586L2.18233%207.69232L1.63212%207.39586ZM8.25923%2015.0362C7.97052%2014.847%207.5831%2014.9277%207.39391%2015.2164C7.20472%2015.5051%207.28539%2015.8926%207.57411%2016.0817L8.25923%2015.0362ZM7.51013%205.95367L7.69258%205.83338L7.00451%204.7898L6.82206%204.91009L7.51013%205.95367ZM1.90283%2011.0673C1.88521%2010.7782%201.875%2010.501%201.875%2010.2484H0.625C0.625%2010.533%200.636444%2010.8365%200.655149%2011.1434L1.90283%2011.0673ZM1.875%2010.2484C1.875%209.99567%201.88521%209.71852%201.90283%209.42938L0.655149%209.35333C0.636444%209.66022%200.625%209.96371%200.625%2010.2484H1.875ZM12.2917%2010.2484C12.2917%2010.6748%2012.263%2011.4575%2012.2196%2012.3905L13.4683%2012.4485C13.5114%2011.5194%2013.5417%2010.7084%2013.5417%2010.2484H12.2917ZM5.00007%206.70669C5.40642%206.70669%205.68068%206.7087%205.9509%206.66307L5.74276%205.43052C5.59964%205.45469%205.44717%205.45669%205.00007%205.45669V6.70669ZM6.82206%204.91009C6.4488%205.1562%206.3204%205.23846%206.18761%205.29706L6.69231%206.44064C6.94302%206.32999%207.17089%206.17735%207.51014%205.95367L6.82206%204.91009ZM5.9509%206.66307C6.2063%206.61994%206.45534%206.54522%206.69231%206.44064L6.18761%205.29706C6.04543%205.35981%205.896%205.40464%205.74276%205.43052L5.9509%206.66307ZM5.00007%2015.04C5.44717%2015.04%205.59964%2015.042%205.74276%2015.0662L5.9509%2013.8337C5.68068%2013.788%205.40642%2013.79%205.00007%2013.79V15.04ZM5.00007%2013.79C3.79701%2013.79%203.39093%2013.7765%203.04567%2013.6167L2.5208%2014.7512C3.17442%2015.0536%203.91327%2015.04%205.00007%2015.04V13.79ZM0.655149%2011.1434C0.713737%2012.1046%200.741742%2012.766%201.0819%2013.3973L2.18233%2012.8044C2.00044%2012.4668%201.96704%2012.1208%201.90283%2011.0673L0.655149%2011.1434ZM3.04567%2013.6167C2.71204%2013.4624%202.3567%2013.128%202.18233%2012.8044L1.0819%2013.3973C1.38451%2013.959%201.9418%2014.4833%202.5208%2014.7512L3.04567%2013.6167ZM12.2196%2012.3905C12.1603%2013.6661%2012.1175%2014.5594%2012.0013%2015.2051C11.8855%2015.848%2011.7209%2016.0934%2011.5404%2016.2203L12.2591%2017.243C12.8475%2016.8295%2013.0965%2016.1762%2013.2315%2015.4266C13.3659%2014.68%2013.4107%2013.6874%2013.4683%2012.4485L12.2196%2012.3905ZM11.6186%2017.569C11.8451%2017.4916%2012.0632%2017.3807%2012.2591%2017.243L11.5404%2016.2203C11.4414%2016.2899%2011.3294%2016.3469%2011.2149%2016.3859L11.6186%2017.569ZM7.69258%205.83338C8.76742%205.1247%209.52165%204.62895%2010.1169%204.33981C10.7104%204.05147%2011.0072%204.03991%2011.2149%204.11077L11.6186%202.92775C10.9368%202.69508%2010.259%202.88107%209.57067%203.21546C8.88394%203.54906%208.04882%204.10124%207.00451%204.7898L7.69258%205.83338ZM11.2149%204.11077C11.3294%204.14984%2011.4414%204.20686%2011.5404%204.27642L12.2591%203.25371C12.0632%203.11606%2011.8451%203.00507%2011.6186%202.92775L11.2149%204.11077ZM5.00007%205.45669C3.91327%205.45669%203.17442%205.44313%202.5208%205.74553L3.04567%206.88C3.39093%206.72026%203.79701%206.70669%205.00007%206.70669V5.45669ZM1.90283%209.42938C1.96704%208.37591%202.00044%208.02991%202.18233%207.69232L1.0819%207.0994C0.741742%207.73072%200.713737%208.39208%200.655149%209.35333L1.90283%209.42938ZM2.5208%205.74553C1.9418%206.01341%201.38451%206.53777%201.0819%207.0994L2.18233%207.69232C2.3567%207.36869%202.71204%207.03435%203.04567%206.88L2.5208%205.74553ZM7.57411%2016.0817C8.43976%2016.649%209.15622%2017.1023%209.76703%2017.3725C10.3856%2017.6461%2011.0002%2017.78%2011.6186%2017.569L11.2149%2016.3859C11.027%2016.45%2010.7656%2016.4474%2010.2727%2016.2293C9.77201%2016.0079%209.14153%2015.6144%208.25923%2015.0362L7.57411%2016.0817ZM13.4359%207.36502C13.3854%206.3424%2013.3303%205.50424%2013.1891%204.85648C13.046%204.19945%2012.792%203.62818%2012.2591%203.25371L11.5404%204.27642C11.7036%204.39113%2011.8545%204.60276%2011.9678%205.1226C12.0831%205.65169%2012.1359%206.38434%2012.1874%207.42669L13.4359%207.36502Z'%20fill='%23090604'/%3e%3cpath%20d='M16.6665%2015.2487C16.6665%2015.2487%2017.9165%2013.7487%2017.9165%2010.2487C17.9165%208.22085%2017.4969%206.86438%2017.1439%206.08203'%20stroke='%23090604'%20stroke-width='1.25'%20stroke-linecap='round'/%3e%3cpath%20d='M15%2012.7487C15%2012.7487%2015.4167%2011.9987%2015.4167%2010.2487C15.4167%209.53046%2015.3465%208.98066%2015.2637%208.58203'%20stroke='%23090604'%20stroke-width='1.25'%20stroke-linecap='round'/%3e%3cpath%20d='M18.3332%201.91797L1.6665%2018.5846'%20stroke='%23090604'%20stroke-width='1.25'%20stroke-linecap='round'/%3e%3c/svg%3e", Ec = "data:image/svg+xml,%3csvg%20width='20'%20height='20'%20viewBox='0%200%2020%2020'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M1.27899%209.14136C1.34039%208.134%201.37109%207.63031%201.63212%207.14586C1.87061%206.70323%202.32692%206.27388%202.78323%206.06276C3.28268%205.83169%203.85514%205.83169%205.00007%205.83169C5.4268%205.83169%205.64016%205.83169%205.84683%205.79679C6.05115%205.76229%206.25039%205.70252%206.43996%205.61885C6.63171%205.53423%206.80984%205.41678%207.1661%205.18188L7.34855%205.06159C9.46769%203.66435%2010.5273%202.96573%2011.4167%203.26926C11.5872%203.32746%2011.7523%203.41146%2011.8997%203.51506C12.6687%204.05544%2012.7271%205.3127%2012.8439%207.8272C12.8872%208.75826%2012.9167%209.55512%2012.9167%209.99836C12.9167%2010.4416%2012.8872%2011.2385%2012.8439%2012.1695C12.7271%2014.684%2012.6687%2015.9413%2011.8997%2016.4817C11.7523%2016.5853%2011.5872%2016.6693%2011.4167%2016.7275C10.5273%2017.031%209.46769%2016.3324%207.34854%2014.9351L7.1661%2014.8148C6.80984%2014.5799%206.63171%2014.4625%206.43996%2014.3779C6.25039%2014.2942%206.05115%2014.2344%205.84683%2014.1999C5.64016%2014.165%205.4268%2014.165%205.00007%2014.165C3.85514%2014.165%203.28268%2014.165%202.78323%2013.934C2.32692%2013.7228%201.87061%2013.2935%201.63212%2012.8509C1.37109%2012.3664%201.34039%2011.8627%201.27899%2010.8554C1.26083%2010.5573%201.25%2010.267%201.25%209.99836C1.25%209.72969%201.26083%209.43937%201.27899%209.14136Z'%20stroke='white'%20stroke-width='1.5'/%3e%3cpath%20d='M15%207.5C15%207.5%2015.4167%208.25%2015.4167%2010C15.4167%2011.75%2015%2012.5%2015%2012.5'%20stroke='white'%20stroke-width='1.5'%20stroke-linecap='round'/%3e%3c/svg%3e";
function wc({
  show: e,
  muted: t,
  onClick: n,
  className: r
}) {
  return e ? g("button", {
    onClick: n,
    title: "Mute Sound",
    className: `${r}`,
    children: g(de, {
      src: t ? bc : Ec,
      size: "20px"
    })
  }) : null;
}
function Tc({
  name: e,
  icon: t,
  displayRestart: n,
  displayMuteButton: r,
  onRestart: i,
  restartDisabled: o,
  onMute: s,
  muted: a,
  isRestarting: c,
  onClose: d,
  onEasterEgg: l,
  closeClassName: u
}) {
  const p = Te(0), {
    error: f
  } = fe(Ft), {
    configurations: _
  } = fe(Be);
  function S() {
    p.current += 1, p.current === 5 && (l == null || l(), p.current = 0);
  }
  const b = [C.Maintenance].includes(_.chatMode);
  return g("header", {
    className: "didagent__header",
    children: [g("div", {
      className: "didagent__header-left",
      children: [_.mode === "fabio" && g("button", {
        onClick: d,
        className: `didagent__close__button didagent__header-bg ${u}`,
        children: g(de, {
          src: Jo,
          size: "20px"
        })
      }), !b && g("div", {
        "data-testid": "didagent__header__name",
        className: `didagent__header__name ${t ? "" : "didagent__header-bg"}`,
        onClick: S,
        children: t ? g("img", {
          src: t,
          alt: "Agent Logo"
        }) : e
      }), n && g("button", {
        onClick: i,
        disabled: o,
        title: "Restart conversation",
        className: `didagent__header__menu__item ${c ? "didagent__header__menu__item-rotate" : ""} didagent__header-bg`,
        children: g(de, {
          src: Sc,
          size: "20px"
        })
      }), g(wc, {
        show: r,
        muted: a,
        onClick: s,
        className: `${a ? "didagent__header__menu__item-active" : ""} didagent__header-bg`
      })]
    }), g("div", {
      className: "didagent__header-center",
      children: g(uc, {
        hide: !f,
        text: f
      })
    })]
  });
}
const Cc = "data:image/svg+xml,%3csvg%20version='1.1'%20id='L5'%20xmlns='http://www.w3.org/2000/svg'%20xmlns:xlink='http://www.w3.org/1999/xlink'%20x='0px'%20y='0px'%20viewBox='0%200%2052%2042'%20enable-background='new%200%200%200%200'%20xml:space='preserve'%3e%3ccircle%20fill='%23fff'%20stroke='none'%20cx='6'%20cy='21'%20r='6'%3e%3canimateTransform%20attributeName='transform'%20dur='1s'%20type='translate'%20values='0%2015%20;%200%20-15;%200%2015'%20repeatCount='indefinite'%20begin='0.1'/%3e%3c/circle%3e%3ccircle%20fill='%23fff'%20stroke='none'%20cx='25'%20cy='21'%20r='6'%3e%3canimateTransform%20attributeName='transform'%20dur='1s'%20type='translate'%20values='0%2010%20;%200%20-10;%200%2010'%20repeatCount='indefinite'%20begin='0.2'/%3e%3c/circle%3e%3ccircle%20fill='%23fff'%20stroke='none'%20cx='44'%20cy='21'%20r='6'%3e%3canimateTransform%20attributeName='transform'%20dur='1s'%20type='translate'%20values='0%205%20;%200%20-5;%200%205'%20repeatCount='indefinite'%20begin='0.3'/%3e%3c/circle%3e%3c/svg%3e";
function Qo(e, t) {
  for (var n in t)
    e[n] = t[n];
  return e;
}
function hi(e, t) {
  for (var n in e)
    if (n !== "__source" && !(n in t))
      return !0;
  for (var r in t)
    if (r !== "__source" && e[r] !== t[r])
      return !0;
  return !1;
}
function gi(e, t) {
  this.props = e, this.context = t;
}
(gi.prototype = new Ie()).isPureReactComponent = !0, gi.prototype.shouldComponentUpdate = function(e, t) {
  return hi(this.props, e) || hi(this.state, t);
};
var mi = x.__b;
x.__b = function(e) {
  e.type && e.type.__f && e.ref && (e.props.ref = e.ref, e.ref = null), mi && mi(e);
};
var kc = typeof Symbol < "u" && Symbol.for && Symbol.for("react.forward_ref") || 3911;
function Ic(e) {
  function t(n) {
    var r = Qo({}, n);
    return delete r.ref, e(r, n.ref || null);
  }
  return t.$$typeof = kc, t.render = t, t.prototype.isReactComponent = t.__f = !0, t.displayName = "ForwardRef(" + (e.displayName || e.name) + ")", t;
}
var Mc = x.__e;
x.__e = function(e, t, n, r) {
  if (e.then) {
    for (var i, o = t; o = o.__; )
      if ((i = o.__c) && i.__c)
        return t.__e == null && (t.__e = n.__e, t.__k = n.__k), i.__c(e, t);
  }
  Mc(e, t, n, r);
};
var yi = x.unmount;
function es(e, t, n) {
  return e && (e.__c && e.__c.__H && (e.__c.__H.__.forEach(function(r) {
    typeof r.__c == "function" && r.__c();
  }), e.__c.__H = null), (e = Qo({}, e)).__c != null && (e.__c.__P === n && (e.__c.__P = t), e.__c = null), e.__k = e.__k && e.__k.map(function(r) {
    return es(r, t, n);
  })), e;
}
function ts(e, t, n) {
  return e && n && (e.__v = null, e.__k = e.__k && e.__k.map(function(r) {
    return ts(r, t, n);
  }), e.__c && e.__c.__P === t && (e.__e && n.appendChild(e.__e), e.__c.__e = !0, e.__c.__P = n)), e;
}
function $n() {
  this.__u = 0, this.t = null, this.__b = null;
}
function ns(e) {
  var t = e.__.__c;
  return t && t.__a && t.__a(e);
}
function Kt() {
  this.u = null, this.o = null;
}
x.unmount = function(e) {
  var t = e.__c;
  t && t.__R && t.__R(), t && 32 & e.__u && (e.type = null), yi && yi(e);
}, ($n.prototype = new Ie()).__c = function(e, t) {
  var n = t.__c, r = this;
  r.t == null && (r.t = []), r.t.push(n);
  var i = ns(r.__v), o = !1, s = function() {
    o || (o = !0, n.__R = null, i ? i(a) : a());
  };
  n.__R = s;
  var a = function() {
    if (!--r.__u) {
      if (r.state.__a) {
        var c = r.state.__a;
        r.__v.__k[0] = ts(c, c.__c.__P, c.__c.__O);
      }
      var d;
      for (r.setState({ __a: r.__b = null }); d = r.t.pop(); )
        d.forceUpdate();
    }
  };
  r.__u++ || 32 & t.__u || r.setState({ __a: r.__b = r.__v.__k[0] }), e.then(s, s);
}, $n.prototype.componentWillUnmount = function() {
  this.t = [];
}, $n.prototype.render = function(e, t) {
  if (this.__b) {
    if (this.__v.__k) {
      var n = document.createElement("div"), r = this.__v.__k[0].__c;
      this.__v.__k[0] = es(this.__b, n, r.__O = r.__P);
    }
    this.__b = null;
  }
  var i = t.__a && At(Fe, null, e.fallback);
  return i && (i.__u &= -33), [At(Fe, null, t.__a ? null : e.children), i];
};
var vi = function(e, t, n) {
  if (++n[1] === n[0] && e.o.delete(t), e.props.revealOrder && (e.props.revealOrder[0] !== "t" || !e.o.size))
    for (n = e.u; n; ) {
      for (; n.length > 3; )
        n.pop()();
      if (n[1] < n[0])
        break;
      e.u = n = n[2];
    }
};
function Nc(e) {
  return this.getChildContext = function() {
    return e.context;
  }, e.children;
}
function Ac(e) {
  var t = this, n = e.i;
  t.componentWillUnmount = function() {
    hn(null, t.l), t.l = null, t.i = null;
  }, t.i && t.i !== n && t.componentWillUnmount(), t.l || (t.i = n, t.l = { nodeType: 1, parentNode: n, childNodes: [], appendChild: function(r) {
    this.childNodes.push(r), t.i.appendChild(r);
  }, insertBefore: function(r, i) {
    this.childNodes.push(r), t.i.appendChild(r);
  }, removeChild: function(r) {
    this.childNodes.splice(this.childNodes.indexOf(r) >>> 1, 1), t.i.removeChild(r);
  } }), hn(At(Nc, { context: t.context }, e.__v), t.l);
}
function Si(e, t) {
  var n = At(Ac, { __v: e, i: t });
  return n.containerInfo = t, n;
}
(Kt.prototype = new Ie()).__a = function(e) {
  var t = this, n = ns(t.__v), r = t.o.get(e);
  return r[0]++, function(i) {
    var o = function() {
      t.props.revealOrder ? (r.push(i), vi(t, e, r)) : i();
    };
    n ? n(o) : o();
  };
}, Kt.prototype.render = function(e) {
  this.u = null, this.o = /* @__PURE__ */ new Map();
  var t = _n(e.children);
  e.revealOrder && e.revealOrder[0] === "b" && t.reverse();
  for (var n = t.length; n--; )
    this.o.set(t[n], this.u = [1, 0, this.u]);
  return e.children;
}, Kt.prototype.componentDidUpdate = Kt.prototype.componentDidMount = function() {
  var e = this;
  this.o.forEach(function(t, n) {
    vi(e, n, t);
  });
};
var xc = typeof Symbol < "u" && Symbol.for && Symbol.for("react.element") || 60103, Rc = /^(?:accent|alignment|arabic|baseline|cap|clip(?!PathU)|color|dominant|fill|flood|font|glyph(?!R)|horiz|image(!S)|letter|lighting|marker(?!H|W|U)|overline|paint|pointer|shape|stop|strikethrough|stroke|text(?!L)|transform|underline|unicode|units|v|vector|vert|word|writing|x(?!C))[A-Z]/, Lc = /^on(Ani|Tra|Tou|BeforeInp|Compo)/, Oc = /[A-Z0-9]/g, Pc = typeof document < "u", $c = function(e) {
  return (typeof Symbol < "u" && typeof Symbol() == "symbol" ? /fil|che|rad/ : /fil|che|ra/).test(e);
};
Ie.prototype.isReactComponent = {}, ["componentWillMount", "componentWillReceiveProps", "componentWillUpdate"].forEach(function(e) {
  Object.defineProperty(Ie.prototype, e, { configurable: !0, get: function() {
    return this["UNSAFE_" + e];
  }, set: function(t) {
    Object.defineProperty(this, e, { configurable: !0, writable: !0, value: t });
  } });
});
var bi = x.event;
function Dc() {
}
function Fc() {
  return this.cancelBubble;
}
function Hc() {
  return this.defaultPrevented;
}
x.event = function(e) {
  return bi && (e = bi(e)), e.persist = Dc, e.isPropagationStopped = Fc, e.isDefaultPrevented = Hc, e.nativeEvent = e;
};
var Uc = { enumerable: !1, configurable: !0, get: function() {
  return this.class;
} }, Ei = x.vnode;
x.vnode = function(e) {
  typeof e.type == "string" && function(t) {
    var n = t.props, r = t.type, i = {};
    for (var o in n) {
      var s = n[o];
      if (!(o === "value" && "defaultValue" in n && s == null || Pc && o === "children" && r === "noscript" || o === "class" || o === "className")) {
        var a = o.toLowerCase();
        o === "defaultValue" && "value" in n && n.value == null ? o = "value" : o === "download" && s === !0 ? s = "" : a === "translate" && s === "no" ? s = !1 : a === "ondoubleclick" ? o = "ondblclick" : a !== "onchange" || r !== "input" && r !== "textarea" || $c(n.type) ? a === "onfocus" ? o = "onfocusin" : a === "onblur" ? o = "onfocusout" : Lc.test(o) ? o = a : r.indexOf("-") === -1 && Rc.test(o) ? o = o.replace(Oc, "-$&").toLowerCase() : s === null && (s = void 0) : a = o = "oninput", a === "oninput" && i[o = a] && (o = "oninputCapture"), i[o] = s;
      }
    }
    r == "select" && i.multiple && Array.isArray(i.value) && (i.value = _n(n.children).forEach(function(c) {
      c.props.selected = i.value.indexOf(c.props.value) != -1;
    })), r == "select" && i.defaultValue != null && (i.value = _n(n.children).forEach(function(c) {
      c.props.selected = i.multiple ? i.defaultValue.indexOf(c.props.value) != -1 : i.defaultValue == c.props.value;
    })), n.class && !n.className ? (i.class = n.class, Object.defineProperty(i, "className", Uc)) : (n.className && !n.class || n.class && n.className) && (i.class = i.className = n.className), t.props = i;
  }(e), e.$$typeof = xc, Ei && Ei(e);
};
var wi = x.__r;
x.__r = function(e) {
  wi && wi(e), e.__c;
};
var Ti = x.diffed;
x.diffed = function(e) {
  Ti && Ti(e);
  var t = e.props, n = e.__e;
  n != null && e.type === "textarea" && "value" in t && t.value !== n.value && (n.value = t.value == null ? "" : t.value);
};
function Bc(e, t, n) {
  return e ? "var(--did-primary-black-9080)" : "var(--did-primary-black-9060)";
}
function Ci({
  negative: e,
  toggled: t,
  onClick: n,
  disabled: r
}) {
  if (!t && r)
    return null;
  const i = e === !0, o = {
    "--hover-color": "var(--did-primary-black-9080)",
    "--color": Bc(t, i, r === !0),
    "--cursor": r === !0 ? "default" : "pointer"
  };
  return g("div", {
    className: "didagent__thumb__container",
    style: o,
    onClick: () => !r && (n == null ? void 0 : n(!t)),
    children: i ? "" : ""
  });
}
const jc = (e, t) => e === "up" ? t === me.Positive ? me.Unrated : me.Positive : t === me.Negative ? me.Unrated : me.Negative;
function Vc({
  className: e,
  show: t,
  onRate: n,
  message: r,
  style: i
}) {
  const [o, s] = L(me.Unrated), [a, c] = L(), [d, l] = L(!1);
  if (!t)
    return null;
  function u(p) {
    return async () => {
      var S;
      const f = jc(p, o);
      s(f), l(!0);
      const _ = await (n == null ? void 0 : n(f, r, a));
      c(_), (S = window.dataLayer) == null || S.push({
        event: "rated_reply",
        rating: f,
        message: r
      });
    };
  }
  return g("div", {
    className: `${e} didagent__rating`,
    style: i,
    children: [g(Ci, {
      disabled: d,
      toggled: o === me.Positive,
      onClick: u("up")
    }), g(Ci, {
      disabled: d,
      negative: !0,
      toggled: o === me.Negative,
      onClick: u("down")
    })]
  });
}
const qc = /(https?:\/\/[^\s]+)/g, ki = {
  "#general#": 280,
  ".": 620,
  ",": 500,
  "?": 500,
  "!": 500
};
function Gc({
  text: e,
  role: t,
  onTypingStatusChange: n,
  scrollToBottom: r
}) {
  const [i, o] = L([]), [s, a] = L(0), [c, d] = L([]);
  return J(() => d(e.split(" ")), [e]), J(() => {
    if (s < c.length) {
      const l = c[s], u = ki[l.split("").pop() ?? ""] || ki["#general#"], f = qc.test(l) ? g("a", {
        href: l,
        target: "_blank",
        rel: "noreferrer",
        className: "didagent__message__url",
        children: l
      }) : g("span", {
        children: l
      }), _ = setTimeout(() => {
        o((S) => [...S, S.length ? " " : "", f]), a((S) => S + 1), r();
      }, u);
      return () => clearTimeout(_);
    }
  }, [s, c]), J(() => {
    s === 0 ? n("start", t) : s >= c.length && n("done", t);
  }, [s, c]), t === "user" ? g("span", {
    children: e
  }) : g("span", {
    className: "appear-animation",
    children: i
  });
}
const Wc = ["Juggling thoughts and data...", "Processing, just a moment...", "Cooking up a response...", "Brainstorming potential answers...", "Let me look this up..."], Ii = ["Pondering the best reply...", "Processing, just a moment...", "Convincing my electrons to run faster...", "This is interesting..."], zc = [{
  text: [""],
  duration: 2e3
}, {
  text: ["Thinking..."],
  duration: 3e3
}, {
  text: Wc,
  duration: 4e3
}, {
  text: Ii,
  duration: 4e3
}, {
  text: Ii,
  duration: 4e3
}];
function Zc(e) {
  return e[Math.floor(Math.random() * e.length)];
}
function Yc(e) {
  const [t, n] = L(e[0].text[0]), r = Te(), i = (s = 0) => {
    s < e.length && !r.current && (r.current = setTimeout(() => {
      r.current = void 0;
      const a = (s + 1) % e.length;
      n(Zc(e[a].text)), i(a);
    }, e[s].duration));
  };
  return {
    text: t,
    doStep: i,
    clear: () => {
      clearTimeout(r.current), n(e[0].text[0]), r.current = void 0;
    }
  };
}
const Kc = "#b8b8b8", Xc = Ic(({
  messages: e,
  isLoading: t,
  onRate: n,
  scrollToBottom: r,
  onScroll: i
}, o) => {
  const [s, a] = L(!1), {
    doStep: c,
    text: d,
    clear: l
  } = Yc(zc);
  J(() => t ? c() : l(), [t]);
  const u = Rt((_, S) => {
    a(_ === "start" ? !1 : S === "assistant");
  }, [a]), p = e[e.length - 1], f = t && p.role === "assistant" ? e.slice(0, e.length - 1) : e;
  return g("div", {
    className: "didagent__messages__container",
    ref: o,
    "data-testid": "didagent_messages",
    onScroll: i,
    children: [f.filter(({
      content: _
    }) => !!_).map((_, S) => g("div", {
      className: `didagent__message__container didagent__message__container__${_.role}`,
      children: [g("pre", {
        className: `didagent__message didagent__message__${_.role}`,
        children: g(Gc, {
          text: _.content,
          role: _.role,
          onTypingStatusChange: u,
          scrollToBottom: r
        }, _.id)
      }), S > 0 && _.role === "assistant" && g(Vc, {
        className: "didagent__message__rating",
        message: _,
        show: s,
        onRate: n,
        style: {
          opacity: S === e.length - 1 ? 1 : void 0
        }
      })]
    }, _.id)), t && g("div", {
      className: "didagent__message__container didagent__message__container__assistant",
      "data-testid": "didagent_message_loader",
      children: g("pre", {
        className: "didagent__message didagent__message__assistant didagent__message__assistant__loader",
        children: [g(de, {
          src: Cc,
          color: Kc,
          size: "22px"
        }), d]
      })
    })]
  });
}), Jc = "data:image/svg+xml,%3csvg%20width='22'%20height='12'%20viewBox='0%200%2022%2012'%20fill='none'%20xmlns='http://www.w3.org/2000/svg'%3e%3cpath%20d='M20.7997%201.79923L10.9997%2010.1992L1.19971%201.79922'%20stroke='%23FFFEFD'%20stroke-width='2.1'%20stroke-linecap='round'%20stroke-linejoin='round'/%3e%3c/svg%3e";
function Qc(e) {
  return e ? {
    maxHeight: "180px",
    paddingbottom: "8px",
    marginBottom: "-8px"
  } : {
    maxHeight: "0",
    paddingBottom: "0",
    marginBottom: "0"
  };
}
function eu({
  messages: e,
  onClick: t,
  show: n,
  enabled: r
}) {
  const [i, o] = L(!1);
  J(() => {
    n && e.length > 0 && setTimeout(() => {
      o(!0);
    }, 2e3);
  }, [n, e]);
  const s = (a) => {
    var c;
    r && t(a), (c = window.dataLayer) == null || c.push({
      event: "clicked_starter_message",
      message: a
    });
  };
  return g("div", {
    className: "didagent__starter_messages__container",
    style: Qc(i && n),
    children: e.map((a) => g("div", {
      className: `didagent__starter_message__container ${r ? "" : "disabled"}`,
      onClick: () => s(a),
      children: [g("div", {
        className: "didagent__starter_message__container_text",
        children: a
      }), g(de, {
        src: Jc,
        size: "16px",
        color: "rgba(255, 255, 255, 0.7)",
        className: "didagent__starter_message__arrow"
      })]
    }, a))
  });
}
function tu({
  streamState: e,
  connectionState: t,
  srcObject: n,
  idleVideo: r,
  isBlur: i,
  muted: o,
  onVideoPlay: s,
  onVideoStop: a,
  onIdleLoad: c
}) {
  const d = Te(null), l = Te(), {
    configurations: u
  } = fe(Be), [p, f] = L(0), _ = Yo();
  return J(() => {
    n && d.current && (l.current = n);
  }, [n, d.current]), J(() => {
    d.current && (e === X.Start ? (d.current.srcObject = l.current, _ && (Ko() && (d.current.volume = 1), d.current.play().catch((S) => {
      console.log("Failed to play the video", S);
    }))) : e === X.New && (f(0), setTimeout(() => {
      d.current && (d.current.srcObject = null);
    }, 500)));
  }, [e]), g("div", {
    className: "didagent__embedded__video__container",
    "data-orientation": u.orientation,
    "data-blur": i,
    children: [g("video", {
      "data-testid": "didagent__video_stream",
      onPlay: () => {
        t === P.Connected && (f(1), s == null || s());
      },
      muted: o || t !== P.Connected,
      ref: d,
      autoPlay: !0,
      playsInline: !0,
      onAbort: (S) => a == null ? void 0 : a(S),
      onPause: (S) => a == null ? void 0 : a(S),
      style: {
        opacity: p
      }
    }), g("video", {
      "data-testid": "didagent__video_idle",
      autoPlay: !0,
      playsInline: !0,
      onLoadedData: c,
      src: r,
      muted: !0,
      loop: !0,
      style: {
        opacity: 1 - p
      }
    })]
  });
}
function nu({
  enabled: e,
  offline: t,
  styles: n,
  onClose: r,
  onError: i
}) {
  var Kr, Xr, Jr, Qr;
  const {
    isAuthenticated: o
  } = fe(Dt), {
    disconnect: s,
    setStreamState: a,
    streamedMessage: c,
    streamState: d,
    connectionState: l,
    agentManager: u,
    setError: p,
    srcObject: f,
    connect: _,
    messages: S,
    reconnect: b,
    terminating: E
  } = fe(Ft), {
    configurations: h,
    configure: y
  } = fe(Be), T = Te(!0), w = Te(null), m = Te(null), k = Te(null), [N, R] = L(""), [D, z] = L(!1), [Z, q] = L(!1), [M, G] = L(!1), [j, re] = L(!1), [te, Gt] = L(!1), [la, fa] = L(0), [pa, Gr] = L(!1);
  function Wr($ = !1) {
    m.current && ($ || T.current) && m.current.scrollTo({
      top: m.current.scrollHeight,
      behavior: "smooth"
    });
  }
  J(() => {
    f && w.current && (w.current.srcObject = f);
  }, [f]), ec(() => Wr(!0), [S, M]), J(() => {
    [X.Buffering, X.Loading].includes(d) ? G(!0) : [X.New, X.Fail].includes(d) && G(!1);
  }, [d]), J(() => {
    var $;
    j ? G(!1) : ($ = k.current) == null || $.focus();
  }, [j, c]), J(() => {
    (Z || [C.Maintenance].includes(h.chatMode)) && y({
      loaderConfig: {
        ...h.loaderConfig,
        show: !1
      }
    });
  }, [y, Z, h.chatMode]), J(() => {
    h.chatMode === C.Maintenance && (p(`${(u == null ? void 0 : u.agent.preview_name) || "Agent"} is not available at the moment`), s());
  }, [u, h.chatMode]);
  async function Wt($) {
    var zt;
    if ($ = $.trim(), $ === "")
      return;
    let Se = !1;
    if (Xn.includes(l) && (await b(), Se = !0), o) {
      if (![C.TextOnly, C.Playground].includes(h.chatMode) && (!m.current || $.trim().length === 0 || ![X.New].includes(d) || !([P.Connected].includes(l) || Se)))
        return;
    } else
      return De("agent-offline-onsend", {
        event: "click"
      }), t == null ? void 0 : t.onSend(N);
    u != null && u.starterMessages && u.starterMessages.indexOf($) > -1 && De("agent-starter-question", {
      event: "click",
      question: $
    }), R(""), a(X.Loading);
    try {
      if (!u)
        throw new Error("AgentManager is not available");
      const pe = await u.chat($).catch(async (Zt) => {
        var ei;
        if ((ei = Zt == null ? void 0 : Zt.message) != null && ei.includes("Playground chat limit exceeded"))
          throw new Error("Playground chat limit exceeded");
        return console.error("Error in sending message", Zt), {
          chatMode: C.Maintenance,
          result: "Sorry, I am not available right now",
          matches: []
        };
      });
      if (pe.chatMode && (u.changeMode(pe.chatMode), pe.chatMode === C.Maintenance))
        return console.log("Agent is in maintenance mode"), i == null || i(new Error("Agent is in maintenance mode"), pe), s();
      a([C.TextOnly, C.Playground].includes(pe.chatMode) ? X.New : X.Buffering);
    } catch (pe) {
      throw a(X.New), pe;
    } finally {
      (zt = k.current) == null || zt.focus();
    }
  }
  async function _a($, Se, zt) {
    if (!u)
      throw new Error("AgentManager is not available");
    return u.rate(Se.id, $ === me.Positive ? 1 : -1, zt).then((pe) => pe.id).catch((pe) => {
      throw console.error("Error in rating", pe), new Error("Error in rating " + pe.message);
    });
  }
  const ha = Rt(async () => {
    var $;
    await s(), await _(), De("agent-new-chat", {
      event: "click",
      agentId: ($ = u == null ? void 0 : u.agent) == null ? void 0 : $.id
    });
  }, [u, _, s]), ga = Rt(() => {
    var Se;
    const $ = {
      opacity: +!!((Se = h.loaderConfig) != null && Se.show)
    };
    return h.loaderConfig.style === "opaque" ? {
      ...$,
      "--background-color": "var(--did-primary-black-90)"
    } : {
      ...$,
      "--background-color": "var(--did-primary-black-00030)",
      "--backdrop-filter": "blur(4px)"
    };
  }, [h.loaderConfig]), ma = !((Kr = u == null ? void 0 : u.agent.metadata) != null && Kr.plan && [Mo.ENTERPRISE, Io.ENTERPRISE].includes(u.agent.metadata.plan)), ya = Cn(() => {
    var $, Se;
    return e && !!((Se = ($ = u == null ? void 0 : u.agent.knowledge) == null ? void 0 : $.embedder) != null && Se.is_limited_language);
  }, [e, u == null ? void 0 : u.agent]), zr = h.chatMode && [C.TextOnly, C.Playground].includes(h.chatMode), Zr = h.loaderConfig.show || [X.Start, X.Loading, X.Buffering].includes(d) && !zr, Yr = Zr || N.trim() === "";
  return g("div", {
    className: `didagent__embedded__container ${te ? "didagent__fullscreen" : ""}`,
    children: [g("div", {
      className: "didagent__embedded__container__loading",
      style: ga(),
      children: [g(de, {
        src: Zo,
        size: "64px",
        color: "var(--did-secondary-60)"
      }), g("span", {
        children: h.loaderConfig.text || ""
      })]
    }), g("div", {
      className: "didagent__background",
      style: {
        background: `url(${u == null ? void 0 : u.agent.preview_thumbnail}) top center no-repeat transparent`
      }
    }), g(tu, {
      connectionState: l,
      streamState: d,
      srcObject: f,
      idleVideo: h.chatMode === C.Playground || (Xr = u == null ? void 0 : u.agent.presenter) == null ? void 0 : Xr.idle_video,
      muted: D,
      isBlur: h.chatMode === C.Maintenance,
      onVideoPlay: () => re(!0),
      onVideoStop: () => re(!1),
      onIdleLoad: () => q(!0)
    }), g(lc, {
      hide: ![C.TextOnly, C.Playground].includes(h.chatMode),
      content: `${h.chatMode === C.TextOnly && ((Jr = u == null ? void 0 : u.agent) == null ? void 0 : Jr.status) === "done" ? "Performance mode" : "Youre in preview mode"}, sound and face animations wont show`
    }), g(Tc, {
      name: (u == null ? void 0 : u.agent.preview_name) ?? "Agent",
      icon: u == null ? void 0 : u.agent.logo,
      displayRestart: S.length > 1 || h.chatMode === C.Maintenance,
      onRestart: ha,
      restartDisabled: ![P.Connected, P.New, P.Disconnected, P.Fail].includes(l),
      displayMuteButton: !zr,
      onMute: () => z(($) => !$),
      muted: D,
      isRestarting: E,
      closeClassName: n == null ? void 0 : n.closeClassName,
      onClose: r,
      onEasterEgg: () => {
        console.log("onEaster"), Gt(!te);
      }
    }), g("div", {
      className: "didagent__filler"
    }), h.chatMode !== C.Maintenance && g("div", {
      className: "didagent__main__container",
      children: [g(Xc, {
        messages: S,
        isLoading: M,
        ref: m,
        onRate: _a,
        onScroll: () => {
          m.current && (T.current = m.current.scrollHeight - m.current.scrollTop <= m.current.clientHeight + 20);
        },
        scrollToBottom: Wr
      }), g(dc, {
        display: ya,
        content: `This agent only interacts in ${(Qr = u == null ? void 0 : u.agent.presenter.voice) == null ? void 0 : Qr.language}`
      }), g(eu, {
        show: S.length <= 1 && !h.loaderConfig.show,
        enabled: l === P.Connected || [C.TextOnly, C.Playground].includes(h.chatMode),
        messages: (u == null ? void 0 : u.starterMessages) ?? [],
        onClick: Wt
      }), g("div", {
        className: "didagent__main__input",
        style: {
          height: la > 1 ? "68px" : "52px",
          "--focus": pa ? "white" : void 0
        },
        children: [g("textarea", {
          disabled: [C.Maintenance, C.DirectPlayback].includes(h.chatMode) || h.loaderConfig.show,
          ref: k,
          placeholder: "Type here...",
          value: N,
          maxLength: 790,
          onFocus: () => Gr(!0),
          onBlur: () => Gr(!1),
          onInput: ($) => {
            fa(cc($.currentTarget)), R($.currentTarget.value), Xn.includes(l) && b();
          },
          onKeyPress: async ($) => {
            !$.shiftKey && $.key === "Enter" && ($.preventDefault(), Yr || Wt(N));
          }
        }), g(mc, {
          onSend: () => Wt(N),
          onTranscript: Wt,
          text: N,
          isSttSendDisabled: Zr,
          isMessageSendDisabled: Yr,
          className: "didagent__main__input-send"
        })]
      })]
    }), g(vc, {
      show: ma
    })]
  });
}
function rs({
  offline: e,
  isOwner: t,
  didApiUrl: n,
  didSocketApiUrl: r,
  onError: i,
  customMixpanelKey: o,
  onAgentReady: s,
  styles: a,
  onClose: c,
  enabled: d = !0
}) {
  const {
    configurations: l
  } = fe(Be);
  return window.localStorage.setItem("track_enabled", (l.track ?? !0).toString()), Yn.mixpanelKey = o || Yn.mixpanelKey, tc((u) => i == null ? void 0 : i(u, {})), g(sc, {
    auth: l.auth,
    didApiUrl: n ?? Ya,
    didSocketApiUrl: r ?? Ka,
    children: g(ac, {
      agentId: l.agentId,
      enabled: d,
      onAgentReady: s,
      onError: i,
      children: g(nu, {
        enabled: d,
        offline: e,
        isOwner: t,
        styles: a,
        onClose: c,
        onError: i
      })
    })
  });
}
function ru(e, t) {
  return {
    cursor: e ? "pointer" : "progress",
    opacity: t || !e ? "0" : "1",
    pointerEvents: e ? "auto" : "none",
    border: t ? "none" : "3px solid var(--did-primary-black-300)",
    bottom: e ? "0" : "-50%"
  };
}
function iu(e) {
  const t = {
    opacity: +e,
    translate: e ? "0px -50%" : "0px -60%"
  };
  return e || (t.background = "transparent"), t;
}
function ou(e) {
  var f;
  const {
    configurations: t
  } = fe(Be), [n, r] = L(), [i, o] = L(!1), [s, a] = L(!1), [c, d] = L(!1), l = s && !c;
  if (J(() => {
    var _;
    n && !((_ = n.presenter) != null && _.idle_video) && n.preview_thumbnail && o(!0);
  }, [n]), J(() => {
    i && setTimeout(() => {
      a(!0), setTimeout(() => {
        a(!1);
      }, 3e3);
    }, 3e3);
  }, [i]), !t.visible)
    return null;
  const u = (_) => {
    var S;
    r(_), (S = e.onAgentReady) == null || S.call(e, _);
  }, p = () => {
    var _;
    d(!1), (_ = window.dataLayer) == null || _.push({
      event: "close_widget"
    });
  };
  return g("span", {
    className: "didagent__fabio",
    "data-position": t.position,
    "data-enabled": c,
    children: [g("button", {
      "data-testid": "didagent__fabio__button",
      style: ru(i, c),
      onClick: () => {
        var _;
        (_ = window.dataLayer) == null || _.push({
          event: "open_widget"
        }), i && (d(!c), De("agent-fab", {
          event: "click"
        }));
      },
      children: [g("div", {
        className: `didagent__fabio__speak_with ${c ? "didagent__transition_out" : ""}`,
        style: iu(l),
        children: g("div", {
          children: "Let's chat"
        })
      }), g("video", {
        src: (n == null ? void 0 : n.preview_url) ?? ((f = n == null ? void 0 : n.presenter) == null ? void 0 : f.idle_video),
        poster: n == null ? void 0 : n.preview_thumbnail,
        alt: "toggle fabio",
        autoPlay: !0,
        playsInline: !0,
        loop: !0,
        muted: !0,
        onLoadedData: () => {
          o(!0), De("agent-fab", {
            event: "view"
          });
        }
      })]
    }), g("div", {
      onClick: (_) => _.stopPropagation(),
      className: "didagent__fabio__container",
      "data-enabled": c,
      "data-position": t.position,
      "data-orientation": t.orientation,
      children: g(rs, {
        ...e,
        onClose: p,
        enabled: c,
        onAgentReady: u
      })
    })]
  });
}
let Dn = [];
function su() {
  if (Dn.length === 0) {
    const e = document.getElementById("d-id-agent-style");
    Dn = e ? [e] : [];
  }
  return Dn;
}
function au(e) {
  const t = Te(null), {
    configurations: n
  } = fe(Be), [r, i] = L();
  return J(() => {
    const o = su();
    if (n.agentId) {
      if (!n.auth)
        throw new Error("No auth provider");
    } else
      throw new Error("No agent provider");
    if (n.mode === "fabio") {
      if (t.current) {
        const s = t.current.shadowRoot ? t.current.shadowRoot : t.current.attachShadow({
          mode: "open"
        });
        o.forEach((a) => s.appendChild(a)), i(Si(g(ou, {
          ...e
        }), s));
      }
    } else if (n.mode === "full") {
      const s = typeof n.targetElement == "string" ? document.getElementById(n.targetElement) : n.targetElement;
      if (n.targetElement) {
        if (!s)
          throw new Error(`No target element for id: ${n.targetElement}`);
      } else
        throw new Error("No target element id");
      const a = s.shadowRoot ? s.shadowRoot : s.attachShadow({
        mode: "open"
      });
      o.forEach((c) => a.appendChild(c)), i(Si(g(rs, {
        ...e
      }), a));
    } else
      throw new Error("Invalid mode");
  }, [n.mode, n.targetElement, n.agentId, n.auth]), g(Fe, {
    children: [g("div", {
      ref: t,
      "data-testid": "didagent_root"
    }), r]
  });
}
const is = Object.prototype.toString;
function os(e) {
  switch (is.call(e)) {
    case "[object Error]":
    case "[object Exception]":
    case "[object DOMException]":
      return !0;
    default:
      return Ne(e, Error);
  }
}
function mt(e, t) {
  return is.call(e) === `[object ${t}]`;
}
function ss(e) {
  return mt(e, "ErrorEvent");
}
function Mi(e) {
  return mt(e, "DOMError");
}
function cu(e) {
  return mt(e, "DOMException");
}
function Me(e) {
  return mt(e, "String");
}
function Ir(e) {
  return typeof e == "object" && e !== null && "__sentry_template_string__" in e && "__sentry_template_values__" in e;
}
function Mr(e) {
  return e === null || Ir(e) || typeof e != "object" && typeof e != "function";
}
function dt(e) {
  return mt(e, "Object");
}
function kn(e) {
  return typeof Event < "u" && Ne(e, Event);
}
function uu(e) {
  return typeof Element < "u" && Ne(e, Element);
}
function du(e) {
  return mt(e, "RegExp");
}
function In(e) {
  return !!(e && e.then && typeof e.then == "function");
}
function lu(e) {
  return dt(e) && "nativeEvent" in e && "preventDefault" in e && "stopPropagation" in e;
}
function Ne(e, t) {
  try {
    return e instanceof t;
  } catch {
    return !1;
  }
}
function as(e) {
  return !!(typeof e == "object" && e !== null && (e.__isVue || e._isVue));
}
function ct(e, t = 0) {
  return typeof e != "string" || t === 0 || e.length <= t ? e : `${e.slice(0, t)}...`;
}
function Ni(e, t) {
  if (!Array.isArray(e))
    return "";
  const n = [];
  for (let r = 0; r < e.length; r++) {
    const i = e[r];
    try {
      as(i) ? n.push("[VueViewModel]") : n.push(String(i));
    } catch {
      n.push("[value cannot be serialized]");
    }
  }
  return n.join(t);
}
function fu(e, t, n = !1) {
  return Me(e) ? du(t) ? t.test(e) : Me(t) ? n ? e === t : e.includes(t) : !1 : !1;
}
function Ge(e, t = [], n = !1) {
  return t.some((r) => fu(e, r, n));
}
function pu(e, t, n = 250, r, i, o, s) {
  if (!o.exception || !o.exception.values || !s || !Ne(s.originalException, Error))
    return;
  const a = o.exception.values.length > 0 ? o.exception.values[o.exception.values.length - 1] : void 0;
  a && (o.exception.values = _u(
    Jn(
      e,
      t,
      i,
      s.originalException,
      r,
      o.exception.values,
      a,
      0
    ),
    n
  ));
}
function Jn(e, t, n, r, i, o, s, a) {
  if (o.length >= n + 1)
    return o;
  let c = [...o];
  if (Ne(r[i], Error)) {
    Ai(s, a);
    const d = e(t, r[i]), l = c.length;
    xi(d, i, l, a), c = Jn(
      e,
      t,
      n,
      r[i],
      i,
      [d, ...c],
      d,
      l
    );
  }
  return Array.isArray(r.errors) && r.errors.forEach((d, l) => {
    if (Ne(d, Error)) {
      Ai(s, a);
      const u = e(t, d), p = c.length;
      xi(u, `errors[${l}]`, p, a), c = Jn(
        e,
        t,
        n,
        d,
        i,
        [u, ...c],
        u,
        p
      );
    }
  }), c;
}
function Ai(e, t) {
  e.mechanism = e.mechanism || { type: "generic", handled: !0 }, e.mechanism = {
    ...e.mechanism,
    ...e.type === "AggregateError" && { is_exception_group: !0 },
    exception_id: t
  };
}
function xi(e, t, n, r) {
  e.mechanism = e.mechanism || { type: "generic", handled: !0 }, e.mechanism = {
    ...e.mechanism,
    type: "chained",
    source: t,
    exception_id: n,
    parent_id: r
  };
}
function _u(e, t) {
  return e.map((n) => (n.value && (n.value = ct(n.value, t)), n));
}
const F = globalThis;
function Nr(e, t, n) {
  const r = F, i = r.__SENTRY__ = r.__SENTRY__ || {};
  return i[e] || (i[e] = t());
}
const ut = F, hu = 80;
function lt(e, t = {}) {
  if (!e)
    return "<unknown>";
  try {
    let n = e;
    const r = 5, i = [];
    let o = 0, s = 0;
    const a = " > ", c = a.length;
    let d;
    const l = Array.isArray(t) ? t : t.keyAttrs, u = !Array.isArray(t) && t.maxStringLength || hu;
    for (; n && o++ < r && (d = gu(n, l), !(d === "html" || o > 1 && s + i.length * c + d.length >= u)); )
      i.push(d), s += d.length, n = n.parentNode;
    return i.reverse().join(a);
  } catch {
    return "<unknown>";
  }
}
function gu(e, t) {
  const n = e, r = [];
  let i, o, s, a, c;
  if (!n || !n.tagName)
    return "";
  if (ut.HTMLElement && n instanceof HTMLElement && n.dataset) {
    if (n.dataset.sentryComponent)
      return n.dataset.sentryComponent;
    if (n.dataset.sentryElement)
      return n.dataset.sentryElement;
  }
  r.push(n.tagName.toLowerCase());
  const d = t && t.length ? t.filter((u) => n.getAttribute(u)).map((u) => [u, n.getAttribute(u)]) : null;
  if (d && d.length)
    d.forEach((u) => {
      r.push(`[${u[0]}="${u[1]}"]`);
    });
  else if (n.id && r.push(`#${n.id}`), i = n.className, i && Me(i))
    for (o = i.split(/\s+/), c = 0; c < o.length; c++)
      r.push(`.${o[c]}`);
  const l = ["aria-label", "type", "name", "title", "alt"];
  for (c = 0; c < l.length; c++)
    s = l[c], a = n.getAttribute(s), a && r.push(`[${s}="${a}"]`);
  return r.join("");
}
function mu() {
  try {
    return ut.document.location.href;
  } catch {
    return "";
  }
}
function yu(e) {
  return ut.document && ut.document.querySelector ? ut.document.querySelector(e) : null;
}
function cs(e) {
  if (!ut.HTMLElement)
    return null;
  let t = e;
  const n = 5;
  for (let r = 0; r < n; r++) {
    if (!t)
      return null;
    if (t instanceof HTMLElement) {
      if (t.dataset.sentryComponent)
        return t.dataset.sentryComponent;
      if (t.dataset.sentryElement)
        return t.dataset.sentryElement;
    }
    t = t.parentNode;
  }
  return null;
}
const yt = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, vu = "Sentry Logger ", Qn = [
  "debug",
  "info",
  "warn",
  "error",
  "log",
  "assert",
  "trace"
], gn = {};
function Ht(e) {
  if (!("console" in F))
    return e();
  const t = F.console, n = {}, r = Object.keys(gn);
  r.forEach((i) => {
    const o = gn[i];
    n[i] = t[i], t[i] = o;
  });
  try {
    return e();
  } finally {
    r.forEach((i) => {
      t[i] = n[i];
    });
  }
}
function Su() {
  let e = !1;
  const t = {
    enable: () => {
      e = !0;
    },
    disable: () => {
      e = !1;
    },
    isEnabled: () => e
  };
  return yt ? Qn.forEach((n) => {
    t[n] = (...r) => {
      e && Ht(() => {
        F.console[n](`${vu}[${n}]:`, ...r);
      });
    };
  }) : Qn.forEach((n) => {
    t[n] = () => {
    };
  }), t;
}
const v = Su(), bu = /^(?:(\w+):)\/\/(?:(\w+)(?::(\w+)?)?@)([\w.-]+)(?::(\d+))?\/(.+)/;
function Eu(e) {
  return e === "http" || e === "https";
}
function Ut(e, t = !1) {
  const { host: n, path: r, pass: i, port: o, projectId: s, protocol: a, publicKey: c } = e;
  return `${a}://${c}${t && i ? `:${i}` : ""}@${n}${o ? `:${o}` : ""}/${r && `${r}/`}${s}`;
}
function wu(e) {
  const t = bu.exec(e);
  if (!t) {
    Ht(() => {
      console.error(`Invalid Sentry Dsn: ${e}`);
    });
    return;
  }
  const [n, r, i = "", o, s = "", a] = t.slice(1);
  let c = "", d = a;
  const l = d.split("/");
  if (l.length > 1 && (c = l.slice(0, -1).join("/"), d = l.pop()), d) {
    const u = d.match(/^\d+/);
    u && (d = u[0]);
  }
  return us({ host: o, pass: i, path: c, projectId: d, port: s, protocol: n, publicKey: r });
}
function us(e) {
  return {
    protocol: e.protocol,
    publicKey: e.publicKey || "",
    pass: e.pass || "",
    host: e.host,
    port: e.port || "",
    path: e.path || "",
    projectId: e.projectId
  };
}
function Tu(e) {
  if (!yt)
    return !0;
  const { port: t, projectId: n, protocol: r } = e;
  return ["protocol", "publicKey", "host", "projectId"].find((s) => e[s] ? !1 : (v.error(`Invalid Sentry Dsn: ${s} missing`), !0)) ? !1 : n.match(/^\d+$/) ? Eu(r) ? t && isNaN(parseInt(t, 10)) ? (v.error(`Invalid Sentry Dsn: Invalid port ${t}`), !1) : !0 : (v.error(`Invalid Sentry Dsn: Invalid protocol ${r}`), !1) : (v.error(`Invalid Sentry Dsn: Invalid projectId ${n}`), !1);
}
function Cu(e) {
  const t = typeof e == "string" ? wu(e) : us(e);
  if (!(!t || !Tu(t)))
    return t;
}
class we extends Error {
  /** Display name of this error instance. */
  constructor(t, n = "warn") {
    super(t), this.message = t, this.name = new.target.prototype.constructor.name, Object.setPrototypeOf(this, new.target.prototype), this.logLevel = n;
  }
}
function ne(e, t, n) {
  if (!(t in e))
    return;
  const r = e[t], i = n(r);
  typeof i == "function" && ds(i, r), e[t] = i;
}
function ve(e, t, n) {
  try {
    Object.defineProperty(e, t, {
      // enumerable: false, // the default, so we can save on bundle size by not explicitly setting it
      value: n,
      writable: !0,
      configurable: !0
    });
  } catch {
    yt && v.log(`Failed to add non-enumerable property "${t}" to object`, e);
  }
}
function ds(e, t) {
  try {
    const n = t.prototype || {};
    e.prototype = t.prototype = n, ve(e, "__sentry_original__", t);
  } catch {
  }
}
function Ar(e) {
  return e.__sentry_original__;
}
function ku(e) {
  return Object.keys(e).map((t) => `${encodeURIComponent(t)}=${encodeURIComponent(e[t])}`).join("&");
}
function ls(e) {
  if (os(e))
    return {
      message: e.message,
      name: e.name,
      stack: e.stack,
      ...Li(e)
    };
  if (kn(e)) {
    const t = {
      type: e.type,
      target: Ri(e.target),
      currentTarget: Ri(e.currentTarget),
      ...Li(e)
    };
    return typeof CustomEvent < "u" && Ne(e, CustomEvent) && (t.detail = e.detail), t;
  } else
    return e;
}
function Ri(e) {
  try {
    return uu(e) ? lt(e) : Object.prototype.toString.call(e);
  } catch {
    return "<unknown>";
  }
}
function Li(e) {
  if (typeof e == "object" && e !== null) {
    const t = {};
    for (const n in e)
      Object.prototype.hasOwnProperty.call(e, n) && (t[n] = e[n]);
    return t;
  } else
    return {};
}
function Iu(e, t = 40) {
  const n = Object.keys(ls(e));
  if (n.sort(), !n.length)
    return "[object has no keys]";
  if (n[0].length >= t)
    return ct(n[0], t);
  for (let r = n.length; r > 0; r--) {
    const i = n.slice(0, r).join(", ");
    if (!(i.length > t))
      return r === n.length ? i : ct(i, t);
  }
  return "";
}
function ie(e) {
  return er(e, /* @__PURE__ */ new Map());
}
function er(e, t) {
  if (Mu(e)) {
    const n = t.get(e);
    if (n !== void 0)
      return n;
    const r = {};
    t.set(e, r);
    for (const i of Object.keys(e))
      typeof e[i] < "u" && (r[i] = er(e[i], t));
    return r;
  }
  if (Array.isArray(e)) {
    const n = t.get(e);
    if (n !== void 0)
      return n;
    const r = [];
    return t.set(e, r), e.forEach((i) => {
      r.push(er(i, t));
    }), r;
  }
  return e;
}
function Mu(e) {
  if (!dt(e))
    return !1;
  try {
    const t = Object.getPrototypeOf(e).constructor.name;
    return !t || t === "Object";
  } catch {
    return !0;
  }
}
const fs = 50, vt = "?", Oi = /\(error: (.*)\)/, Pi = /captureMessage|captureException/;
function ps(...e) {
  const t = e.sort((n, r) => n[0] - r[0]).map((n) => n[1]);
  return (n, r = 0, i = 0) => {
    const o = [], s = n.split(`
`);
    for (let a = r; a < s.length; a++) {
      const c = s[a];
      if (c.length > 1024)
        continue;
      const d = Oi.test(c) ? c.replace(Oi, "$1") : c;
      if (!d.match(/\S*Error: /)) {
        for (const l of t) {
          const u = l(d);
          if (u) {
            o.push(u);
            break;
          }
        }
        if (o.length >= fs + i)
          break;
      }
    }
    return Au(o.slice(i));
  };
}
function Nu(e) {
  return Array.isArray(e) ? ps(...e) : e;
}
function Au(e) {
  if (!e.length)
    return [];
  const t = Array.from(e);
  return /sentryWrapped/.test(t[t.length - 1].function || "") && t.pop(), t.reverse(), Pi.test(t[t.length - 1].function || "") && (t.pop(), Pi.test(t[t.length - 1].function || "") && t.pop()), t.slice(0, fs).map((n) => ({
    ...n,
    filename: n.filename || t[t.length - 1].filename,
    function: n.function || vt
  }));
}
const Fn = "<anonymous>";
function Ae(e) {
  try {
    return !e || typeof e != "function" ? Fn : e.name || Fn;
  } catch {
    return Fn;
  }
}
const cn = {}, $i = {};
function Qe(e, t) {
  cn[e] = cn[e] || [], cn[e].push(t);
}
function et(e, t) {
  $i[e] || (t(), $i[e] = !0);
}
function ye(e, t) {
  const n = e && cn[e];
  if (n)
    for (const r of n)
      try {
        r(t);
      } catch (i) {
        yt && v.error(
          `Error while triggering instrumentation handler.
Type: ${e}
Name: ${Ae(r)}
Error:`,
          i
        );
      }
}
function xu(e) {
  const t = "console";
  Qe(t, e), et(t, Ru);
}
function Ru() {
  "console" in F && Qn.forEach(function(e) {
    e in F.console && ne(F.console, e, function(t) {
      return gn[e] = t, function(...n) {
        ye("console", { args: n, level: e });
        const i = gn[e];
        i && i.apply(F.console, n);
      };
    });
  });
}
const tr = F;
function _s() {
  if (!("fetch" in tr))
    return !1;
  try {
    return new Headers(), new Request("http://www.example.com"), new Response(), !0;
  } catch {
    return !1;
  }
}
function nr(e) {
  return e && /^function\s+\w+\(\)\s+\{\s+\[native code\]\s+\}$/.test(e.toString());
}
function Lu() {
  if (typeof EdgeRuntime == "string")
    return !0;
  if (!_s())
    return !1;
  if (nr(tr.fetch))
    return !0;
  let e = !1;
  const t = tr.document;
  if (t && typeof t.createElement == "function")
    try {
      const n = t.createElement("iframe");
      n.hidden = !0, t.head.appendChild(n), n.contentWindow && n.contentWindow.fetch && (e = nr(n.contentWindow.fetch)), t.head.removeChild(n);
    } catch (n) {
      yt && v.warn("Could not create sandbox iframe for pure fetch check, bailing to window.fetch: ", n);
    }
  return e;
}
const hs = 1e3;
function Bt() {
  return Date.now() / hs;
}
function Ou() {
  const { performance: e } = F;
  if (!e || !e.now)
    return Bt;
  const t = Date.now() - e.now(), n = e.timeOrigin == null ? t : e.timeOrigin;
  return () => (n + e.now()) / hs;
}
const ce = Ou(), he = (() => {
  const { performance: e } = F;
  if (!e || !e.now)
    return;
  const t = 3600 * 1e3, n = e.now(), r = Date.now(), i = e.timeOrigin ? Math.abs(e.timeOrigin + n - r) : t, o = i < t, s = e.timing && e.timing.navigationStart, c = typeof s == "number" ? Math.abs(s + n - r) : t, d = c < t;
  return o || d ? i <= c ? e.timeOrigin : s : r;
})();
function gs(e) {
  const t = "fetch";
  Qe(t, e), et(t, Pu);
}
function Pu() {
  Lu() && ne(F, "fetch", function(e) {
    return function(...t) {
      const { method: n, url: r } = $u(t), i = {
        args: t,
        fetchData: {
          method: n,
          url: r
        },
        startTimestamp: ce() * 1e3
      };
      return ye("fetch", {
        ...i
      }), e.apply(F, t).then(
        (o) => {
          const s = {
            ...i,
            endTimestamp: ce() * 1e3,
            response: o
          };
          return ye("fetch", s), o;
        },
        (o) => {
          const s = {
            ...i,
            endTimestamp: ce() * 1e3,
            error: o
          };
          throw ye("fetch", s), o;
        }
      );
    };
  });
}
function rr(e, t) {
  return !!e && typeof e == "object" && !!e[t];
}
function Di(e) {
  return typeof e == "string" ? e : e ? rr(e, "url") ? e.url : e.toString ? e.toString() : "" : "";
}
function $u(e) {
  if (e.length === 0)
    return { method: "GET", url: "" };
  if (e.length === 2) {
    const [n, r] = e;
    return {
      url: Di(n),
      method: rr(r, "method") ? String(r.method).toUpperCase() : "GET"
    };
  }
  const t = e[0];
  return {
    url: Di(t),
    method: rr(t, "method") ? String(t.method).toUpperCase() : "GET"
  };
}
let Xt = null;
function ms(e) {
  const t = "error";
  Qe(t, e), et(t, Du);
}
function Du() {
  Xt = F.onerror, F.onerror = function(e, t, n, r, i) {
    return ye("error", {
      column: r,
      error: i,
      line: n,
      msg: e,
      url: t
    }), Xt && !Xt.__SENTRY_LOADER__ ? Xt.apply(this, arguments) : !1;
  }, F.onerror.__SENTRY_INSTRUMENTED__ = !0;
}
let Jt = null;
function ys(e) {
  const t = "unhandledrejection";
  Qe(t, e), et(t, Fu);
}
function Fu() {
  Jt = F.onunhandledrejection, F.onunhandledrejection = function(e) {
    return ye("unhandledrejection", e), Jt && !Jt.__SENTRY_LOADER__ ? Jt.apply(this, arguments) : !0;
  }, F.onunhandledrejection.__SENTRY_INSTRUMENTED__ = !0;
}
function Hu() {
  return "npm";
}
function Uu() {
  const e = typeof WeakSet == "function", t = e ? /* @__PURE__ */ new WeakSet() : [];
  function n(i) {
    if (e)
      return t.has(i) ? !0 : (t.add(i), !1);
    for (let o = 0; o < t.length; o++)
      if (t[o] === i)
        return !0;
    return t.push(i), !1;
  }
  function r(i) {
    if (e)
      t.delete(i);
    else
      for (let o = 0; o < t.length; o++)
        if (t[o] === i) {
          t.splice(o, 1);
          break;
        }
  }
  return [n, r];
}
function V() {
  const e = F, t = e.crypto || e.msCrypto;
  let n = () => Math.random() * 16;
  try {
    if (t && t.randomUUID)
      return t.randomUUID().replace(/-/g, "");
    t && t.getRandomValues && (n = () => {
      const r = new Uint8Array(1);
      return t.getRandomValues(r), r[0];
    });
  } catch {
  }
  return ("10000000100040008000" + 1e11).replace(
    /[018]/g,
    (r) => (
      // eslint-disable-next-line no-bitwise
      (r ^ (n() & 15) >> r / 4).toString(16)
    )
  );
}
function vs(e) {
  return e.exception && e.exception.values ? e.exception.values[0] : void 0;
}
function Ve(e) {
  const { message: t, event_id: n } = e;
  if (t)
    return t;
  const r = vs(e);
  return r ? r.type && r.value ? `${r.type}: ${r.value}` : r.type || r.value || n || "<unknown>" : n || "<unknown>";
}
function ir(e, t, n) {
  const r = e.exception = e.exception || {}, i = r.values = r.values || [], o = i[0] = i[0] || {};
  o.value || (o.value = t || ""), o.type || (o.type = "Error");
}
function Lt(e, t) {
  const n = vs(e);
  if (!n)
    return;
  const r = { type: "generic", handled: !0 }, i = n.mechanism;
  if (n.mechanism = { ...r, ...i, ...t }, t && "data" in t) {
    const o = { ...i && i.data, ...t.data };
    n.mechanism.data = o;
  }
}
function Fi(e) {
  if (e && e.__sentry_captured__)
    return !0;
  try {
    ve(e, "__sentry_captured__", !0);
  } catch {
  }
  return !1;
}
function Ss(e) {
  return Array.isArray(e) ? e : [e];
}
function Le(e, t = 100, n = 1 / 0) {
  try {
    return or("", e, t, n);
  } catch (r) {
    return { ERROR: `**non-serializable** (${r})` };
  }
}
function bs(e, t = 3, n = 100 * 1024) {
  const r = Le(e, t);
  return qu(r) > n ? bs(e, t - 1, n) : r;
}
function or(e, t, n = 1 / 0, r = 1 / 0, i = Uu()) {
  const [o, s] = i;
  if (t == null || // this matches null and undefined -> eqeq not eqeqeq
  ["number", "boolean", "string"].includes(typeof t) && !Number.isNaN(t))
    return t;
  const a = Bu(e, t);
  if (!a.startsWith("[object "))
    return a;
  if (t.__sentry_skip_normalization__)
    return t;
  const c = typeof t.__sentry_override_normalization_depth__ == "number" ? t.__sentry_override_normalization_depth__ : n;
  if (c === 0)
    return a.replace("object ", "");
  if (o(t))
    return "[Circular ~]";
  const d = t;
  if (d && typeof d.toJSON == "function")
    try {
      const f = d.toJSON();
      return or("", f, c - 1, r, i);
    } catch {
    }
  const l = Array.isArray(t) ? [] : {};
  let u = 0;
  const p = ls(t);
  for (const f in p) {
    if (!Object.prototype.hasOwnProperty.call(p, f))
      continue;
    if (u >= r) {
      l[f] = "[MaxProperties ~]";
      break;
    }
    const _ = p[f];
    l[f] = or(f, _, c - 1, r, i), u++;
  }
  return s(t), l;
}
function Bu(e, t) {
  try {
    if (e === "domain" && t && typeof t == "object" && t._events)
      return "[Domain]";
    if (e === "domainEmitter")
      return "[DomainEmitter]";
    if (typeof global < "u" && t === global)
      return "[Global]";
    if (typeof window < "u" && t === window)
      return "[Window]";
    if (typeof document < "u" && t === document)
      return "[Document]";
    if (as(t))
      return "[VueViewModel]";
    if (lu(t))
      return "[SyntheticEvent]";
    if (typeof t == "number" && t !== t)
      return "[NaN]";
    if (typeof t == "function")
      return `[Function: ${Ae(t)}]`;
    if (typeof t == "symbol")
      return `[${String(t)}]`;
    if (typeof t == "bigint")
      return `[BigInt: ${String(t)}]`;
    const n = ju(t);
    return /^HTML(\w*)Element$/.test(n) ? `[HTMLElement: ${n}]` : `[object ${n}]`;
  } catch (n) {
    return `**non-serializable** (${n})`;
  }
}
function ju(e) {
  const t = Object.getPrototypeOf(e);
  return t ? t.constructor.name : "null prototype";
}
function Vu(e) {
  return ~-encodeURI(e).split(/%..|./).length;
}
function qu(e) {
  return Vu(JSON.stringify(e));
}
var Ce;
(function(e) {
  e[e.PENDING = 0] = "PENDING";
  const n = 1;
  e[e.RESOLVED = n] = "RESOLVED";
  const r = 2;
  e[e.REJECTED = r] = "REJECTED";
})(Ce || (Ce = {}));
function Ke(e) {
  return new _e((t) => {
    t(e);
  });
}
function mn(e) {
  return new _e((t, n) => {
    n(e);
  });
}
class _e {
  constructor(t) {
    _e.prototype.__init.call(this), _e.prototype.__init2.call(this), _e.prototype.__init3.call(this), _e.prototype.__init4.call(this), this._state = Ce.PENDING, this._handlers = [];
    try {
      t(this._resolve, this._reject);
    } catch (n) {
      this._reject(n);
    }
  }
  /** JSDoc */
  then(t, n) {
    return new _e((r, i) => {
      this._handlers.push([
        !1,
        (o) => {
          if (!t)
            r(o);
          else
            try {
              r(t(o));
            } catch (s) {
              i(s);
            }
        },
        (o) => {
          if (!n)
            i(o);
          else
            try {
              r(n(o));
            } catch (s) {
              i(s);
            }
        }
      ]), this._executeHandlers();
    });
  }
  /** JSDoc */
  catch(t) {
    return this.then((n) => n, t);
  }
  /** JSDoc */
  finally(t) {
    return new _e((n, r) => {
      let i, o;
      return this.then(
        (s) => {
          o = !1, i = s, t && t();
        },
        (s) => {
          o = !0, i = s, t && t();
        }
      ).then(() => {
        if (o) {
          r(i);
          return;
        }
        n(i);
      });
    });
  }
  /** JSDoc */
  __init() {
    this._resolve = (t) => {
      this._setResult(Ce.RESOLVED, t);
    };
  }
  /** JSDoc */
  __init2() {
    this._reject = (t) => {
      this._setResult(Ce.REJECTED, t);
    };
  }
  /** JSDoc */
  __init3() {
    this._setResult = (t, n) => {
      if (this._state === Ce.PENDING) {
        if (In(n)) {
          n.then(this._resolve, this._reject);
          return;
        }
        this._state = t, this._value = n, this._executeHandlers();
      }
    };
  }
  /** JSDoc */
  __init4() {
    this._executeHandlers = () => {
      if (this._state === Ce.PENDING)
        return;
      const t = this._handlers.slice();
      this._handlers = [], t.forEach((n) => {
        n[0] || (this._state === Ce.RESOLVED && n[1](this._value), this._state === Ce.REJECTED && n[2](this._value), n[0] = !0);
      });
    };
  }
}
function Gu(e) {
  const t = [];
  function n() {
    return e === void 0 || t.length < e;
  }
  function r(s) {
    return t.splice(t.indexOf(s), 1)[0];
  }
  function i(s) {
    if (!n())
      return mn(new we("Not adding Promise because buffer limit was reached."));
    const a = s();
    return t.indexOf(a) === -1 && t.push(a), a.then(() => r(a)).then(
      null,
      () => r(a).then(null, () => {
      })
    ), a;
  }
  function o(s) {
    return new _e((a, c) => {
      let d = t.length;
      if (!d)
        return a(!0);
      const l = setTimeout(() => {
        s && s > 0 && a(!1);
      }, s);
      t.forEach((u) => {
        Ke(u).then(() => {
          --d || (clearTimeout(l), a(!0));
        }, c);
      });
    });
  }
  return {
    $: t,
    add: i,
    drain: o
  };
}
function We(e) {
  if (!e)
    return {};
  const t = e.match(/^(([^:/?#]+):)?(\/\/([^/?#]*))?([^?#]*)(\?([^#]*))?(#(.*))?$/);
  if (!t)
    return {};
  const n = t[6] || "", r = t[8] || "";
  return {
    host: t[4],
    path: t[5],
    protocol: t[2],
    search: n,
    hash: r,
    relative: t[5] + n + r
    // everything minus origin
  };
}
const Wu = ["fatal", "error", "warning", "log", "info", "debug"];
function zu(e) {
  return e === "warn" ? "warning" : Wu.includes(e) ? e : "log";
}
const sr = "baggage", Es = "sentry-", Zu = /^sentry-/, Yu = 8192;
function Ku(e) {
  const t = Xu(e);
  if (!t)
    return;
  const n = Object.entries(t).reduce((r, [i, o]) => {
    if (i.match(Zu)) {
      const s = i.slice(Es.length);
      r[s] = o;
    }
    return r;
  }, {});
  if (Object.keys(n).length > 0)
    return n;
}
function ws(e) {
  if (!e)
    return;
  const t = Object.entries(e).reduce(
    (n, [r, i]) => (i && (n[`${Es}${r}`] = i), n),
    {}
  );
  return Ju(t);
}
function Xu(e) {
  if (!(!e || !Me(e) && !Array.isArray(e)))
    return Array.isArray(e) ? e.reduce((t, n) => {
      const r = Hi(n);
      for (const i of Object.keys(r))
        t[i] = r[i];
      return t;
    }, {}) : Hi(e);
}
function Hi(e) {
  return e.split(",").map((t) => t.split("=").map((n) => decodeURIComponent(n.trim()))).reduce((t, [n, r]) => (t[n] = r, t), {});
}
function Ju(e) {
  if (Object.keys(e).length !== 0)
    return Object.entries(e).reduce((t, [n, r], i) => {
      const o = `${encodeURIComponent(n)}=${encodeURIComponent(r)}`, s = i === 0 ? o : `${t},${o}`;
      return s.length > Yu ? (yt && v.warn(
        `Not adding key: ${n} with val: ${r} to baggage header due to exceeding baggage size limits.`
      ), t) : s;
    }, "");
}
const Qu = new RegExp(
  "^[ \\t]*([0-9a-f]{32})?-?([0-9a-f]{16})?-?([01])?[ \\t]*$"
  // whitespace
);
function ed(e) {
  if (!e)
    return;
  const t = e.match(Qu);
  if (!t)
    return;
  let n;
  return t[3] === "1" ? n = !0 : t[3] === "0" && (n = !1), {
    traceId: t[1],
    parentSampled: n,
    parentSpanId: t[2]
  };
}
function td(e, t) {
  const n = ed(e), r = Ku(t), { traceId: i, parentSpanId: o, parentSampled: s } = n || {};
  return n ? {
    traceId: i || V(),
    parentSpanId: o || V().substring(16),
    spanId: V().substring(16),
    sampled: s,
    dsc: r || {}
    // If we have traceparent data but no DSC it means we are not head of trace and we must freeze it
  } : {
    traceId: i || V(),
    spanId: V().substring(16)
  };
}
function xr(e = V(), t = V().substring(16), n) {
  let r = "";
  return n !== void 0 && (r = n ? "-1" : "-0"), `${e}-${t}${r}`;
}
function St(e, t = []) {
  return [e, t];
}
function nd(e, t) {
  const [n, r] = e;
  return [n, [...r, t]];
}
function Ui(e, t) {
  const n = e[1];
  for (const r of n) {
    const i = r[0].type;
    if (t(r, i))
      return !0;
  }
  return !1;
}
function ar(e) {
  return F.__SENTRY__ && F.__SENTRY__.encodePolyfill ? F.__SENTRY__.encodePolyfill(e) : new TextEncoder().encode(e);
}
function rd(e) {
  const [t, n] = e;
  let r = JSON.stringify(t);
  function i(o) {
    typeof r == "string" ? r = typeof o == "string" ? r + o : [ar(r), o] : r.push(typeof o == "string" ? ar(o) : o);
  }
  for (const o of n) {
    const [s, a] = o;
    if (i(`
${JSON.stringify(s)}
`), typeof a == "string" || a instanceof Uint8Array)
      i(a);
    else {
      let c;
      try {
        c = JSON.stringify(a);
      } catch {
        c = JSON.stringify(Le(a));
      }
      i(c);
    }
  }
  return typeof r == "string" ? r : id(r);
}
function id(e) {
  const t = e.reduce((i, o) => i + o.length, 0), n = new Uint8Array(t);
  let r = 0;
  for (const i of e)
    n.set(i, r), r += i.length;
  return n;
}
function od(e) {
  return [{
    type: "span"
  }, e];
}
function sd(e) {
  const t = typeof e.data == "string" ? ar(e.data) : e.data;
  return [
    ie({
      type: "attachment",
      length: t.length,
      filename: e.filename,
      content_type: e.contentType,
      attachment_type: e.attachmentType
    }),
    t
  ];
}
const ad = {
  session: "session",
  sessions: "session",
  attachment: "attachment",
  transaction: "transaction",
  event: "error",
  client_report: "internal",
  user_report: "default",
  profile: "profile",
  replay_event: "replay",
  replay_recording: "replay",
  check_in: "monitor",
  feedback: "feedback",
  span: "span",
  statsd: "metric_bucket"
};
function Bi(e) {
  return ad[e];
}
function Ts(e) {
  if (!e || !e.sdk)
    return;
  const { name: t, version: n } = e.sdk;
  return { name: t, version: n };
}
function cd(e, t, n, r) {
  const i = e.sdkProcessingMetadata && e.sdkProcessingMetadata.dynamicSamplingContext;
  return {
    event_id: e.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...t && { sdk: t },
    ...!!n && r && { dsn: Ut(r) },
    ...i && {
      trace: ie({ ...i })
    }
  };
}
function ud(e, t, n) {
  const r = [
    { type: "client_report" },
    {
      timestamp: Bt(),
      discarded_events: e
    }
  ];
  return St(t ? { dsn: t } : {}, [r]);
}
const dd = 60 * 1e3;
function ld(e, t = Date.now()) {
  const n = parseInt(`${e}`, 10);
  if (!isNaN(n))
    return n * 1e3;
  const r = Date.parse(`${e}`);
  return isNaN(r) ? dd : r - t;
}
function fd(e, t) {
  return e[t] || e.all || 0;
}
function pd(e, t, n = Date.now()) {
  return fd(e, t) > n;
}
function _d(e, { statusCode: t, headers: n }, r = Date.now()) {
  const i = {
    ...e
  }, o = n && n["x-sentry-rate-limits"], s = n && n["retry-after"];
  if (o)
    for (const a of o.trim().split(",")) {
      const [c, d, , , l] = a.split(":", 5), u = parseInt(c, 10), p = (isNaN(u) ? 60 : u) * 1e3;
      if (!d)
        i.all = r + p;
      else
        for (const f of d.split(";"))
          f === "metric_bucket" ? (!l || l.split(";").includes("custom")) && (i[f] = r + p) : i[f] = r + p;
    }
  else
    s ? i.all = r + ld(s, r) : t === 429 && (i.all = r + 60 * 1e3);
  return i;
}
function hd(e) {
  let t, n = e[0], r = 1;
  for (; r < e.length; ) {
    const i = e[r], o = e[r + 1];
    if (r += 2, (i === "optionalAccess" || i === "optionalCall") && n == null)
      return;
    i === "access" || i === "optionalAccess" ? (t = n, n = o(n)) : (i === "call" || i === "optionalCall") && (n = o((...s) => n.call(t, ...s)), t = void 0);
  }
  return n;
}
const Qt = F;
function gd() {
  const e = Qt.chrome, t = e && e.app && e.app.runtime, n = "history" in Qt && !!Qt.history.pushState && !!Qt.history.replaceState;
  return !t && n;
}
const O = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function tt() {
  return Mn(F), F;
}
function Mn(e) {
  return e.__SENTRY__ || (e.__SENTRY__ = {
    extensions: {}
  }), e.__SENTRY__;
}
function md(e) {
  const t = ce(), n = {
    sid: V(),
    init: !0,
    timestamp: t,
    started: t,
    duration: 0,
    status: "ok",
    errors: 0,
    ignoreDuration: !1,
    toJSON: () => vd(n)
  };
  return e && ft(n, e), n;
}
function ft(e, t = {}) {
  if (t.user && (!e.ipAddress && t.user.ip_address && (e.ipAddress = t.user.ip_address), !e.did && !t.did && (e.did = t.user.id || t.user.email || t.user.username)), e.timestamp = t.timestamp || ce(), t.abnormal_mechanism && (e.abnormal_mechanism = t.abnormal_mechanism), t.ignoreDuration && (e.ignoreDuration = t.ignoreDuration), t.sid && (e.sid = t.sid.length === 32 ? t.sid : V()), t.init !== void 0 && (e.init = t.init), !e.did && t.did && (e.did = `${t.did}`), typeof t.started == "number" && (e.started = t.started), e.ignoreDuration)
    e.duration = void 0;
  else if (typeof t.duration == "number")
    e.duration = t.duration;
  else {
    const n = e.timestamp - e.started;
    e.duration = n >= 0 ? n : 0;
  }
  t.release && (e.release = t.release), t.environment && (e.environment = t.environment), !e.ipAddress && t.ipAddress && (e.ipAddress = t.ipAddress), !e.userAgent && t.userAgent && (e.userAgent = t.userAgent), typeof t.errors == "number" && (e.errors = t.errors), t.status && (e.status = t.status);
}
function yd(e, t) {
  let n = {};
  e.status === "ok" && (n = { status: "exited" }), ft(e, n);
}
function vd(e) {
  return ie({
    sid: `${e.sid}`,
    init: e.init,
    // Make sure that sec is converted to ms for date constructor
    started: new Date(e.started * 1e3).toISOString(),
    timestamp: new Date(e.timestamp * 1e3).toISOString(),
    status: e.status,
    errors: e.errors,
    did: typeof e.did == "number" || typeof e.did == "string" ? `${e.did}` : void 0,
    duration: e.duration,
    abnormal_mechanism: e.abnormal_mechanism,
    attrs: {
      release: e.release,
      environment: e.environment,
      ip_address: e.ipAddress,
      user_agent: e.userAgent
    }
  });
}
const cr = "_sentrySpan";
function Ot(e, t) {
  t ? ve(e, cr, t) : delete e[cr];
}
function yn(e) {
  return e[cr];
}
const Sd = 100;
class Rr {
  /** Flag if notifying is happening. */
  /** Callback for client to receive scope changes. */
  /** Callback list that will be called during event processing. */
  /** Array of breadcrumbs. */
  /** User */
  /** Tags */
  /** Extra */
  /** Contexts */
  /** Attachments */
  /** Propagation Context for distributed tracing */
  /**
   * A place to stash data which is needed at some point in the SDK's event processing pipeline but which shouldn't get
   * sent to Sentry
   */
  /** Fingerprint */
  /** Severity */
  /**
   * Transaction Name
   *
   * IMPORTANT: The transaction name on the scope has nothing to do with root spans/transaction objects.
   * It's purpose is to assign a transaction to the scope that's added to non-transaction events.
   */
  /** Session */
  /** Request Mode Session Status */
  /** The client on this scope */
  /** Contains the last event id of a captured event.  */
  // NOTE: Any field which gets added here should get added not only to the constructor but also to the `clone` method.
  constructor() {
    this._notifyingListeners = !1, this._scopeListeners = [], this._eventProcessors = [], this._breadcrumbs = [], this._attachments = [], this._user = {}, this._tags = {}, this._extra = {}, this._contexts = {}, this._sdkProcessingMetadata = {}, this._propagationContext = ji();
  }
  /**
   * @inheritDoc
   */
  clone() {
    const t = new Rr();
    return t._breadcrumbs = [...this._breadcrumbs], t._tags = { ...this._tags }, t._extra = { ...this._extra }, t._contexts = { ...this._contexts }, t._user = this._user, t._level = this._level, t._session = this._session, t._transactionName = this._transactionName, t._fingerprint = this._fingerprint, t._eventProcessors = [...this._eventProcessors], t._requestSession = this._requestSession, t._attachments = [...this._attachments], t._sdkProcessingMetadata = { ...this._sdkProcessingMetadata }, t._propagationContext = { ...this._propagationContext }, t._client = this._client, t._lastEventId = this._lastEventId, Ot(t, yn(this)), t;
  }
  /**
   * @inheritDoc
   */
  setClient(t) {
    this._client = t;
  }
  /**
   * @inheritDoc
   */
  setLastEventId(t) {
    this._lastEventId = t;
  }
  /**
   * @inheritDoc
   */
  getClient() {
    return this._client;
  }
  /**
   * @inheritDoc
   */
  lastEventId() {
    return this._lastEventId;
  }
  /**
   * @inheritDoc
   */
  addScopeListener(t) {
    this._scopeListeners.push(t);
  }
  /**
   * @inheritDoc
   */
  addEventProcessor(t) {
    return this._eventProcessors.push(t), this;
  }
  /**
   * @inheritDoc
   */
  setUser(t) {
    return this._user = t || {
      email: void 0,
      id: void 0,
      ip_address: void 0,
      username: void 0
    }, this._session && ft(this._session, { user: t }), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getUser() {
    return this._user;
  }
  /**
   * @inheritDoc
   */
  getRequestSession() {
    return this._requestSession;
  }
  /**
   * @inheritDoc
   */
  setRequestSession(t) {
    return this._requestSession = t, this;
  }
  /**
   * @inheritDoc
   */
  setTags(t) {
    return this._tags = {
      ...this._tags,
      ...t
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTag(t, n) {
    return this._tags = { ...this._tags, [t]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtras(t) {
    return this._extra = {
      ...this._extra,
      ...t
    }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setExtra(t, n) {
    return this._extra = { ...this._extra, [t]: n }, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setFingerprint(t) {
    return this._fingerprint = t, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setLevel(t) {
    return this._level = t, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setTransactionName(t) {
    return this._transactionName = t, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setContext(t, n) {
    return n === null ? delete this._contexts[t] : this._contexts[t] = n, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  setSession(t) {
    return t ? this._session = t : delete this._session, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getSession() {
    return this._session;
  }
  /**
   * @inheritDoc
   */
  update(t) {
    if (!t)
      return this;
    const n = typeof t == "function" ? t(this) : t, [r, i] = n instanceof Xe ? [n.getScopeData(), n.getRequestSession()] : dt(n) ? [t, t.requestSession] : [], { tags: o, extra: s, user: a, contexts: c, level: d, fingerprint: l = [], propagationContext: u } = r || {};
    return this._tags = { ...this._tags, ...o }, this._extra = { ...this._extra, ...s }, this._contexts = { ...this._contexts, ...c }, a && Object.keys(a).length && (this._user = a), d && (this._level = d), l.length && (this._fingerprint = l), u && (this._propagationContext = u), i && (this._requestSession = i), this;
  }
  /**
   * @inheritDoc
   */
  clear() {
    return this._breadcrumbs = [], this._tags = {}, this._extra = {}, this._user = {}, this._contexts = {}, this._level = void 0, this._transactionName = void 0, this._fingerprint = void 0, this._requestSession = void 0, this._session = void 0, Ot(this, void 0), this._attachments = [], this._propagationContext = ji(), this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addBreadcrumb(t, n) {
    const r = typeof n == "number" ? n : Sd;
    if (r <= 0)
      return this;
    const i = {
      timestamp: Bt(),
      ...t
    }, o = this._breadcrumbs;
    return o.push(i), this._breadcrumbs = o.length > r ? o.slice(-r) : o, this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  getLastBreadcrumb() {
    return this._breadcrumbs[this._breadcrumbs.length - 1];
  }
  /**
   * @inheritDoc
   */
  clearBreadcrumbs() {
    return this._breadcrumbs = [], this._notifyScopeListeners(), this;
  }
  /**
   * @inheritDoc
   */
  addAttachment(t) {
    return this._attachments.push(t), this;
  }
  /**
   * @inheritDoc
   */
  clearAttachments() {
    return this._attachments = [], this;
  }
  /** @inheritDoc */
  getScopeData() {
    return {
      breadcrumbs: this._breadcrumbs,
      attachments: this._attachments,
      contexts: this._contexts,
      tags: this._tags,
      extra: this._extra,
      user: this._user,
      level: this._level,
      fingerprint: this._fingerprint || [],
      eventProcessors: this._eventProcessors,
      propagationContext: this._propagationContext,
      sdkProcessingMetadata: this._sdkProcessingMetadata,
      transactionName: this._transactionName,
      span: yn(this)
    };
  }
  /**
   * @inheritDoc
   */
  setSDKProcessingMetadata(t) {
    return this._sdkProcessingMetadata = { ...this._sdkProcessingMetadata, ...t }, this;
  }
  /**
   * @inheritDoc
   */
  setPropagationContext(t) {
    return this._propagationContext = t, this;
  }
  /**
   * @inheritDoc
   */
  getPropagationContext() {
    return this._propagationContext;
  }
  /**
   * @inheritDoc
   */
  captureException(t, n) {
    const r = n && n.event_id ? n.event_id : V();
    if (!this._client)
      return v.warn("No client configured on scope - will not capture exception!"), r;
    const i = new Error("Sentry syntheticException");
    return this._client.captureException(
      t,
      {
        originalException: t,
        syntheticException: i,
        ...n,
        event_id: r
      },
      this
    ), r;
  }
  /**
   * @inheritDoc
   */
  captureMessage(t, n, r) {
    const i = r && r.event_id ? r.event_id : V();
    if (!this._client)
      return v.warn("No client configured on scope - will not capture message!"), i;
    const o = new Error(t);
    return this._client.captureMessage(
      t,
      n,
      {
        originalException: t,
        syntheticException: o,
        ...r,
        event_id: i
      },
      this
    ), i;
  }
  /**
   * @inheritDoc
   */
  captureEvent(t, n) {
    const r = n && n.event_id ? n.event_id : V();
    return this._client ? (this._client.captureEvent(t, { ...n, event_id: r }, this), r) : (v.warn("No client configured on scope - will not capture event!"), r);
  }
  /**
   * This will be called on every set call.
   */
  _notifyScopeListeners() {
    this._notifyingListeners || (this._notifyingListeners = !0, this._scopeListeners.forEach((t) => {
      t(this);
    }), this._notifyingListeners = !1);
  }
}
const Xe = Rr;
function ji() {
  return {
    traceId: V(),
    spanId: V().substring(16)
  };
}
function bd() {
  return Nr("defaultCurrentScope", () => new Xe());
}
function Ed() {
  return Nr("defaultIsolationScope", () => new Xe());
}
class wd {
  constructor(t, n) {
    let r;
    t ? r = t : r = new Xe();
    let i;
    n ? i = n : i = new Xe(), this._stack = [{ scope: r }], this._isolationScope = i;
  }
  /**
   * Fork a scope for the stack.
   */
  withScope(t) {
    const n = this._pushScope();
    let r;
    try {
      r = t(n);
    } catch (i) {
      throw this._popScope(), i;
    }
    return In(r) ? r.then(
      (i) => (this._popScope(), i),
      (i) => {
        throw this._popScope(), i;
      }
    ) : (this._popScope(), r);
  }
  /**
   * Get the client of the stack.
   */
  getClient() {
    return this.getStackTop().client;
  }
  /**
   * Returns the scope of the top stack.
   */
  getScope() {
    return this.getStackTop().scope;
  }
  /**
   * Get the isolation scope for the stack.
   */
  getIsolationScope() {
    return this._isolationScope;
  }
  /**
   * Returns the scope stack for domains or the process.
   */
  getStack() {
    return this._stack;
  }
  /**
   * Returns the topmost scope layer in the order domain > local > process.
   */
  getStackTop() {
    return this._stack[this._stack.length - 1];
  }
  /**
   * Push a scope to the stack.
   */
  _pushScope() {
    const t = this.getScope().clone();
    return this.getStack().push({
      client: this.getClient(),
      scope: t
    }), t;
  }
  /**
   * Pop a scope from the stack.
   */
  _popScope() {
    return this.getStack().length <= 1 ? !1 : !!this.getStack().pop();
  }
}
function pt() {
  const e = tt(), t = Mn(e);
  return t.hub || (t.hub = new wd(bd(), Ed())), t.hub;
}
function Td(e) {
  return pt().withScope(e);
}
function Cd(e, t) {
  const n = pt();
  return n.withScope(() => (n.getStackTop().scope = e, t(e)));
}
function Vi(e) {
  return pt().withScope(() => e(pt().getIsolationScope()));
}
function kd() {
  return {
    withIsolationScope: Vi,
    withScope: Td,
    withSetScope: Cd,
    withSetIsolationScope: (e, t) => Vi(t),
    getCurrentScope: () => pt().getScope(),
    getIsolationScope: () => pt().getIsolationScope()
  };
}
function jt(e) {
  const t = Mn(e);
  return t.acs ? t.acs : kd();
}
function W() {
  const e = tt();
  return jt(e).getCurrentScope();
}
function xe() {
  const e = tt();
  return jt(e).getIsolationScope();
}
function Cs() {
  return Nr("globalScope", () => new Xe());
}
function Lr(...e) {
  const t = tt(), n = jt(t);
  if (e.length === 2) {
    const [r, i] = e;
    return r ? n.withSetScope(r, i) : n.withScope(i);
  }
  return n.withScope(e[0]);
}
function U() {
  return W().getClient();
}
const Pe = "sentry.source", ks = "sentry.sample_rate", Pt = "sentry.op", oe = "sentry.origin", ur = "sentry.idle_span_finish_reason", Or = "sentry.measurement_unit", Pr = "sentry.measurement_value", Id = "sentry.profile_id", Is = "sentry.exclusive_time", Md = 0, Ms = 1, ee = 2;
function Nd(e) {
  if (e < 400 && e >= 100)
    return { code: Ms };
  if (e >= 400 && e < 500)
    switch (e) {
      case 401:
        return { code: ee, message: "unauthenticated" };
      case 403:
        return { code: ee, message: "permission_denied" };
      case 404:
        return { code: ee, message: "not_found" };
      case 409:
        return { code: ee, message: "already_exists" };
      case 413:
        return { code: ee, message: "failed_precondition" };
      case 429:
        return { code: ee, message: "resource_exhausted" };
      case 499:
        return { code: ee, message: "cancelled" };
      default:
        return { code: ee, message: "invalid_argument" };
    }
  if (e >= 500 && e < 600)
    switch (e) {
      case 501:
        return { code: ee, message: "unimplemented" };
      case 503:
        return { code: ee, message: "unavailable" };
      case 504:
        return { code: ee, message: "deadline_exceeded" };
      default:
        return { code: ee, message: "internal_error" };
    }
  return { code: ee, message: "unknown_error" };
}
function Ns(e, t) {
  e.setAttribute("http.response.status_code", t);
  const n = Nd(t);
  n.message !== "unknown_error" && e.setStatus(n);
}
const As = 0, xs = 1;
function Ad(e) {
  const { spanId: t, traceId: n } = e.spanContext(), { data: r, op: i, parent_span_id: o, status: s, origin: a } = H(e);
  return ie({
    parent_span_id: o,
    span_id: t,
    trace_id: n,
    data: r,
    op: i,
    status: s,
    origin: a
  });
}
function xd(e) {
  const { spanId: t, traceId: n } = e.spanContext(), { parent_span_id: r } = H(e);
  return ie({ parent_span_id: r, span_id: t, trace_id: n });
}
function Rs(e) {
  const { traceId: t, spanId: n } = e.spanContext(), r = nt(e);
  return xr(t, n, r);
}
function ze(e) {
  return typeof e == "number" ? qi(e) : Array.isArray(e) ? e[0] + e[1] / 1e9 : e instanceof Date ? qi(e.getTime()) : ce();
}
function qi(e) {
  return e > 9999999999 ? e / 1e3 : e;
}
function H(e) {
  if (Ld(e))
    return e.getSpanJSON();
  try {
    const { spanId: t, traceId: n } = e.spanContext();
    if (Rd(e)) {
      const { attributes: r, startTime: i, name: o, endTime: s, parentSpanId: a, status: c } = e;
      return ie({
        span_id: t,
        trace_id: n,
        data: r,
        description: o,
        parent_span_id: a,
        start_timestamp: ze(i),
        // This is [0,0] by default in OTEL, in which case we want to interpret this as no end time
        timestamp: ze(s) || void 0,
        status: Ls(c),
        op: r[Pt],
        origin: r[oe],
        _metrics_summary: void 0
      });
    }
    return {
      span_id: t,
      trace_id: n
    };
  } catch {
    return {};
  }
}
function Rd(e) {
  const t = e;
  return !!t.attributes && !!t.startTime && !!t.name && !!t.endTime && !!t.status;
}
function Ld(e) {
  return typeof e.getSpanJSON == "function";
}
function nt(e) {
  const { traceFlags: t } = e.spanContext();
  return t === xs;
}
function Ls(e) {
  if (!(!e || e.code === Md))
    return e.code === Ms ? "ok" : e.message || "unknown_error";
}
const $e = "_sentryChildSpans", dr = "_sentryRootSpan";
function Os(e, t) {
  const n = e[dr] || e;
  ve(t, dr, n), e[$e] && e[$e].size < 1e3 ? e[$e].add(t) : ve(e, $e, /* @__PURE__ */ new Set([t]));
}
function Od(e, t) {
  e[$e] && e[$e].delete(t);
}
function un(e) {
  const t = /* @__PURE__ */ new Set();
  function n(r) {
    if (!t.has(r) && nt(r)) {
      t.add(r);
      const i = r[$e] ? Array.from(r[$e]) : [];
      for (const o of i)
        n(o);
    }
  }
  return n(e), Array.from(t);
}
function ue(e) {
  return e[dr] || e;
}
function ge() {
  const e = tt(), t = jt(e);
  return t.getActiveSpan ? t.getActiveSpan() : yn(W());
}
let Gi = !1;
function Pd() {
  Gi || (Gi = !0, ms(lr), ys(lr));
}
function lr() {
  const e = ge(), t = e && ue(e);
  if (t) {
    const n = "internal_error";
    O && v.log(`[Tracing] Root span: ${n} -> Global error occured`), t.setStatus({ code: ee, message: n });
  }
}
lr.tag = "sentry_tracingErrorCallback";
const Ps = "_sentryScope", $s = "_sentryIsolationScope";
function $d(e, t, n) {
  e && (ve(e, $s, n), ve(e, Ps, t));
}
function Wi(e) {
  return {
    scope: e[Ps],
    isolationScope: e[$s]
  };
}
function Ue(e) {
  if (typeof __SENTRY_TRACING__ == "boolean" && !__SENTRY_TRACING__)
    return !1;
  const t = e || Dd();
  return !!t && (t.enableTracing || "tracesSampleRate" in t || "tracesSampler" in t);
}
function Dd() {
  const e = U();
  return e && e.getOptions();
}
class bt {
  constructor(t = {}) {
    this._traceId = t.traceId || V(), this._spanId = t.spanId || V().substring(16);
  }
  /** @inheritdoc */
  spanContext() {
    return {
      spanId: this._spanId,
      traceId: this._traceId,
      traceFlags: As
    };
  }
  /** @inheritdoc */
  // eslint-disable-next-line @typescript-eslint/no-empty-function
  end(t) {
  }
  /** @inheritdoc */
  setAttribute(t, n) {
    return this;
  }
  /** @inheritdoc */
  setAttributes(t) {
    return this;
  }
  /** @inheritdoc */
  setStatus(t) {
    return this;
  }
  /** @inheritdoc */
  updateName(t) {
    return this;
  }
  /** @inheritdoc */
  isRecording() {
    return !1;
  }
  /** @inheritdoc */
  addEvent(t, n, r) {
    return this;
  }
}
const $r = "production", Ds = "_frozenDsc";
function zi(e, t) {
  ve(e, Ds, t);
}
function Nn(e, t) {
  const n = t.getOptions(), { publicKey: r } = t.getDsn() || {}, i = ie({
    environment: n.environment || $r,
    release: n.release,
    public_key: r,
    trace_id: e
  });
  return t.emit("createDsc", i), i;
}
function rt(e) {
  const t = U();
  if (!t)
    return {};
  const n = Nn(H(e).trace_id || "", t), r = ue(e);
  if (!r)
    return n;
  const i = r[Ds];
  if (i)
    return i;
  const o = H(r), s = o.data || {}, a = s[ks];
  a != null && (n.sample_rate = `${a}`);
  const c = s[Pe];
  return c && c !== "url" && (n.transaction = o.description), n.sampled = String(nt(r)), t.emit("createDsc", n), n;
}
function Fd(e) {
  if (!O)
    return;
  const { description: t = "< unknown name >", op: n = "< unknown op >", parent_span_id: r } = H(e), { spanId: i } = e.spanContext(), o = nt(e), s = ue(e), a = s === e, c = `[Tracing] Starting ${o ? "sampled" : "unsampled"} ${a ? "root " : ""}span`, d = [`op: ${n}`, `name: ${t}`, `ID: ${i}`];
  if (r && d.push(`parent ID: ${r}`), !a) {
    const { op: l, description: u } = H(s);
    d.push(`root ID: ${s.spanContext().spanId}`), l && d.push(`root op: ${l}`), u && d.push(`root description: ${u}`);
  }
  v.log(`${c}
  ${d.join(`
  `)}`);
}
function Hd(e) {
  if (!O)
    return;
  const { description: t = "< unknown name >", op: n = "< unknown op >" } = H(e), { spanId: r } = e.spanContext(), o = ue(e) === e, s = `[Tracing] Finishing "${n}" ${o ? "root " : ""}span "${t}" with ID ${r}`;
  v.log(s);
}
function Fs(e) {
  if (typeof e == "boolean")
    return Number(e);
  const t = typeof e == "string" ? parseFloat(e) : e;
  if (typeof t != "number" || isNaN(t) || t < 0 || t > 1) {
    O && v.warn(
      `[Tracing] Given sample rate is invalid. Sample rate must be a boolean or a number between 0 and 1. Got ${JSON.stringify(
        e
      )} of type ${JSON.stringify(typeof e)}.`
    );
    return;
  }
  return t;
}
function Ud(e, t) {
  if (!Ue(e))
    return [!1];
  let n;
  typeof e.tracesSampler == "function" ? n = e.tracesSampler(t) : t.parentSampled !== void 0 ? n = t.parentSampled : typeof e.tracesSampleRate < "u" ? n = e.tracesSampleRate : n = 1;
  const r = Fs(n);
  return r === void 0 ? (O && v.warn("[Tracing] Discarding transaction because of invalid sample rate."), [!1]) : r ? Math.random() < r ? [!0, r] : (O && v.log(
    `[Tracing] Discarding transaction because it's not included in the random sample (sampling rate = ${Number(
      n
    )})`
  ), [!1, r]) : (O && v.log(
    `[Tracing] Discarding transaction because ${typeof e.tracesSampler == "function" ? "tracesSampler returned 0 or false" : "a negative sampling decision was inherited or tracesSampleRate is set to 0"}`
  ), [!1, r]);
}
function Bd(e, t) {
  return t && (e.sdk = e.sdk || {}, e.sdk.name = e.sdk.name || t.name, e.sdk.version = e.sdk.version || t.version, e.sdk.integrations = [...e.sdk.integrations || [], ...t.integrations || []], e.sdk.packages = [...e.sdk.packages || [], ...t.packages || []]), e;
}
function jd(e, t, n, r) {
  const i = Ts(n), o = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...i && { sdk: i },
    ...!!r && t && { dsn: Ut(t) }
  }, s = "aggregates" in e ? [{ type: "sessions" }, e] : [{ type: "session" }, e.toJSON()];
  return St(o, [s]);
}
function Vd(e, t, n, r) {
  const i = Ts(n), o = e.type && e.type !== "replay_event" ? e.type : "event";
  Bd(e, n && n.sdk);
  const s = cd(e, i, r, t);
  return delete e.sdkProcessingMetadata, St(s, [[{ type: o }, e]]);
}
function qd(e, t) {
  function n(l) {
    return !!l.trace_id && !!l.public_key;
  }
  const r = rt(e[0]), i = t && t.getDsn(), o = t && t.getOptions().tunnel, s = {
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...n(r) && { trace: r },
    ...!!o && i && { dsn: Ut(i) }
  }, a = t && t.getOptions().beforeSendSpan, c = a ? (l) => a(H(l)) : (l) => H(l), d = [];
  for (const l of e) {
    const u = c(l);
    u && d.push(od(u));
  }
  return St(s, d);
}
function Gd(e, t, n) {
  const r = ge(), i = r && ue(r);
  i && i.addEvent(e, {
    [Pr]: t,
    [Or]: n
  });
}
function Zi(e) {
  if (!e || e.length === 0)
    return;
  const t = {};
  return e.forEach((n) => {
    const r = n.attributes || {}, i = r[Or], o = r[Pr];
    typeof i == "string" && typeof o == "number" && (t[n.name] = { value: o, unit: i });
  }), t;
}
class Dr {
  /** Epoch timestamp in seconds when the span started. */
  /** Epoch timestamp in seconds when the span ended. */
  /** Internal keeper of the status */
  /** The timed events added to this span. */
  /** if true, treat span as a standalone span (not part of a transaction) */
  /**
   * You should never call the constructor manually, always use `Sentry.startSpan()`
   * or other span methods.
   * @internal
   * @hideconstructor
   * @hidden
   */
  constructor(t = {}) {
    this._traceId = t.traceId || V(), this._spanId = t.spanId || V().substring(16), this._startTime = t.startTimestamp || ce(), this._attributes = {}, this.setAttributes({
      [oe]: "manual",
      [Pt]: t.op,
      ...t.attributes
    }), this._name = t.name, t.parentSpanId && (this._parentSpanId = t.parentSpanId), "sampled" in t && (this._sampled = t.sampled), t.endTimestamp && (this._endTime = t.endTimestamp), this._events = [], this._isStandaloneSpan = t.isStandalone, this._endTime && this._onSpanEnded();
  }
  /** @inheritdoc */
  spanContext() {
    const { _spanId: t, _traceId: n, _sampled: r } = this;
    return {
      spanId: t,
      traceId: n,
      traceFlags: r ? xs : As
    };
  }
  /** @inheritdoc */
  setAttribute(t, n) {
    n === void 0 ? delete this._attributes[t] : this._attributes[t] = n;
  }
  /** @inheritdoc */
  setAttributes(t) {
    Object.keys(t).forEach((n) => this.setAttribute(n, t[n]));
  }
  /**
   * This should generally not be used,
   * but we need it for browser tracing where we want to adjust the start time afterwards.
   * USE THIS WITH CAUTION!
   *
   * @hidden
   * @internal
   */
  updateStartTime(t) {
    this._startTime = ze(t);
  }
  /**
   * @inheritDoc
   */
  setStatus(t) {
    return this._status = t, this;
  }
  /**
   * @inheritDoc
   */
  updateName(t) {
    return this._name = t, this;
  }
  /** @inheritdoc */
  end(t) {
    this._endTime || (this._endTime = ze(t), Hd(this), this._onSpanEnded());
  }
  /**
   * Get JSON representation of this span.
   *
   * @hidden
   * @internal This method is purely for internal purposes and should not be used outside
   * of SDK code. If you need to get a JSON representation of a span,
   * use `spanToJSON(span)` instead.
   */
  getSpanJSON() {
    return ie({
      data: this._attributes,
      description: this._name,
      op: this._attributes[Pt],
      parent_span_id: this._parentSpanId,
      span_id: this._spanId,
      start_timestamp: this._startTime,
      status: Ls(this._status),
      timestamp: this._endTime,
      trace_id: this._traceId,
      origin: this._attributes[oe],
      _metrics_summary: void 0,
      profile_id: this._attributes[Id],
      exclusive_time: this._attributes[Is],
      measurements: Zi(this._events),
      is_segment: this._isStandaloneSpan && ue(this) === this || void 0,
      segment_id: this._isStandaloneSpan ? ue(this).spanContext().spanId : void 0
    });
  }
  /** @inheritdoc */
  isRecording() {
    return !this._endTime && !!this._sampled;
  }
  /**
   * @inheritdoc
   */
  addEvent(t, n, r) {
    O && v.log("[Tracing] Adding an event to span:", t);
    const i = Yi(n) ? n : r || ce(), o = Yi(n) ? {} : n || {}, s = {
      name: t,
      time: ze(i),
      attributes: o
    };
    return this._events.push(s), this;
  }
  /**
   * This method should generally not be used,
   * but for now we need a way to publicly check if the `_isStandaloneSpan` flag is set.
   * USE THIS WITH CAUTION!
   * @internal
   * @hidden
   * @experimental
   */
  isStandaloneSpan() {
    return !!this._isStandaloneSpan;
  }
  /** Emit `spanEnd` when the span is ended. */
  _onSpanEnded() {
    const t = U();
    if (t && t.emit("spanEnd", this), !(this._isStandaloneSpan || this === ue(this)))
      return;
    if (this._isStandaloneSpan) {
      zd(qd([this], t));
      return;
    }
    const r = this._convertSpanToTransaction();
    r && (Wi(this).scope || W()).captureEvent(r);
  }
  /**
   * Finish the transaction & prepare the event to send to Sentry.
   */
  _convertSpanToTransaction() {
    if (!Ki(H(this)))
      return;
    this._name || (O && v.warn("Transaction has no name, falling back to `<unlabeled transaction>`."), this._name = "<unlabeled transaction>");
    const { scope: t, isolationScope: n } = Wi(this), i = (t || W()).getClient() || U();
    if (this._sampled !== !0) {
      O && v.log("[Tracing] Discarding transaction because its trace was not chosen to be sampled."), i && i.recordDroppedEvent("sample_rate", "transaction");
      return;
    }
    const s = un(this).filter((u) => u !== this && !Wd(u)).map((u) => H(u)).filter(Ki), a = this._attributes[Pe], c = {
      contexts: {
        trace: Ad(this)
      },
      spans: s,
      start_timestamp: this._startTime,
      timestamp: this._endTime,
      transaction: this._name,
      type: "transaction",
      sdkProcessingMetadata: {
        capturedSpanScope: t,
        capturedSpanIsolationScope: n,
        ...ie({
          dynamicSamplingContext: rt(this)
        })
      },
      _metrics_summary: void 0,
      ...a && {
        transaction_info: {
          source: a
        }
      }
    }, d = Zi(this._events);
    return d && Object.keys(d).length && (O && v.log("[Measurements] Adding measurements to transaction", JSON.stringify(d, void 0, 2)), c.measurements = d), c;
  }
}
function Yi(e) {
  return e && typeof e == "number" || e instanceof Date || Array.isArray(e);
}
function Ki(e) {
  return !!e.start_timestamp && !!e.timestamp && !!e.span_id && !!e.trace_id;
}
function Wd(e) {
  return e instanceof Dr && e.isStandaloneSpan();
}
function zd(e) {
  const t = U();
  if (!t)
    return;
  const n = e[1];
  if (!n || n.length === 0) {
    t.recordDroppedEvent("before_send", "span");
    return;
  }
  const r = t.getTransport();
  r && r.send(e).then(null, (i) => {
    O && v.error("Error while sending span:", i);
  });
}
const Hs = "__SENTRY_SUPPRESS_TRACING__";
function it(e) {
  const t = Us();
  if (t.startInactiveSpan)
    return t.startInactiveSpan(e);
  const n = Kd(e), r = e.scope || W(), i = Jd(r);
  return e.onlyIfParent && !i ? new bt() : Yd({
    parentSpan: i,
    spanContext: n,
    forceTransaction: e.forceTransaction,
    scope: r
  });
}
function Zd(e, t) {
  const n = Us();
  return n.withActiveSpan ? n.withActiveSpan(e, t) : Lr((r) => (Ot(r, e || void 0), t(r)));
}
function Yd({
  parentSpan: e,
  spanContext: t,
  forceTransaction: n,
  scope: r
}) {
  if (!Ue())
    return new bt();
  const i = xe();
  let o;
  if (e && !n)
    o = Xd(e, r, t), Os(e, o);
  else if (e) {
    const s = rt(e), { traceId: a, spanId: c } = e.spanContext(), d = nt(e);
    o = Xi(
      {
        traceId: a,
        parentSpanId: c,
        ...t
      },
      r,
      d
    ), zi(o, s);
  } else {
    const {
      traceId: s,
      dsc: a,
      parentSpanId: c,
      sampled: d
    } = {
      ...i.getPropagationContext(),
      ...r.getPropagationContext()
    };
    o = Xi(
      {
        traceId: s,
        parentSpanId: c,
        ...t
      },
      r,
      d
    ), a && zi(o, a);
  }
  return Fd(o), $d(o, r, i), o;
}
function Kd(e) {
  const n = {
    isStandalone: (e.experimental || {}).standalone,
    ...e
  };
  if (e.startTime) {
    const r = { ...n };
    return r.startTimestamp = ze(e.startTime), delete r.startTime, r;
  }
  return n;
}
function Us() {
  const e = tt();
  return jt(e);
}
function Xi(e, t, n) {
  const r = U(), i = r && r.getOptions() || {}, { name: o = "", attributes: s } = e, [a, c] = t.getScopeData().sdkProcessingMetadata[Hs] ? [!1] : Ud(i, {
    name: o,
    parentSampled: n,
    attributes: s,
    transactionContext: {
      name: o,
      parentSampled: n
    }
  }), d = new Dr({
    ...e,
    attributes: {
      [Pe]: "custom",
      ...e.attributes
    },
    sampled: a
  });
  return c !== void 0 && d.setAttribute(ks, c), r && r.emit("spanStart", d), d;
}
function Xd(e, t, n) {
  const { spanId: r, traceId: i } = e.spanContext(), o = t.getScopeData().sdkProcessingMetadata[Hs] ? !1 : nt(e), s = o ? new Dr({
    ...n,
    parentSpanId: r,
    traceId: i,
    sampled: o
  }) : new bt({ traceId: i });
  Os(e, s);
  const a = U();
  return a && (a.emit("spanStart", s), n.endTimestamp && a.emit("spanEnd", s)), s;
}
function Jd(e) {
  const t = yn(e);
  if (!t)
    return;
  const n = U();
  return (n ? n.getOptions() : {}).parentSpanIsAlwaysRootSpan ? ue(t) : t;
}
const dn = {
  idleTimeout: 1e3,
  finalTimeout: 3e4,
  childSpanTimeout: 15e3
}, Qd = "heartbeatFailed", el = "idleTimeout", tl = "finalTimeout", nl = "externalFinish";
function Bs(e, t = {}) {
  const n = /* @__PURE__ */ new Map();
  let r = !1, i, o = nl, s = !t.disableAutoFinish;
  const {
    idleTimeout: a = dn.idleTimeout,
    finalTimeout: c = dn.finalTimeout,
    childSpanTimeout: d = dn.childSpanTimeout,
    beforeSpanEnd: l
  } = t, u = U();
  if (!u || !Ue())
    return new bt();
  const p = W(), f = ge(), _ = rl(e);
  function S(m = ce()) {
    const k = un(_).filter((q) => q !== _);
    if (!k.length) {
      _.end(m);
      return;
    }
    const N = k.map((q) => H(q).timestamp).filter((q) => !!q), R = N.length ? Math.max(...N) : void 0, D = ze(m), z = H(_).start_timestamp, Z = Math.min(
      z ? z + c / 1e3 : 1 / 0,
      Math.max(z || -1 / 0, Math.min(D, R || 1 / 0))
    );
    _.end(Z);
  }
  function b() {
    i && (clearTimeout(i), i = void 0);
  }
  function E(m) {
    b(), i = setTimeout(() => {
      !r && n.size === 0 && s && (o = el, S(m));
    }, a);
  }
  function h(m) {
    i = setTimeout(() => {
      !r && s && (o = Qd, S(m));
    }, d);
  }
  function y(m) {
    b(), n.set(m, !0);
    const k = ce();
    h(k + d / 1e3);
  }
  function T(m) {
    if (n.has(m) && n.delete(m), n.size === 0) {
      const k = ce();
      E(k + a / 1e3);
    }
  }
  function w() {
    r = !0, n.clear(), l && l(_), Ot(p, f);
    const m = H(_), { timestamp: k, start_timestamp: N } = m;
    if (!k || !N)
      return;
    (m.data || {})[ur] || _.setAttribute(ur, o), v.log(`[Tracing] Idle span "${m.op}" finished`);
    const D = un(_).filter((Z) => Z !== _);
    let z = 0;
    D.forEach((Z) => {
      Z.isRecording() && (Z.setStatus({ code: ee, message: "cancelled" }), Z.end(k), O && v.log("[Tracing] Cancelling span since span ended early", JSON.stringify(Z, void 0, 2)));
      const q = H(Z), { timestamp: M = 0, start_timestamp: G = 0 } = q, j = G <= k, re = (c + a) / 1e3, te = M - G < re;
      if (O) {
        const Gt = JSON.stringify(Z, void 0, 2);
        j ? te || v.log("[Tracing] Discarding span since it finished after idle span final timeout", Gt) : v.log("[Tracing] Discarding span since it happened after idle span was finished", Gt);
      }
      (!te || !j) && (Od(_, Z), z++);
    }), z > 0 && _.setAttribute("sentry.idle_span_discarded_spans", z);
  }
  return u.on("spanStart", (m) => {
    if (r || m === _ || H(m).timestamp)
      return;
    un(_).includes(m) && y(m.spanContext().spanId);
  }), u.on("spanEnd", (m) => {
    r || (T(m.spanContext().spanId), m === _ && w());
  }), u.on("idleSpanEnableAutoFinish", (m) => {
    m === _ && (s = !0, E(), n.size && h());
  }), t.disableAutoFinish || E(), setTimeout(() => {
    r || (_.setStatus({ code: ee, message: "deadline_exceeded" }), o = tl, S());
  }, c), _;
}
function rl(e) {
  const t = it(e);
  return Ot(W(), t), O && v.log("[Tracing] Started span is an idle span"), t;
}
function fr(e, t, n, r = 0) {
  return new _e((i, o) => {
    const s = e[r];
    if (t === null || typeof s != "function")
      i(t);
    else {
      const a = s({ ...t }, n);
      O && s.id && a === null && v.log(`Event processor "${s.id}" dropped event`), In(a) ? a.then((c) => fr(e, c, n, r + 1).then(i)).then(null, o) : fr(e, a, n, r + 1).then(i).then(null, o);
    }
  });
}
function il(e, t) {
  const { fingerprint: n, span: r, breadcrumbs: i, sdkProcessingMetadata: o } = t;
  ol(e, t), r && cl(e, r), ul(e, n), sl(e, i), al(e, o);
}
function Ji(e, t) {
  const {
    extra: n,
    tags: r,
    user: i,
    contexts: o,
    level: s,
    sdkProcessingMetadata: a,
    breadcrumbs: c,
    fingerprint: d,
    eventProcessors: l,
    attachments: u,
    propagationContext: p,
    transactionName: f,
    span: _
  } = t;
  Ct(e, "extra", n), Ct(e, "tags", r), Ct(e, "user", i), Ct(e, "contexts", o), Ct(e, "sdkProcessingMetadata", a), s && (e.level = s), f && (e.transactionName = f), _ && (e.span = _), c.length && (e.breadcrumbs = [...e.breadcrumbs, ...c]), d.length && (e.fingerprint = [...e.fingerprint, ...d]), l.length && (e.eventProcessors = [...e.eventProcessors, ...l]), u.length && (e.attachments = [...e.attachments, ...u]), e.propagationContext = { ...e.propagationContext, ...p };
}
function Ct(e, t, n) {
  if (n && Object.keys(n).length) {
    e[t] = { ...e[t] };
    for (const r in n)
      Object.prototype.hasOwnProperty.call(n, r) && (e[t][r] = n[r]);
  }
}
function ol(e, t) {
  const { extra: n, tags: r, user: i, contexts: o, level: s, transactionName: a } = t, c = ie(n);
  c && Object.keys(c).length && (e.extra = { ...c, ...e.extra });
  const d = ie(r);
  d && Object.keys(d).length && (e.tags = { ...d, ...e.tags });
  const l = ie(i);
  l && Object.keys(l).length && (e.user = { ...l, ...e.user });
  const u = ie(o);
  u && Object.keys(u).length && (e.contexts = { ...u, ...e.contexts }), s && (e.level = s), a && e.type !== "transaction" && (e.transaction = a);
}
function sl(e, t) {
  const n = [...e.breadcrumbs || [], ...t];
  e.breadcrumbs = n.length ? n : void 0;
}
function al(e, t) {
  e.sdkProcessingMetadata = {
    ...e.sdkProcessingMetadata,
    ...t
  };
}
function cl(e, t) {
  e.contexts = {
    trace: xd(t),
    ...e.contexts
  }, e.sdkProcessingMetadata = {
    dynamicSamplingContext: rt(t),
    ...e.sdkProcessingMetadata
  };
  const n = ue(t), r = H(n).description;
  r && !e.transaction && e.type === "transaction" && (e.transaction = r);
}
function ul(e, t) {
  e.fingerprint = e.fingerprint ? Ss(e.fingerprint) : [], t && (e.fingerprint = e.fingerprint.concat(t)), e.fingerprint && !e.fingerprint.length && delete e.fingerprint;
}
function dl(e, t, n, r, i, o) {
  const { normalizeDepth: s = 3, normalizeMaxBreadth: a = 1e3 } = e, c = {
    ...t,
    event_id: t.event_id || n.event_id || V(),
    timestamp: t.timestamp || Bt()
  }, d = n.integrations || e.integrations.map((b) => b.name);
  ll(c, e), _l(c, d), t.type === void 0 && fl(c, e.stackParser);
  const l = gl(r, n.captureContext);
  n.mechanism && Lt(c, n.mechanism);
  const u = i ? i.getEventProcessors() : [], p = Cs().getScopeData();
  if (o) {
    const b = o.getScopeData();
    Ji(p, b);
  }
  if (l) {
    const b = l.getScopeData();
    Ji(p, b);
  }
  const f = [...n.attachments || [], ...p.attachments];
  f.length && (n.attachments = f), il(c, p);
  const _ = [
    ...u,
    // Run scope event processors _after_ all other processors
    ...p.eventProcessors
  ];
  return fr(_, c, n).then((b) => (b && pl(b), typeof s == "number" && s > 0 ? hl(b, s, a) : b));
}
function ll(e, t) {
  const { environment: n, release: r, dist: i, maxValueLength: o = 250 } = t;
  "environment" in e || (e.environment = "environment" in t ? n : $r), e.release === void 0 && r !== void 0 && (e.release = r), e.dist === void 0 && i !== void 0 && (e.dist = i), e.message && (e.message = ct(e.message, o));
  const s = e.exception && e.exception.values && e.exception.values[0];
  s && s.value && (s.value = ct(s.value, o));
  const a = e.request;
  a && a.url && (a.url = ct(a.url, o));
}
const Qi = /* @__PURE__ */ new WeakMap();
function fl(e, t) {
  const n = F._sentryDebugIds;
  if (!n)
    return;
  let r;
  const i = Qi.get(t);
  i ? r = i : (r = /* @__PURE__ */ new Map(), Qi.set(t, r));
  const o = Object.keys(n).reduce((s, a) => {
    let c;
    const d = r.get(a);
    d ? c = d : (c = t(a), r.set(a, c));
    for (let l = c.length - 1; l >= 0; l--) {
      const u = c[l];
      if (u.filename) {
        s[u.filename] = n[a];
        break;
      }
    }
    return s;
  }, {});
  try {
    e.exception.values.forEach((s) => {
      s.stacktrace.frames.forEach((a) => {
        a.filename && (a.debug_id = o[a.filename]);
      });
    });
  } catch {
  }
}
function pl(e) {
  const t = {};
  try {
    e.exception.values.forEach((r) => {
      r.stacktrace.frames.forEach((i) => {
        i.debug_id && (i.abs_path ? t[i.abs_path] = i.debug_id : i.filename && (t[i.filename] = i.debug_id), delete i.debug_id);
      });
    });
  } catch {
  }
  if (Object.keys(t).length === 0)
    return;
  e.debug_meta = e.debug_meta || {}, e.debug_meta.images = e.debug_meta.images || [];
  const n = e.debug_meta.images;
  Object.keys(t).forEach((r) => {
    n.push({
      type: "sourcemap",
      code_file: r,
      debug_id: t[r]
    });
  });
}
function _l(e, t) {
  t.length > 0 && (e.sdk = e.sdk || {}, e.sdk.integrations = [...e.sdk.integrations || [], ...t]);
}
function hl(e, t, n) {
  if (!e)
    return null;
  const r = {
    ...e,
    ...e.breadcrumbs && {
      breadcrumbs: e.breadcrumbs.map((i) => ({
        ...i,
        ...i.data && {
          data: Le(i.data, t, n)
        }
      }))
    },
    ...e.user && {
      user: Le(e.user, t, n)
    },
    ...e.contexts && {
      contexts: Le(e.contexts, t, n)
    },
    ...e.extra && {
      extra: Le(e.extra, t, n)
    }
  };
  return e.contexts && e.contexts.trace && r.contexts && (r.contexts.trace = e.contexts.trace, e.contexts.trace.data && (r.contexts.trace.data = Le(e.contexts.trace.data, t, n))), e.spans && (r.spans = e.spans.map((i) => ({
    ...i,
    ...i.data && {
      data: Le(i.data, t, n)
    }
  }))), r;
}
function gl(e, t) {
  if (!t)
    return e;
  const n = e ? e.clone() : new Xe();
  return n.update(t), n;
}
function ml(e, t) {
  return W().captureException(e, void 0);
}
function yl(e, t) {
  const r = { captureContext: t };
  return W().captureMessage(e, void 0, r);
}
function js(e, t) {
  return W().captureEvent(e, t);
}
function eo(e) {
  const t = U(), n = xe(), r = W(), { release: i, environment: o = $r } = t && t.getOptions() || {}, { userAgent: s } = F.navigator || {}, a = md({
    release: i,
    environment: o,
    user: r.getUser() || n.getUser(),
    ...s && { userAgent: s },
    ...e
  }), c = n.getSession();
  return c && c.status === "ok" && ft(c, { status: "exited" }), Vs(), n.setSession(a), r.setSession(a), a;
}
function Vs() {
  const e = xe(), t = W(), n = t.getSession() || e.getSession();
  n && yd(n), qs(), e.setSession(), t.setSession();
}
function qs() {
  const e = xe(), t = W(), n = U(), r = t.getSession() || e.getSession();
  r && n && n.captureSession(r);
}
function to(e = !1) {
  if (e) {
    Vs();
    return;
  }
  qs();
}
const vl = "7";
function Sl(e) {
  const t = e.protocol ? `${e.protocol}:` : "", n = e.port ? `:${e.port}` : "";
  return `${t}//${e.host}${n}${e.path ? `/${e.path}` : ""}/api/`;
}
function bl(e) {
  return `${Sl(e)}${e.projectId}/envelope/`;
}
function El(e, t) {
  return ku({
    // We send only the minimum set of required information. See
    // https://github.com/getsentry/sentry-javascript/issues/2572.
    sentry_key: e.publicKey,
    sentry_version: vl,
    ...t && { sentry_client: `${t.name}/${t.version}` }
  });
}
function wl(e, t, n) {
  return t || `${bl(e)}?${El(e, n)}`;
}
const no = [];
function Tl(e) {
  const t = {};
  return e.forEach((n) => {
    const { name: r } = n, i = t[r];
    i && !i.isDefaultInstance && n.isDefaultInstance || (t[r] = n);
  }), Object.keys(t).map((n) => t[n]);
}
function Cl(e) {
  const t = e.defaultIntegrations || [], n = e.integrations;
  t.forEach((s) => {
    s.isDefaultInstance = !0;
  });
  let r;
  Array.isArray(n) ? r = [...t, ...n] : typeof n == "function" ? r = Ss(n(t)) : r = t;
  const i = Tl(r), o = Il(i, (s) => s.name === "Debug");
  if (o !== -1) {
    const [s] = i.splice(o, 1);
    i.push(s);
  }
  return i;
}
function kl(e, t) {
  const n = {};
  return t.forEach((r) => {
    r && Gs(e, r, n);
  }), n;
}
function ro(e, t) {
  for (const n of t)
    n && n.afterAllSetup && n.afterAllSetup(e);
}
function Gs(e, t, n) {
  if (n[t.name]) {
    O && v.log(`Integration skipped because it was already installed: ${t.name}`);
    return;
  }
  if (n[t.name] = t, no.indexOf(t.name) === -1 && typeof t.setupOnce == "function" && (t.setupOnce(), no.push(t.name)), t.setup && typeof t.setup == "function" && t.setup(e), typeof t.preprocessEvent == "function") {
    const r = t.preprocessEvent.bind(t);
    e.on("preprocessEvent", (i, o) => r(i, o, e));
  }
  if (typeof t.processEvent == "function") {
    const r = t.processEvent.bind(t), i = Object.assign((o, s) => r(o, s, e), {
      id: t.name
    });
    e.addEventProcessor(i);
  }
  O && v.log(`Integration installed: ${t.name}`);
}
function Il(e, t) {
  for (let n = 0; n < e.length; n++)
    if (t(e[n]) === !0)
      return n;
  return -1;
}
const io = "Not capturing exception because it's already been captured.";
class Ml {
  /** Options passed to the SDK. */
  /** The client Dsn, if specified in options. Without this Dsn, the SDK will be disabled. */
  /** Array of set up integrations. */
  /** Number of calls being processed */
  /** Holds flushable  */
  // eslint-disable-next-line @typescript-eslint/ban-types
  /**
   * Initializes this client instance.
   *
   * @param options Options for the client.
   */
  constructor(t) {
    if (this._options = t, this._integrations = {}, this._numProcessing = 0, this._outcomes = {}, this._hooks = {}, this._eventProcessors = [], t.dsn ? this._dsn = Cu(t.dsn) : O && v.warn("No DSN provided, client will not send events."), this._dsn) {
      const n = wl(
        this._dsn,
        t.tunnel,
        t._metadata ? t._metadata.sdk : void 0
      );
      this._transport = t.transport({
        tunnel: this._options.tunnel,
        recordDroppedEvent: this.recordDroppedEvent.bind(this),
        ...t.transportOptions,
        url: n
      });
    }
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
  captureException(t, n, r) {
    const i = V();
    if (Fi(t))
      return O && v.log(io), i;
    const o = {
      event_id: i,
      ...n
    };
    return this._process(
      this.eventFromException(t, o).then(
        (s) => this._captureEvent(s, o, r)
      )
    ), o.event_id;
  }
  /**
   * @inheritDoc
   */
  captureMessage(t, n, r, i) {
    const o = {
      event_id: V(),
      ...r
    }, s = Ir(t) ? t : String(t), a = Mr(t) ? this.eventFromMessage(s, n, o) : this.eventFromException(t, o);
    return this._process(a.then((c) => this._captureEvent(c, o, i))), o.event_id;
  }
  /**
   * @inheritDoc
   */
  captureEvent(t, n, r) {
    const i = V();
    if (n && n.originalException && Fi(n.originalException))
      return O && v.log(io), i;
    const o = {
      event_id: i,
      ...n
    }, a = (t.sdkProcessingMetadata || {}).capturedSpanScope;
    return this._process(this._captureEvent(t, o, a || r)), o.event_id;
  }
  /**
   * @inheritDoc
   */
  captureSession(t) {
    typeof t.release != "string" ? O && v.warn("Discarded session because of missing or non-string release") : (this.sendSession(t), ft(t, { init: !1 }));
  }
  /**
   * @inheritDoc
   */
  getDsn() {
    return this._dsn;
  }
  /**
   * @inheritDoc
   */
  getOptions() {
    return this._options;
  }
  /**
   * @see SdkMetadata in @sentry/types
   *
   * @return The metadata of the SDK
   */
  getSdkMetadata() {
    return this._options._metadata;
  }
  /**
   * @inheritDoc
   */
  getTransport() {
    return this._transport;
  }
  /**
   * @inheritDoc
   */
  flush(t) {
    const n = this._transport;
    return n ? (this.emit("flush"), this._isClientDoneProcessing(t).then((r) => n.flush(t).then((i) => r && i))) : Ke(!0);
  }
  /**
   * @inheritDoc
   */
  close(t) {
    return this.flush(t).then((n) => (this.getOptions().enabled = !1, this.emit("close"), n));
  }
  /** Get all installed event processors. */
  getEventProcessors() {
    return this._eventProcessors;
  }
  /** @inheritDoc */
  addEventProcessor(t) {
    this._eventProcessors.push(t);
  }
  /** @inheritdoc */
  init() {
    this._isEnabled() && this._setupIntegrations();
  }
  /**
   * Gets an installed integration by its name.
   *
   * @returns The installed integration or `undefined` if no integration with that `name` was installed.
   */
  getIntegrationByName(t) {
    return this._integrations[t];
  }
  /**
   * @inheritDoc
   */
  addIntegration(t) {
    const n = this._integrations[t.name];
    Gs(this, t, this._integrations), n || ro(this, [t]);
  }
  /**
   * @inheritDoc
   */
  sendEvent(t, n = {}) {
    this.emit("beforeSendEvent", t, n);
    let r = Vd(t, this._dsn, this._options._metadata, this._options.tunnel);
    for (const o of n.attachments || [])
      r = nd(r, sd(o));
    const i = this.sendEnvelope(r);
    i && i.then((o) => this.emit("afterSendEvent", t, o), null);
  }
  /**
   * @inheritDoc
   */
  sendSession(t) {
    const n = jd(t, this._dsn, this._options._metadata, this._options.tunnel);
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  recordDroppedEvent(t, n, r) {
    if (this._options.sendClientReports) {
      const i = `${t}:${n}`;
      O && v.log(`Adding outcome: "${i}"`), this._outcomes[i] = this._outcomes[i] + 1 || 1;
    }
  }
  // Keep on() & emit() signatures in sync with types' client.ts interface
  /* eslint-disable @typescript-eslint/unified-signatures */
  /** @inheritdoc */
  /** @inheritdoc */
  on(t, n) {
    this._hooks[t] || (this._hooks[t] = []), this._hooks[t].push(n);
  }
  /** @inheritdoc */
  /** @inheritdoc */
  emit(t, ...n) {
    this._hooks[t] && this._hooks[t].forEach((r) => r(...n));
  }
  /**
   * @inheritdoc
   */
  sendEnvelope(t) {
    return this.emit("beforeEnvelope", t), this._isEnabled() && this._transport ? this._transport.send(t).then(null, (n) => (O && v.error("Error while sending event:", n), n)) : (O && v.error("Transport disabled"), Ke({}));
  }
  /* eslint-enable @typescript-eslint/unified-signatures */
  /** Setup integrations for this client. */
  _setupIntegrations() {
    const { integrations: t } = this._options;
    this._integrations = kl(this, t), ro(this, t);
  }
  /** Updates existing session based on the provided event */
  _updateSessionFromEvent(t, n) {
    let r = !1, i = !1;
    const o = n.exception && n.exception.values;
    if (o) {
      i = !0;
      for (const c of o) {
        const d = c.mechanism;
        if (d && d.handled === !1) {
          r = !0;
          break;
        }
      }
    }
    const s = t.status === "ok";
    (s && t.errors === 0 || s && r) && (ft(t, {
      ...r && { status: "crashed" },
      errors: t.errors || Number(i || r)
    }), this.captureSession(t));
  }
  /**
   * Determine if the client is finished processing. Returns a promise because it will wait `timeout` ms before saying
   * "no" (resolving to `false`) in order to give the client a chance to potentially finish first.
   *
   * @param timeout The time, in ms, after which to resolve to `false` if the client is still busy. Passing `0` (or not
   * passing anything) will make the promise wait as long as it takes for processing to finish before resolving to
   * `true`.
   * @returns A promise which will resolve to `true` if processing is already done or finishes before the timeout, and
   * `false` otherwise
   */
  _isClientDoneProcessing(t) {
    return new _e((n) => {
      let r = 0;
      const i = 1, o = setInterval(() => {
        this._numProcessing == 0 ? (clearInterval(o), n(!0)) : (r += i, t && r >= t && (clearInterval(o), n(!1)));
      }, i);
    });
  }
  /** Determines whether this SDK is enabled and a transport is present. */
  _isEnabled() {
    return this.getOptions().enabled !== !1 && this._transport !== void 0;
  }
  /**
   * Adds common information to events.
   *
   * The information includes release and environment from `options`,
   * breadcrumbs and context (extra, tags and user) from the scope.
   *
   * Information that is already present in the event is never overwritten. For
   * nested objects, such as the context, keys are merged.
   *
   * @param event The original event.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A new event with more information.
   */
  _prepareEvent(t, n, r, i = xe()) {
    const o = this.getOptions(), s = Object.keys(this._integrations);
    return !n.integrations && s.length > 0 && (n.integrations = s), this.emit("preprocessEvent", t, n), t.type || i.setLastEventId(t.event_id || n.event_id), dl(o, t, n, r, this, i).then((a) => {
      if (a === null)
        return a;
      const c = {
        ...i.getPropagationContext(),
        ...r ? r.getPropagationContext() : void 0
      };
      if (!(a.contexts && a.contexts.trace) && c) {
        const { traceId: l, spanId: u, parentSpanId: p, dsc: f } = c;
        a.contexts = {
          trace: ie({
            trace_id: l,
            span_id: u,
            parent_span_id: p
          }),
          ...a.contexts
        };
        const _ = f || Nn(l, this);
        a.sdkProcessingMetadata = {
          dynamicSamplingContext: _,
          ...a.sdkProcessingMetadata
        };
      }
      return a;
    });
  }
  /**
   * Processes the event and logs an error in case of rejection
   * @param event
   * @param hint
   * @param scope
   */
  _captureEvent(t, n = {}, r) {
    return this._processEvent(t, n, r).then(
      (i) => i.event_id,
      (i) => {
        if (O) {
          const o = i;
          o.logLevel === "log" ? v.log(o.message) : v.warn(o);
        }
      }
    );
  }
  /**
   * Processes an event (either error or message) and sends it to Sentry.
   *
   * This also adds breadcrumbs and context information to the event. However,
   * platform specific meta data (such as the User's IP address) must be added
   * by the SDK implementor.
   *
   *
   * @param event The event to send to Sentry.
   * @param hint May contain additional information about the original exception.
   * @param currentScope A scope containing event metadata.
   * @returns A SyncPromise that resolves with the event or rejects in case event was/will not be send.
   */
  _processEvent(t, n, r) {
    const i = this.getOptions(), { sampleRate: o } = i, s = zs(t), a = Ws(t), c = t.type || "error", d = `before send for type \`${c}\``, l = typeof o > "u" ? void 0 : Fs(o);
    if (a && typeof l == "number" && Math.random() > l)
      return this.recordDroppedEvent("sample_rate", "error", t), mn(
        new we(
          `Discarding event because it's not included in the random sample (sampling rate = ${o})`,
          "log"
        )
      );
    const u = c === "replay_event" ? "replay" : c, f = (t.sdkProcessingMetadata || {}).capturedSpanIsolationScope;
    return this._prepareEvent(t, n, r, f).then((_) => {
      if (_ === null)
        throw this.recordDroppedEvent("event_processor", u, t), new we("An event processor returned `null`, will not send event.", "log");
      if (n.data && n.data.__sentry__ === !0)
        return _;
      const b = Al(i, _, n);
      return Nl(b, d);
    }).then((_) => {
      if (_ === null)
        throw this.recordDroppedEvent("before_send", u, t), new we(`${d} returned \`null\`, will not send event.`, "log");
      const S = r && r.getSession();
      !s && S && this._updateSessionFromEvent(S, _);
      const b = _.transaction_info;
      if (s && b && _.transaction !== t.transaction) {
        const E = "custom";
        _.transaction_info = {
          ...b,
          source: E
        };
      }
      return this.sendEvent(_, n), _;
    }).then(null, (_) => {
      throw _ instanceof we ? _ : (this.captureException(_, {
        data: {
          __sentry__: !0
        },
        originalException: _
      }), new we(
        `Event processing pipeline threw an error, original event will not be sent. Details have been sent as a new event.
Reason: ${_}`
      ));
    });
  }
  /**
   * Occupies the client with processing and event
   */
  _process(t) {
    this._numProcessing++, t.then(
      (n) => (this._numProcessing--, n),
      (n) => (this._numProcessing--, n)
    );
  }
  /**
   * Clears outcomes on this client and returns them.
   */
  _clearOutcomes() {
    const t = this._outcomes;
    return this._outcomes = {}, Object.keys(t).map((n) => {
      const [r, i] = n.split(":");
      return {
        reason: r,
        category: i,
        quantity: t[n]
      };
    });
  }
  /**
   * @inheritDoc
   */
  // eslint-disable-next-line @typescript-eslint/no-explicit-any
}
function Nl(e, t) {
  const n = `${t} must return \`null\` or a valid event.`;
  if (In(e))
    return e.then(
      (r) => {
        if (!dt(r) && r !== null)
          throw new we(n);
        return r;
      },
      (r) => {
        throw new we(`${t} rejected with ${r}`);
      }
    );
  if (!dt(e) && e !== null)
    throw new we(n);
  return e;
}
function Al(e, t, n) {
  const { beforeSend: r, beforeSendTransaction: i, beforeSendSpan: o } = e;
  if (Ws(t) && r)
    return r(t, n);
  if (zs(t)) {
    if (t.spans && o) {
      const s = [];
      for (const a of t.spans) {
        const c = o(a);
        c && s.push(c);
      }
      t.spans = s;
    }
    if (i)
      return i(t, n);
  }
  return t;
}
function Ws(e) {
  return e.type === void 0;
}
function zs(e) {
  return e.type === "transaction";
}
function xl(e, t) {
  t.debug === !0 && (O ? v.enable() : Ht(() => {
    console.warn("[Sentry] Cannot initialize SDK with `debug` option using a non-debug bundle.");
  })), W().update(t.initialScope);
  const r = new e(t);
  Rl(r), r.init();
}
function Rl(e) {
  W().setClient(e), Ll(e);
}
function Ll(e) {
  const t = Mn(tt());
  t.hub && typeof t.hub.getStackTop == "function" && (t.hub.getStackTop().client = e);
}
const Ol = 64;
function Pl(e, t, n = Gu(
  e.bufferSize || Ol
)) {
  let r = {};
  const i = (s) => n.drain(s);
  function o(s) {
    const a = [];
    if (Ui(s, (u, p) => {
      const f = Bi(p);
      if (pd(r, f)) {
        const _ = oo(u, p);
        e.recordDroppedEvent("ratelimit_backoff", f, _);
      } else
        a.push(u);
    }), a.length === 0)
      return Ke({});
    const c = St(s[0], a), d = (u) => {
      Ui(c, (p, f) => {
        const _ = oo(p, f);
        e.recordDroppedEvent(u, Bi(f), _);
      });
    }, l = () => t({ body: rd(c) }).then(
      (u) => (u.statusCode !== void 0 && (u.statusCode < 200 || u.statusCode >= 300) && O && v.warn(`Sentry responded with status code ${u.statusCode} to sent event.`), r = _d(r, u), u),
      (u) => {
        throw d("network_error"), u;
      }
    );
    return n.add(l).then(
      (u) => u,
      (u) => {
        if (u instanceof we)
          return O && v.error("Skipped sending event because buffer is full."), d("queue_overflow"), Ke({});
        throw u;
      }
    );
  }
  return {
    send: o,
    flush: i
  };
}
function oo(e, t) {
  if (!(t !== "event" && t !== "transaction"))
    return Array.isArray(e) ? e[1] : void 0;
}
const so = "8.4.0";
function $l(e, t, n = [t], r = "npm") {
  const i = e._metadata || {};
  i.sdk || (i.sdk = {
    name: `sentry.javascript.${t}`,
    packages: n.map((o) => ({
      name: `${r}:@sentry/${o}`,
      version: so
    })),
    version: so
  }), e._metadata = i;
}
const Dl = 100;
function Je(e, t) {
  const n = U(), r = xe();
  if (!n)
    return;
  const { beforeBreadcrumb: i = null, maxBreadcrumbs: o = Dl } = n.getOptions();
  if (o <= 0)
    return;
  const a = { timestamp: Bt(), ...e }, c = i ? Ht(() => i(a, t)) : a;
  c !== null && (n.emit && n.emit("beforeAddBreadcrumb", c, t), r.addBreadcrumb(c, o));
}
let ao;
const Fl = "FunctionToString", co = /* @__PURE__ */ new WeakMap(), Hl = () => ({
  name: Fl,
  setupOnce() {
    ao = Function.prototype.toString;
    try {
      Function.prototype.toString = function(...e) {
        const t = Ar(this), n = co.has(U()) && t !== void 0 ? t : this;
        return ao.apply(n, e);
      };
    } catch {
    }
  },
  setup(e) {
    co.set(e, !0);
  }
}), Ul = Hl, Bl = [
  /^Script error\.?$/,
  /^Javascript error: Script error\.? on line 0$/,
  /^ResizeObserver loop completed with undelivered notifications.$/,
  /^Cannot redefine property: googletag$/
], jl = "InboundFilters", Vl = (e = {}) => ({
  name: jl,
  processEvent(t, n, r) {
    const i = r.getOptions(), o = Gl(e, i);
    return Wl(t, o) ? null : t;
  }
}), ql = Vl;
function Gl(e = {}, t = {}) {
  return {
    allowUrls: [...e.allowUrls || [], ...t.allowUrls || []],
    denyUrls: [...e.denyUrls || [], ...t.denyUrls || []],
    ignoreErrors: [
      ...e.ignoreErrors || [],
      ...t.ignoreErrors || [],
      ...e.disableErrorDefaults ? [] : Bl
    ],
    ignoreTransactions: [...e.ignoreTransactions || [], ...t.ignoreTransactions || []],
    ignoreInternal: e.ignoreInternal !== void 0 ? e.ignoreInternal : !0
  };
}
function Wl(e, t) {
  return t.ignoreInternal && Jl(e) ? (O && v.warn(`Event dropped due to being internal Sentry Error.
Event: ${Ve(e)}`), !0) : zl(e, t.ignoreErrors) ? (O && v.warn(
    `Event dropped due to being matched by \`ignoreErrors\` option.
Event: ${Ve(e)}`
  ), !0) : Zl(e, t.ignoreTransactions) ? (O && v.warn(
    `Event dropped due to being matched by \`ignoreTransactions\` option.
Event: ${Ve(e)}`
  ), !0) : Yl(e, t.denyUrls) ? (O && v.warn(
    `Event dropped due to being matched by \`denyUrls\` option.
Event: ${Ve(
      e
    )}.
Url: ${vn(e)}`
  ), !0) : Kl(e, t.allowUrls) ? !1 : (O && v.warn(
    `Event dropped due to not being matched by \`allowUrls\` option.
Event: ${Ve(
      e
    )}.
Url: ${vn(e)}`
  ), !0);
}
function zl(e, t) {
  return e.type || !t || !t.length ? !1 : Xl(e).some((n) => Ge(n, t));
}
function Zl(e, t) {
  if (e.type !== "transaction" || !t || !t.length)
    return !1;
  const n = e.transaction;
  return n ? Ge(n, t) : !1;
}
function Yl(e, t) {
  if (!t || !t.length)
    return !1;
  const n = vn(e);
  return n ? Ge(n, t) : !1;
}
function Kl(e, t) {
  if (!t || !t.length)
    return !0;
  const n = vn(e);
  return n ? Ge(n, t) : !0;
}
function Xl(e) {
  const t = [];
  e.message && t.push(e.message);
  let n;
  try {
    n = e.exception.values[e.exception.values.length - 1];
  } catch {
  }
  return n && n.value && (t.push(n.value), n.type && t.push(`${n.type}: ${n.value}`)), t;
}
function Jl(e) {
  try {
    return e.exception.values[0].type === "SentryError";
  } catch {
  }
  return !1;
}
function Ql(e = []) {
  for (let t = e.length - 1; t >= 0; t--) {
    const n = e[t];
    if (n && n.filename !== "<anonymous>" && n.filename !== "[native code]")
      return n.filename || null;
  }
  return null;
}
function vn(e) {
  try {
    let t;
    try {
      t = e.exception.values[0].stacktrace.frames;
    } catch {
    }
    return t ? Ql(t) : null;
  } catch {
    return O && v.error(`Cannot extract url for event ${Ve(e)}`), null;
  }
}
const e0 = "Dedupe", t0 = () => {
  let e;
  return {
    name: e0,
    processEvent(t) {
      if (t.type)
        return t;
      try {
        if (r0(t, e))
          return O && v.warn("Event dropped due to being a duplicate of previously captured event."), null;
      } catch {
      }
      return e = t;
    }
  };
}, n0 = t0;
function r0(e, t) {
  return t ? !!(i0(e, t) || o0(e, t)) : !1;
}
function i0(e, t) {
  const n = e.message, r = t.message;
  return !(!n && !r || n && !r || !n && r || n !== r || !Ys(e, t) || !Zs(e, t));
}
function o0(e, t) {
  const n = uo(t), r = uo(e);
  return !(!n || !r || n.type !== r.type || n.value !== r.value || !Ys(e, t) || !Zs(e, t));
}
function Zs(e, t) {
  let n = lo(e), r = lo(t);
  if (!n && !r)
    return !0;
  if (n && !r || !n && r || (n = n, r = r, r.length !== n.length))
    return !1;
  for (let i = 0; i < r.length; i++) {
    const o = r[i], s = n[i];
    if (o.filename !== s.filename || o.lineno !== s.lineno || o.colno !== s.colno || o.function !== s.function)
      return !1;
  }
  return !0;
}
function Ys(e, t) {
  let n = e.fingerprint, r = t.fingerprint;
  if (!n && !r)
    return !0;
  if (n && !r || !n && r)
    return !1;
  n = n, r = r;
  try {
    return n.join("") === r.join("");
  } catch {
    return !1;
  }
}
function uo(e) {
  return e.exception && e.exception.values && e.exception.values[0];
}
function lo(e) {
  const t = e.exception;
  if (t)
    try {
      return t.values[0].stacktrace.frames;
    } catch {
      return;
    }
}
function s0(e, t, n, r, i = "auto.http.browser") {
  if (!e.fetchData)
    return;
  const o = Ue() && t(e.fetchData.url);
  if (e.endTimestamp && o) {
    const _ = e.fetchData.__span;
    if (!_)
      return;
    const S = r[_];
    S && (u0(S, e), delete r[_]);
    return;
  }
  const s = W(), a = U(), { method: c, url: d } = e.fetchData, l = c0(d), u = l ? We(l).host : void 0, p = !!ge(), f = o && p ? it({
    name: `${c} ${d}`,
    attributes: {
      url: d,
      type: "fetch",
      "http.method": c,
      "http.url": l,
      "server.address": u,
      [oe]: i,
      [Pt]: "http.client"
    }
  }) : new bt();
  if (e.fetchData.__span = f.spanContext().spanId, r[f.spanContext().spanId] = f, n(e.fetchData.url) && a) {
    const _ = e.args[0];
    e.args[1] = e.args[1] || {};
    const S = e.args[1];
    S.headers = a0(
      _,
      a,
      s,
      S,
      // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),
      // we do not want to use the span as base for the trace headers,
      // which means that the headers will be generated from the scope and the sampling decision is deferred
      Ue() && p ? f : void 0
    );
  }
  return f;
}
function a0(e, t, n, r, i) {
  const o = xe(), { traceId: s, spanId: a, sampled: c, dsc: d } = {
    ...o.getPropagationContext(),
    ...n.getPropagationContext()
  }, l = i ? Rs(i) : xr(s, a, c), u = ws(
    d || (i ? rt(i) : Nn(s, t))
  ), p = r.headers || (typeof Request < "u" && Ne(e, Request) ? e.headers : void 0);
  if (p)
    if (typeof Headers < "u" && Ne(p, Headers)) {
      const f = new Headers(p);
      return f.append("sentry-trace", l), u && f.append(sr, u), f;
    } else if (Array.isArray(p)) {
      const f = [...p, ["sentry-trace", l]];
      return u && f.push([sr, u]), f;
    } else {
      const f = "baggage" in p ? p.baggage : void 0, _ = [];
      return Array.isArray(f) ? _.push(...f) : f && _.push(f), u && _.push(u), {
        ...p,
        "sentry-trace": l,
        baggage: _.length > 0 ? _.join(",") : void 0
      };
    }
  else
    return { "sentry-trace": l, baggage: u };
}
function c0(e) {
  try {
    return new URL(e).href;
  } catch {
    return;
  }
}
function u0(e, t) {
  if (t.response) {
    Ns(e, t.response.status);
    const n = t.response && t.response.headers && t.response.headers.get("content-length");
    if (n) {
      const r = parseInt(n);
      r > 0 && e.setAttribute("http.response_content_length", r);
    }
  } else
    t.error && e.setStatus({ code: ee, message: "internal_error" });
  e.end();
}
const A = F;
let pr = 0;
function Ks() {
  return pr > 0;
}
function d0() {
  pr++, setTimeout(() => {
    pr--;
  });
}
function _t(e, t = {}, n) {
  if (typeof e != "function")
    return e;
  try {
    const i = e.__sentry_wrapped__;
    if (i)
      return i;
    if (Ar(e))
      return e;
  } catch {
    return e;
  }
  const r = function() {
    const i = Array.prototype.slice.call(arguments);
    try {
      const o = i.map((s) => _t(s, t));
      return e.apply(this, o);
    } catch (o) {
      throw d0(), Lr((s) => {
        s.addEventProcessor((a) => (t.mechanism && (ir(a, void 0), Lt(a, t.mechanism)), a.extra = {
          ...a.extra,
          arguments: i
        }, a)), ml(o);
      }), o;
    }
  };
  try {
    for (const i in e)
      Object.prototype.hasOwnProperty.call(e, i) && (r[i] = e[i]);
  } catch {
  }
  ds(r, e), ve(e, "__sentry_wrapped__", r);
  try {
    Object.getOwnPropertyDescriptor(r, "name").configurable && Object.defineProperty(r, "name", {
      get() {
        return e.name;
      }
    });
  } catch {
  }
  return r;
}
const ae = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__;
function Fr(e, t) {
  const n = Hr(e, t), r = {
    type: t && t.name,
    value: h0(t)
  };
  return n.length && (r.stacktrace = { frames: n }), r.type === void 0 && r.value === "" && (r.value = "Unrecoverable error caught"), r;
}
function l0(e, t, n, r) {
  const i = U(), o = i && i.getOptions().normalizeDepth, s = S0(t), a = {
    __serialized__: bs(t, o)
  };
  if (s)
    return {
      exception: {
        values: [Fr(e, s)]
      },
      extra: a
    };
  const c = {
    exception: {
      values: [
        {
          type: kn(t) ? t.constructor.name : r ? "UnhandledRejection" : "Error",
          value: y0(t, { isUnhandledRejection: r })
        }
      ]
    },
    extra: a
  };
  if (n) {
    const d = Hr(e, n);
    d.length && (c.exception.values[0].stacktrace = { frames: d });
  }
  return c;
}
function Hn(e, t) {
  return {
    exception: {
      values: [Fr(e, t)]
    }
  };
}
function Hr(e, t) {
  const n = t.stacktrace || t.stack || "", r = p0(t), i = _0(t);
  try {
    return e(n, r, i);
  } catch {
  }
  return [];
}
const f0 = /Minified React error #\d+;/i;
function p0(e) {
  return e && f0.test(e.message) ? 1 : 0;
}
function _0(e) {
  return typeof e.framesToPop == "number" ? e.framesToPop : 0;
}
function h0(e) {
  const t = e && e.message;
  return t ? t.error && typeof t.error.message == "string" ? t.error.message : t : "No error message";
}
function g0(e, t, n, r) {
  const i = n && n.syntheticException || void 0, o = Ur(e, t, i, r);
  return Lt(o), o.level = "error", n && n.event_id && (o.event_id = n.event_id), Ke(o);
}
function m0(e, t, n = "info", r, i) {
  const o = r && r.syntheticException || void 0, s = _r(e, t, o, i);
  return s.level = n, r && r.event_id && (s.event_id = r.event_id), Ke(s);
}
function Ur(e, t, n, r, i) {
  let o;
  if (ss(t) && t.error)
    return Hn(e, t.error);
  if (Mi(t) || cu(t)) {
    const s = t;
    if ("stack" in t)
      o = Hn(e, t);
    else {
      const a = s.name || (Mi(s) ? "DOMError" : "DOMException"), c = s.message ? `${a}: ${s.message}` : a;
      o = _r(e, c, n, r), ir(o, c);
    }
    return "code" in s && (o.tags = { ...o.tags, "DOMException.code": `${s.code}` }), o;
  }
  return os(t) ? Hn(e, t) : dt(t) || kn(t) ? (o = l0(e, t, n, i), Lt(o, {
    synthetic: !0
  }), o) : (o = _r(e, t, n, r), ir(o, `${t}`), Lt(o, {
    synthetic: !0
  }), o);
}
function _r(e, t, n, r) {
  const i = {};
  if (r && n) {
    const o = Hr(e, n);
    o.length && (i.exception = {
      values: [{ value: t, stacktrace: { frames: o } }]
    });
  }
  if (Ir(t)) {
    const { __sentry_template_string__: o, __sentry_template_values__: s } = t;
    return i.logentry = {
      message: o,
      params: s
    }, i;
  }
  return i.message = t, i;
}
function y0(e, { isUnhandledRejection: t }) {
  const n = Iu(e), r = t ? "promise rejection" : "exception";
  return ss(e) ? `Event \`ErrorEvent\` captured as ${r} with message \`${e.message}\`` : kn(e) ? `Event \`${v0(e)}\` (type=${e.type}) captured as ${r}` : `Object captured as ${r} with keys: ${n}`;
}
function v0(e) {
  try {
    const t = Object.getPrototypeOf(e);
    return t ? t.constructor.name : void 0;
  } catch {
  }
}
function S0(e) {
  for (const t in e)
    if (Object.prototype.hasOwnProperty.call(e, t)) {
      const n = e[t];
      if (n instanceof Error)
        return n;
    }
}
function b0(e, {
  metadata: t,
  tunnel: n,
  dsn: r
}) {
  const i = {
    event_id: e.event_id,
    sent_at: (/* @__PURE__ */ new Date()).toISOString(),
    ...t && t.sdk && {
      sdk: {
        name: t.sdk.name,
        version: t.sdk.version
      }
    },
    ...!!n && !!r && { dsn: Ut(r) }
  }, o = E0(e);
  return St(i, [o]);
}
function E0(e) {
  return [{
    type: "user_report"
  }, e];
}
class w0 extends Ml {
  /**
   * Creates a new Browser SDK instance.
   *
   * @param options Configuration options for this SDK.
   */
  constructor(t) {
    const n = {
      // We default this to true, as it is the safer scenario
      parentSpanIsAlwaysRootSpan: !0,
      ...t
    }, r = A.SENTRY_SDK_SOURCE || Hu();
    $l(n, "browser", ["browser"], r), super(n), n.sendClientReports && A.document && A.document.addEventListener("visibilitychange", () => {
      A.document.visibilityState === "hidden" && this._flushOutcomes();
    });
  }
  /**
   * @inheritDoc
   */
  eventFromException(t, n) {
    return g0(this._options.stackParser, t, n, this._options.attachStacktrace);
  }
  /**
   * @inheritDoc
   */
  eventFromMessage(t, n = "info", r) {
    return m0(this._options.stackParser, t, n, r, this._options.attachStacktrace);
  }
  /**
   * Sends user feedback to Sentry.
   *
   * @deprecated Use `captureFeedback` instead.
   */
  captureUserFeedback(t) {
    if (!this._isEnabled()) {
      ae && v.warn("SDK not enabled, will not capture user feedback.");
      return;
    }
    const n = b0(t, {
      metadata: this.getSdkMetadata(),
      dsn: this.getDsn(),
      tunnel: this.getOptions().tunnel
    });
    this.sendEnvelope(n);
  }
  /**
   * @inheritDoc
   */
  _prepareEvent(t, n, r) {
    return t.platform = t.platform || "javascript", super._prepareEvent(t, n, r);
  }
  /**
   * Sends client reports as an envelope.
   */
  _flushOutcomes() {
    const t = this._clearOutcomes();
    if (t.length === 0) {
      ae && v.log("No outcomes to send");
      return;
    }
    if (!this._dsn) {
      ae && v.log("No dsn provided, will not send outcomes");
      return;
    }
    ae && v.log("Sending outcomes:", t);
    const n = ud(t, this._options.tunnel && Ut(this._dsn));
    this.sendEnvelope(n);
  }
}
const le = typeof __SENTRY_DEBUG__ > "u" || __SENTRY_DEBUG__, T0 = (e, t) => e > t[1] ? "poor" : e > t[0] ? "needs-improvement" : "good", Et = (e, t, n, r) => {
  let i, o;
  return (s) => {
    t.value >= 0 && (s || r) && (o = t.value - (i || 0), (o || i === void 0) && (i = t.value, t.delta = o, t.rating = T0(t.value, n), e(t)));
  };
}, I = F, C0 = () => `v3-${Date.now()}-${Math.floor(Math.random() * (9e12 - 1)) + 1e12}`, An = () => I.performance && performance.getEntriesByType && performance.getEntriesByType("navigation")[0], xn = () => {
  const e = An();
  return e && e.activationStart || 0;
}, wt = (e, t) => {
  const n = An();
  let r = "navigate";
  return n && (I.document && I.document.prerendering || xn() > 0 ? r = "prerender" : I.document && I.document.wasDiscarded ? r = "restore" : n.type && (r = n.type.replace(/_/g, "-"))), {
    name: e,
    value: typeof t > "u" ? -1 : t,
    rating: "good",
    // If needed, will be updated when reported. `const` to keep the type from widening to `string`.
    delta: 0,
    entries: [],
    id: C0(),
    navigationType: r
  };
}, ot = (e, t, n) => {
  try {
    if (PerformanceObserver.supportedEntryTypes.includes(e)) {
      const r = new PerformanceObserver((i) => {
        Promise.resolve().then(() => {
          t(i.getEntries());
        });
      });
      return r.observe(
        Object.assign(
          {
            type: e,
            buffered: !0
          },
          n || {}
        )
      ), r;
    }
  } catch {
  }
}, Rn = (e) => {
  const t = (n) => {
    (n.type === "pagehide" || I.document && I.document.visibilityState === "hidden") && e(n);
  };
  I.document && (addEventListener("visibilitychange", t, !0), addEventListener("pagehide", t, !0));
}, Br = (e) => {
  let t = !1;
  return (n) => {
    t || (e(n), t = !0);
  };
};
let $t = -1;
const k0 = () => {
  $t = I.document.visibilityState === "hidden" && !I.document.prerendering ? 0 : 1 / 0;
}, Sn = (e) => {
  I.document.visibilityState === "hidden" && $t > -1 && ($t = e.type === "visibilitychange" ? e.timeStamp : 0, removeEventListener("visibilitychange", Sn, !0), removeEventListener("prerenderingchange", Sn, !0));
}, I0 = () => {
  addEventListener("visibilitychange", Sn, !0), addEventListener("prerenderingchange", Sn, !0);
}, Ln = () => (I.document && $t < 0 && (k0(), I0()), {
  get firstHiddenTime() {
    return $t;
  }
}), Vt = (e) => {
  I.document && I.document.prerendering ? addEventListener("prerenderingchange", () => e(), !0) : e();
}, M0 = [1800, 3e3], N0 = (e, t = {}) => {
  Vt(() => {
    const n = Ln(), r = wt("FCP");
    let i;
    const s = ot("paint", (a) => {
      a.forEach((c) => {
        c.name === "first-contentful-paint" && (s.disconnect(), c.startTime < n.firstHiddenTime && (r.value = Math.max(c.startTime - xn(), 0), r.entries.push(c), i(!0)));
      });
    });
    s && (i = Et(e, r, M0, t.reportAllChanges));
  });
}, A0 = [0.1, 0.25], x0 = (e, t = {}) => {
  N0(
    Br(() => {
      const n = wt("CLS", 0);
      let r, i = 0, o = [];
      const s = (c) => {
        c.forEach((d) => {
          if (!d.hadRecentInput) {
            const l = o[0], u = o[o.length - 1];
            i && d.startTime - u.startTime < 1e3 && d.startTime - l.startTime < 5e3 ? (i += d.value, o.push(d)) : (i = d.value, o = [d]);
          }
        }), i > n.value && (n.value = i, n.entries = o, r());
      }, a = ot("layout-shift", s);
      a && (r = Et(e, n, A0, t.reportAllChanges), Rn(() => {
        s(a.takeRecords()), r(!0);
      }), setTimeout(r, 0));
    })
  );
}, R0 = [100, 300], L0 = (e, t = {}) => {
  Vt(() => {
    const n = Ln(), r = wt("FID");
    let i;
    const o = (c) => {
      c.startTime < n.firstHiddenTime && (r.value = c.processingStart - c.startTime, r.entries.push(c), i(!0));
    }, s = (c) => {
      c.forEach(o);
    }, a = ot("first-input", s);
    i = Et(e, r, R0, t.reportAllChanges), a && Rn(
      Br(() => {
        s(a.takeRecords()), a.disconnect();
      })
    );
  });
};
let Xs = 0, Un = 1 / 0, en = 0;
const O0 = (e) => {
  e.forEach((t) => {
    t.interactionId && (Un = Math.min(Un, t.interactionId), en = Math.max(en, t.interactionId), Xs = en ? (en - Un) / 7 + 1 : 0);
  });
};
let hr;
const P0 = () => hr ? Xs : performance.interactionCount || 0, $0 = () => {
  "interactionCount" in performance || hr || (hr = ot("event", O0, {
    type: "event",
    buffered: !0,
    durationThreshold: 0
  }));
}, D0 = [200, 500], F0 = 0, Js = () => P0() - F0, fo = 10, ke = [], Bn = {}, po = (e) => {
  const t = ke[ke.length - 1], n = Bn[e.interactionId];
  if (n || ke.length < fo || e.duration > t.latency) {
    if (n)
      n.entries.push(e), n.latency = Math.max(n.latency, e.duration);
    else {
      const r = {
        // eslint-disable-next-line @typescript-eslint/no-non-null-assertion
        id: e.interactionId,
        latency: e.duration,
        entries: [e]
      };
      Bn[r.id] = r, ke.push(r);
    }
    ke.sort((r, i) => i.latency - r.latency), ke.splice(fo).forEach((r) => {
      delete Bn[r.id];
    });
  }
}, H0 = () => {
  const e = Math.min(
    ke.length - 1,
    Math.floor(Js() / 50)
  );
  return ke[e];
}, U0 = (e, t = {}) => {
  Vt(() => {
    $0();
    const n = wt("INP");
    let r;
    const i = (s) => {
      s.forEach((c) => {
        c.interactionId && po(c), c.entryType === "first-input" && !ke.some((l) => l.entries.some((u) => c.duration === u.duration && c.startTime === u.startTime)) && po(c);
      });
      const a = H0();
      a && a.latency !== n.value && (n.value = a.latency, n.entries = a.entries, r());
    }, o = ot("event", i, {
      // Event Timing entries have their durations rounded to the nearest 8ms,
      // so a duration of 40ms would be any event that spans 2.5 or more frames
      // at 60Hz. This threshold is chosen to strike a balance between usefulness
      // and performance. Running this callback for any interaction that spans
      // just one or two frames is likely not worth the insight that could be
      // gained.
      durationThreshold: t.durationThreshold != null ? t.durationThreshold : 40
    });
    r = Et(e, n, D0, t.reportAllChanges), o && ("PerformanceEventTiming" in I && "interactionId" in PerformanceEventTiming.prototype && o.observe({ type: "first-input", buffered: !0 }), Rn(() => {
      i(o.takeRecords()), n.value < 0 && Js() > 0 && (n.value = 0, n.entries = []), r(!0);
    }));
  });
}, B0 = [2500, 4e3], _o = {}, j0 = (e, t = {}) => {
  Vt(() => {
    const n = Ln(), r = wt("LCP");
    let i;
    const o = (a) => {
      const c = a[a.length - 1];
      c && c.startTime < n.firstHiddenTime && (r.value = Math.max(c.startTime - xn(), 0), r.entries = [c], i());
    }, s = ot("largest-contentful-paint", o);
    if (s) {
      i = Et(e, r, B0, t.reportAllChanges);
      const a = Br(() => {
        _o[r.id] || (o(s.takeRecords()), s.disconnect(), _o[r.id] = !0, i(!0));
      });
      ["keydown", "click"].forEach((c) => {
        I.document && addEventListener(c, () => setTimeout(a, 0), !0);
      }), Rn(a);
    }
  });
}, V0 = [800, 1800], gr = (e) => {
  I.document && I.document.prerendering ? Vt(() => gr(e)) : I.document && I.document.readyState !== "complete" ? addEventListener("load", () => gr(e), !0) : setTimeout(e, 0);
}, q0 = (e, t = {}) => {
  const n = wt("TTFB"), r = Et(e, n, V0, t.reportAllChanges);
  gr(() => {
    const i = An();
    if (i) {
      const o = i.responseStart;
      if (o <= 0 || o > performance.now())
        return;
      n.value = Math.max(o - xn(), 0), n.entries = [i], r(!0);
    }
  });
}, It = {}, bn = {};
let Qs, ea, ta, na, ra;
function G0(e, t = !1) {
  return qt("cls", e, K0, Qs, t);
}
function W0(e, t = !1) {
  return qt("lcp", e, J0, ta, t);
}
function z0(e) {
  return qt("fid", e, X0, ea);
}
function Z0(e) {
  return qt("ttfb", e, Q0, na);
}
function Y0(e) {
  return qt("inp", e, ef, ra);
}
function jr(e, t) {
  return ia(e, t), bn[e] || (tf(e), bn[e] = !0), oa(e, t);
}
function Tt(e, t) {
  const n = It[e];
  if (!(!n || !n.length))
    for (const r of n)
      try {
        r(t);
      } catch (i) {
        le && v.error(
          `Error while triggering instrumentation handler.
Type: ${e}
Name: ${Ae(r)}
Error:`,
          i
        );
      }
}
function K0() {
  return x0(
    (e) => {
      Tt("cls", {
        metric: e
      }), Qs = e;
    },
    // We want the callback to be called whenever the CLS value updates.
    // By default, the callback is only called when the tab goes to the background.
    { reportAllChanges: !0 }
  );
}
function X0() {
  return L0((e) => {
    Tt("fid", {
      metric: e
    }), ea = e;
  });
}
function J0() {
  return j0((e) => {
    Tt("lcp", {
      metric: e
    }), ta = e;
  });
}
function Q0() {
  return q0((e) => {
    Tt("ttfb", {
      metric: e
    }), na = e;
  });
}
function ef() {
  return U0((e) => {
    Tt("inp", {
      metric: e
    }), ra = e;
  });
}
function qt(e, t, n, r, i = !1) {
  ia(e, t);
  let o;
  return bn[e] || (o = n(), bn[e] = !0), r && t({ metric: r }), oa(e, t, i ? o : void 0);
}
function tf(e) {
  const t = {};
  e === "event" && (t.durationThreshold = 0), ot(
    e,
    (n) => {
      Tt(e, { entries: n });
    },
    t
  );
}
function ia(e, t) {
  It[e] = It[e] || [], It[e].push(t);
}
function oa(e, t, n) {
  return () => {
    n && n();
    const r = It[e];
    if (!r)
      return;
    const i = r.indexOf(t);
    i !== -1 && r.splice(i, 1);
  };
}
function jn(e) {
  return typeof e == "number" && isFinite(e);
}
function ht(e, t, n, { ...r }) {
  const i = H(e).start_timestamp;
  return i && i > t && typeof e.updateStartTime == "function" && e.updateStartTime(t), Zd(e, () => {
    const o = it({
      startTime: t,
      ...r
    });
    return o && o.end(n), o;
  });
}
function Vr() {
  return I && I.addEventListener && I.performance;
}
function Q(e) {
  return e / 1e3;
}
const nf = 2147483647;
let ho = 0, Y = {}, Ee, Mt;
function rf() {
  const e = Vr();
  if (e && he) {
    e.mark && I.performance.mark("sentry-tracing-init");
    const t = uf(), n = af(), r = cf(), i = df();
    return () => {
      t(), n(), r(), i();
    };
  }
  return () => {
  };
}
function of() {
  jr("longtask", ({ entries: e }) => {
    for (const t of e) {
      if (!ge())
        return;
      const n = Q(he + t.startTime), r = Q(t.duration), i = it({
        name: "Main UI thread blocked",
        op: "ui.long-task",
        startTime: n,
        attributes: {
          [oe]: "auto.ui.browser.metrics"
        }
      });
      i && i.end(n + r);
    }
  });
}
function sf() {
  jr("event", ({ entries: e }) => {
    for (const t of e) {
      if (!ge())
        return;
      if (t.name === "click") {
        const n = Q(he + t.startTime), r = Q(t.duration), i = {
          name: lt(t.target),
          op: `ui.interaction.${t.name}`,
          startTime: n,
          attributes: {
            [oe]: "auto.ui.browser.metrics"
          }
        }, o = cs(t.target);
        o && (i.attributes["ui.component_name"] = o);
        const s = it(i);
        s && s.end(n + r);
      }
    }
  });
}
function af() {
  return G0(({ metric: e }) => {
    const t = e.entries[e.entries.length - 1];
    t && (le && v.log("[Measurements] Adding CLS"), Y.cls = { value: e.value, unit: "" }, Mt = t);
  }, !0);
}
function cf() {
  return W0(({ metric: e }) => {
    const t = e.entries[e.entries.length - 1];
    t && (le && v.log("[Measurements] Adding LCP"), Y.lcp = { value: e.value, unit: "millisecond" }, Ee = t);
  }, !0);
}
function uf() {
  return z0(({ metric: e }) => {
    const t = e.entries[e.entries.length - 1];
    if (!t)
      return;
    const n = Q(he), r = Q(t.startTime);
    le && v.log("[Measurements] Adding FID"), Y.fid = { value: e.value, unit: "millisecond" }, Y["mark.fid"] = { value: n + r, unit: "second" };
  });
}
function df() {
  return Z0(({ metric: e }) => {
    e.entries[e.entries.length - 1] && (le && v.log("[Measurements] Adding TTFB"), Y.ttfb = { value: e.value, unit: "millisecond" });
  });
}
function lf(e) {
  const t = Vr();
  if (!t || !I.performance.getEntries || !he)
    return;
  le && v.log("[Tracing] Adding & adjusting spans using Performance API");
  const n = Q(he), r = t.getEntries(), { op: i, start_timestamp: o } = H(e);
  if (r.slice(ho).forEach((s) => {
    const a = Q(s.startTime), c = Q(s.duration);
    if (!(i === "navigation" && o && n + a < o))
      switch (s.entryType) {
        case "navigation": {
          pf(e, s, n);
          break;
        }
        case "mark":
        case "paint":
        case "measure": {
          ff(e, s, a, c, n);
          const d = Ln(), l = s.startTime < d.firstHiddenTime;
          s.name === "first-paint" && l && (le && v.log("[Measurements] Adding FP"), Y.fp = { value: s.startTime, unit: "millisecond" }), s.name === "first-contentful-paint" && l && (le && v.log("[Measurements] Adding FCP"), Y.fcp = { value: s.startTime, unit: "millisecond" });
          break;
        }
        case "resource": {
          hf(e, s, s.name, a, c, n);
          break;
        }
      }
  }), ho = Math.max(r.length - 1, 0), gf(e), i === "pageload") {
    yf(Y), ["fcp", "fp", "lcp"].forEach((a) => {
      if (!Y[a] || !o || n >= o)
        return;
      const c = Y[a].value, d = n + Q(c), l = Math.abs((d - o) * 1e3), u = l - c;
      le && v.log(`[Measurements] Normalized ${a} from ${c} to ${l} (${u})`), Y[a].value = l;
    });
    const s = Y["mark.fid"];
    s && Y.fid && (ht(e, s.value, s.value + Q(Y.fid.value), {
      name: "first input delay",
      op: "ui.action",
      attributes: {
        [oe]: "auto.ui.browser.metrics"
      }
    }), delete Y["mark.fid"]), "fcp" in Y || delete Y.cls, Object.keys(Y).forEach((a) => {
      Gd(a, Y[a].value, Y[a].unit);
    }), mf(e);
  }
  Ee = void 0, Mt = void 0, Y = {};
}
function ff(e, t, n, r, i) {
  const o = i + n, s = o + r;
  return ht(e, o, s, {
    name: t.name,
    op: t.entryType,
    attributes: {
      [oe]: "auto.resource.browser.metrics"
    }
  }), o;
}
function pf(e, t, n) {
  ["unloadEvent", "redirect", "domContentLoadedEvent", "loadEvent", "connect"].forEach((r) => {
    tn(e, t, r, n);
  }), tn(e, t, "secureConnection", n, "TLS/SSL", "connectEnd"), tn(e, t, "fetch", n, "cache", "domainLookupStart"), tn(e, t, "domainLookup", n, "DNS"), _f(e, t, n);
}
function tn(e, t, n, r, i, o) {
  const s = o ? t[o] : t[`${n}End`], a = t[`${n}Start`];
  !a || !s || ht(e, r + Q(a), r + Q(s), {
    op: "browser",
    name: i || n,
    attributes: {
      [oe]: "auto.ui.browser.metrics"
    }
  });
}
function _f(e, t, n) {
  t.responseEnd && (ht(
    e,
    n + Q(t.requestStart),
    n + Q(t.responseEnd),
    {
      op: "browser",
      name: "request",
      attributes: {
        [oe]: "auto.ui.browser.metrics"
      }
    }
  ), ht(
    e,
    n + Q(t.responseStart),
    n + Q(t.responseEnd),
    {
      op: "browser",
      name: "response",
      attributes: {
        [oe]: "auto.ui.browser.metrics"
      }
    }
  ));
}
function hf(e, t, n, r, i, o) {
  if (t.initiatorType === "xmlhttprequest" || t.initiatorType === "fetch")
    return;
  const s = We(n), a = {
    [oe]: "auto.resource.browser.metrics"
  };
  Vn(a, t, "transferSize", "http.response_transfer_size"), Vn(a, t, "encodedBodySize", "http.response_content_length"), Vn(a, t, "decodedBodySize", "http.decoded_response_content_length"), "renderBlockingStatus" in t && (a["resource.render_blocking_status"] = t.renderBlockingStatus), s.protocol && (a["url.scheme"] = s.protocol.split(":").pop()), s.host && (a["server.address"] = s.host), a["url.same_origin"] = n.includes(I.location.origin);
  const c = o + r, d = c + i;
  ht(e, c, d, {
    name: n.replace(I.location.origin, ""),
    op: t.initiatorType ? `resource.${t.initiatorType}` : "resource.other",
    attributes: a
  });
}
function gf(e) {
  const t = I.navigator;
  if (!t)
    return;
  const n = t.connection;
  n && (n.effectiveType && e.setAttribute("effectiveConnectionType", n.effectiveType), n.type && e.setAttribute("connectionType", n.type), jn(n.rtt) && (Y["connection.rtt"] = { value: n.rtt, unit: "millisecond" })), jn(t.deviceMemory) && e.setAttribute("deviceMemory", `${t.deviceMemory} GB`), jn(t.hardwareConcurrency) && e.setAttribute("hardwareConcurrency", String(t.hardwareConcurrency));
}
function mf(e) {
  Ee && (le && v.log("[Measurements] Adding LCP Data"), Ee.element && e.setAttribute("lcp.element", lt(Ee.element)), Ee.id && e.setAttribute("lcp.id", Ee.id), Ee.url && e.setAttribute("lcp.url", Ee.url.trim().slice(0, 200)), e.setAttribute("lcp.size", Ee.size)), Mt && Mt.sources && (le && v.log("[Measurements] Adding CLS Data"), Mt.sources.forEach(
    (t, n) => e.setAttribute(`cls.source.${n + 1}`, lt(t.node))
  ));
}
function Vn(e, t, n, r) {
  const i = t[n];
  i != null && i < nf && (e[r] = i);
}
function yf(e) {
  const t = An();
  if (!t)
    return;
  const { responseStart: n, requestStart: r } = t;
  r <= n && (le && v.log("[Measurements] Adding TTFB Request Time"), e["ttfb.requestTime"] = {
    value: n - r,
    unit: "millisecond"
  });
}
const vf = 1e3;
let go, mr, yr;
function Sf(e) {
  const t = "dom";
  Qe(t, e), et(t, bf);
}
function bf() {
  if (!I.document)
    return;
  const e = ye.bind(null, "dom"), t = mo(e, !0);
  I.document.addEventListener("click", t, !1), I.document.addEventListener("keypress", t, !1), ["EventTarget", "Node"].forEach((n) => {
    const r = I[n] && I[n].prototype;
    !r || !r.hasOwnProperty || !r.hasOwnProperty("addEventListener") || (ne(r, "addEventListener", function(i) {
      return function(o, s, a) {
        if (o === "click" || o == "keypress")
          try {
            const c = this, d = c.__sentry_instrumentation_handlers__ = c.__sentry_instrumentation_handlers__ || {}, l = d[o] = d[o] || { refCount: 0 };
            if (!l.handler) {
              const u = mo(e);
              l.handler = u, i.call(this, o, u, a);
            }
            l.refCount++;
          } catch {
          }
        return i.call(this, o, s, a);
      };
    }), ne(
      r,
      "removeEventListener",
      function(i) {
        return function(o, s, a) {
          if (o === "click" || o == "keypress")
            try {
              const c = this, d = c.__sentry_instrumentation_handlers__ || {}, l = d[o];
              l && (l.refCount--, l.refCount <= 0 && (i.call(this, o, l.handler, a), l.handler = void 0, delete d[o]), Object.keys(d).length === 0 && delete c.__sentry_instrumentation_handlers__);
            } catch {
            }
          return i.call(this, o, s, a);
        };
      }
    ));
  });
}
function Ef(e) {
  if (e.type !== mr)
    return !1;
  try {
    if (!e.target || e.target._sentryId !== yr)
      return !1;
  } catch {
  }
  return !0;
}
function wf(e, t) {
  return e !== "keypress" ? !1 : !t || !t.tagName ? !0 : !(t.tagName === "INPUT" || t.tagName === "TEXTAREA" || t.isContentEditable);
}
function mo(e, t = !1) {
  return (n) => {
    if (!n || n._sentryCaptured)
      return;
    const r = Tf(n);
    if (wf(n.type, r))
      return;
    ve(n, "_sentryCaptured", !0), r && !r._sentryId && ve(r, "_sentryId", V());
    const i = n.type === "keypress" ? "input" : n.type;
    Ef(n) || (e({ event: n, name: i, global: t }), mr = n.type, yr = r ? r._sentryId : void 0), clearTimeout(go), go = I.setTimeout(() => {
      yr = void 0, mr = void 0;
    }, vf);
  };
}
function Tf(e) {
  try {
    return e.target;
  } catch {
    return null;
  }
}
let nn;
function qr(e) {
  const t = "history";
  Qe(t, e), et(t, Cf);
}
function Cf() {
  if (!gd())
    return;
  const e = I.onpopstate;
  I.onpopstate = function(...n) {
    const r = I.location.href, i = nn;
    if (nn = r, ye("history", { from: i, to: r }), e)
      try {
        return e.apply(this, n);
      } catch {
      }
  };
  function t(n) {
    return function(...r) {
      const i = r.length > 2 ? r[2] : void 0;
      if (i) {
        const o = nn, s = String(i);
        nn = s, ye("history", { from: o, to: s });
      }
      return n.apply(this, r);
    };
  }
  ne(I.history, "pushState", t), ne(I.history, "replaceState", t);
}
const ln = {};
function kf(e) {
  const t = ln[e];
  if (t)
    return t;
  let n = I[e];
  if (nr(n))
    return ln[e] = n.bind(I);
  const r = I.document;
  if (r && typeof r.createElement == "function")
    try {
      const i = r.createElement("iframe");
      i.hidden = !0, r.head.appendChild(i);
      const o = i.contentWindow;
      o && o[e] && (n = o[e]), r.head.removeChild(i);
    } catch (i) {
      le && v.warn(`Could not create sandbox iframe for ${e} check, bailing to window.${e}: `, i);
    }
  return n && (ln[e] = n.bind(I));
}
function yo(e) {
  ln[e] = void 0;
}
const at = "__sentry_xhr_v3__";
function sa(e) {
  const t = "xhr";
  Qe(t, e), et(t, If);
}
function If() {
  if (!I.XMLHttpRequest)
    return;
  const e = XMLHttpRequest.prototype;
  ne(e, "open", function(t) {
    return function(...n) {
      const r = ce() * 1e3, i = Me(n[0]) ? n[0].toUpperCase() : void 0, o = Mf(n[1]);
      if (!i || !o)
        return t.apply(this, n);
      this[at] = {
        method: i,
        url: o,
        request_headers: {}
      }, i === "POST" && o.match(/sentry_key/) && (this.__sentry_own_request__ = !0);
      const s = () => {
        const a = this[at];
        if (a && this.readyState === 4) {
          try {
            a.status_code = this.status;
          } catch {
          }
          const c = {
            endTimestamp: ce() * 1e3,
            startTimestamp: r,
            xhr: this
          };
          ye("xhr", c);
        }
      };
      return "onreadystatechange" in this && typeof this.onreadystatechange == "function" ? ne(this, "onreadystatechange", function(a) {
        return function(...c) {
          return s(), a.apply(this, c);
        };
      }) : this.addEventListener("readystatechange", s), ne(this, "setRequestHeader", function(a) {
        return function(...c) {
          const [d, l] = c, u = this[at];
          return u && Me(d) && Me(l) && (u.request_headers[d.toLowerCase()] = l), a.apply(this, c);
        };
      }), t.apply(this, n);
    };
  }), ne(e, "send", function(t) {
    return function(...n) {
      const r = this[at];
      if (!r)
        return t.apply(this, n);
      n[0] !== void 0 && (r.body = n[0]);
      const i = {
        startTimestamp: ce() * 1e3,
        xhr: this
      };
      return ye("xhr", i), t.apply(this, n);
    };
  });
}
function Mf(e) {
  if (Me(e))
    return e;
  try {
    return e.toString();
  } catch {
  }
}
function Nf() {
  if (Vr() && he) {
    const t = Af();
    return () => {
      t();
    };
  }
  return () => {
  };
}
const vo = {
  click: "click",
  pointerdown: "click",
  pointerup: "click",
  mousedown: "click",
  mouseup: "click",
  touchstart: "click",
  touchend: "click",
  mouseover: "hover",
  mouseout: "hover",
  mouseenter: "hover",
  mouseleave: "hover",
  pointerover: "hover",
  pointerout: "hover",
  pointerenter: "hover",
  pointerleave: "hover",
  dragstart: "drag",
  dragend: "drag",
  drag: "drag",
  dragenter: "drag",
  dragleave: "drag",
  dragover: "drag",
  drop: "drag",
  keydown: "press",
  keyup: "press",
  keypress: "press",
  input: "press"
};
function Af() {
  return Y0(({ metric: e }) => {
    const t = U();
    if (!t || e.value == null)
      return;
    const n = e.entries.find((y) => y.duration === e.value && vo[y.name]);
    if (!n)
      return;
    const r = vo[n.name], i = t.getOptions(), o = Q(he + n.startTime), s = Q(e.value), a = W(), c = ge(), d = c ? ue(c) : void 0, l = d ? H(d).description : void 0, u = a.getUser(), p = t.getIntegrationByName("Replay"), f = p && p.getReplayId(), _ = u !== void 0 ? u.email || u.id || u.ip_address : void 0, S = hd([a, "access", (y) => y.getScopeData, "call", (y) => y(), "access", (y) => y.contexts, "optionalAccess", (y) => y.profile, "optionalAccess", (y) => y.profile_id]), b = lt(n.target), E = ie({
      release: i.release,
      environment: i.environment,
      transaction: l,
      [Is]: e.value,
      user: _ || void 0,
      profile_id: S || void 0,
      replay_id: f || void 0
    }), h = it({
      name: b,
      op: `ui.interaction.${r}`,
      attributes: E,
      startTime: o,
      experimental: {
        standalone: !0
      }
    });
    h.addEvent("inp", {
      [Or]: "millisecond",
      [Pr]: e.value
    }), h.end(o + s);
  });
}
function xf(e, t = kf("fetch")) {
  let n = 0, r = 0;
  function i(o) {
    const s = o.body.length;
    n += s, r++;
    const a = {
      body: o.body,
      method: "POST",
      referrerPolicy: "origin",
      headers: e.headers,
      // Outgoing requests are usually cancelled when navigating to a different page, causing a "TypeError: Failed to
      // fetch" error and sending a "network_error" client-outcome - in Chrome, the request status shows "(cancelled)".
      // The `keepalive` flag keeps outgoing requests alive, even when switching pages. We want this since we're
      // frequently sending events right before the user is switching pages (eg. whenfinishing navigation transactions).
      // Gotchas:
      // - `keepalive` isn't supported by Firefox
      // - As per spec (https://fetch.spec.whatwg.org/#http-network-or-cache-fetch):
      //   If the sum of contentLength and inflightKeepaliveBytes is greater than 64 kibibytes, then return a network error.
      //   We will therefore only activate the flag when we're below that limit.
      // There is also a limit of requests that can be open at the same time, so we also limit this to 15
      // See https://github.com/getsentry/sentry-javascript/pull/7553 for details
      keepalive: n <= 6e4 && r < 15,
      ...e.fetchOptions
    };
    if (!t)
      return yo("fetch"), mn("No fetch implementation available");
    try {
      return t(e.url, a).then((c) => (n -= s, r--, {
        statusCode: c.status,
        headers: {
          "x-sentry-rate-limits": c.headers.get("X-Sentry-Rate-Limits"),
          "retry-after": c.headers.get("Retry-After")
        }
      }));
    } catch (c) {
      return yo("fetch"), n -= s, r--, mn(c);
    }
  }
  return Pl(e, i);
}
const Rf = 30, Lf = 50;
function aa(e, t, n, r) {
  const i = {
    filename: e,
    function: t === "<anonymous>" ? vt : t,
    in_app: !0
    // All browser frames are considered in_app
  };
  return n !== void 0 && (i.lineno = n), r !== void 0 && (i.colno = r), i;
}
const Of = /^\s*at (?:(.+?\)(?: \[.+\])?|.*?) ?\((?:address at )?)?(?:async )?((?:<anonymous>|[-a-z]+:|.*bundle|\/)?.*?)(?::(\d+))?(?::(\d+))?\)?\s*$/i, Pf = /\((\S*)(?::(\d+))(?::(\d+))\)/, $f = (e) => {
  const t = Of.exec(e);
  if (t) {
    if (t[2] && t[2].indexOf("eval") === 0) {
      const o = Pf.exec(t[2]);
      o && (t[2] = o[1], t[3] = o[2], t[4] = o[3]);
    }
    const [r, i] = ca(t[1] || vt, t[2]);
    return aa(i, r, t[3] ? +t[3] : void 0, t[4] ? +t[4] : void 0);
  }
}, Df = [Rf, $f], Ff = /^\s*(.*?)(?:\((.*?)\))?(?:^|@)?((?:[-a-z]+)?:\/.*?|\[native code\]|[^@]*(?:bundle|\d+\.js)|\/[\w\-. /=]+)(?::(\d+))?(?::(\d+))?\s*$/i, Hf = /(\S+) line (\d+)(?: > eval line \d+)* > eval/i, Uf = (e) => {
  const t = Ff.exec(e);
  if (t) {
    if (t[3] && t[3].indexOf(" > eval") > -1) {
      const o = Hf.exec(t[3]);
      o && (t[1] = t[1] || "eval", t[3] = o[1], t[4] = o[2], t[5] = "");
    }
    let r = t[3], i = t[1] || vt;
    return [i, r] = ca(i, r), aa(r, i, t[4] ? +t[4] : void 0, t[5] ? +t[5] : void 0);
  }
}, Bf = [Lf, Uf], jf = [Df, Bf], Vf = ps(...jf), ca = (e, t) => {
  const n = e.indexOf("safari-extension") !== -1, r = e.indexOf("safari-web-extension") !== -1;
  return n || r ? [
    e.indexOf("@") !== -1 ? e.split("@")[0] : vt,
    n ? `safari-extension:${t}` : `safari-web-extension:${t}`
  ] : [e, t];
}, rn = 1024, qf = "Breadcrumbs", Gf = (e = {}) => {
  const t = {
    console: !0,
    dom: !0,
    fetch: !0,
    history: !0,
    sentry: !0,
    xhr: !0,
    ...e
  };
  return {
    name: qf,
    setup(n) {
      t.console && xu(Yf(n)), t.dom && Sf(Zf(n, t.dom)), t.xhr && sa(Kf(n)), t.fetch && gs(Xf(n)), t.history && qr(Jf(n)), t.sentry && n.on("beforeSendEvent", zf(n));
    }
  };
}, Wf = Gf;
function zf(e) {
  return function(n) {
    U() === e && Je(
      {
        category: `sentry.${n.type === "transaction" ? "transaction" : "event"}`,
        event_id: n.event_id,
        level: n.level,
        message: Ve(n)
      },
      {
        event: n
      }
    );
  };
}
function Zf(e, t) {
  return function(r) {
    if (U() !== e)
      return;
    let i, o, s = typeof t == "object" ? t.serializeAttribute : void 0, a = typeof t == "object" && typeof t.maxStringLength == "number" ? t.maxStringLength : void 0;
    a && a > rn && (ae && v.warn(
      `\`dom.maxStringLength\` cannot exceed ${rn}, but a value of ${a} was configured. Sentry will use ${rn} instead.`
    ), a = rn), typeof s == "string" && (s = [s]);
    try {
      const d = r.event, l = Qf(d) ? d.target : d;
      i = lt(l, { keyAttrs: s, maxStringLength: a }), o = cs(l);
    } catch {
      i = "<unknown>";
    }
    if (i.length === 0)
      return;
    const c = {
      category: `ui.${r.name}`,
      message: i
    };
    o && (c.data = { "ui.component_name": o }), Je(c, {
      event: r.event,
      name: r.name,
      global: r.global
    });
  };
}
function Yf(e) {
  return function(n) {
    if (U() !== e)
      return;
    const r = {
      category: "console",
      data: {
        arguments: n.args,
        logger: "console"
      },
      level: zu(n.level),
      message: Ni(n.args, " ")
    };
    if (n.level === "assert")
      if (n.args[0] === !1)
        r.message = `Assertion failed: ${Ni(n.args.slice(1), " ") || "console.assert"}`, r.data.arguments = n.args.slice(1);
      else
        return;
    Je(r, {
      input: n.args,
      level: n.level
    });
  };
}
function Kf(e) {
  return function(n) {
    if (U() !== e)
      return;
    const { startTimestamp: r, endTimestamp: i } = n, o = n.xhr[at];
    if (!r || !i || !o)
      return;
    const { method: s, url: a, status_code: c, body: d } = o, l = {
      method: s,
      url: a,
      status_code: c
    }, u = {
      xhr: n.xhr,
      input: d,
      startTimestamp: r,
      endTimestamp: i
    };
    Je(
      {
        category: "xhr",
        data: l,
        type: "http"
      },
      u
    );
  };
}
function Xf(e) {
  return function(n) {
    if (U() !== e)
      return;
    const { startTimestamp: r, endTimestamp: i } = n;
    if (i && !(n.fetchData.url.match(/sentry_key/) && n.fetchData.method === "POST"))
      if (n.error) {
        const o = n.fetchData, s = {
          data: n.error,
          input: n.args,
          startTimestamp: r,
          endTimestamp: i
        };
        Je(
          {
            category: "fetch",
            data: o,
            level: "error",
            type: "http"
          },
          s
        );
      } else {
        const o = n.response, s = {
          ...n.fetchData,
          status_code: o && o.status
        }, a = {
          input: n.args,
          response: o,
          startTimestamp: r,
          endTimestamp: i
        };
        Je(
          {
            category: "fetch",
            data: s,
            type: "http"
          },
          a
        );
      }
  };
}
function Jf(e) {
  return function(n) {
    if (U() !== e)
      return;
    let r = n.from, i = n.to;
    const o = We(A.location.href);
    let s = r ? We(r) : void 0;
    const a = We(i);
    (!s || !s.path) && (s = o), o.protocol === a.protocol && o.host === a.host && (i = a.relative), o.protocol === s.protocol && o.host === s.host && (r = s.relative), Je({
      category: "navigation",
      data: {
        from: r,
        to: i
      }
    });
  };
}
function Qf(e) {
  return !!e && !!e.target;
}
const ep = [
  "EventTarget",
  "Window",
  "Node",
  "ApplicationCache",
  "AudioTrackList",
  "BroadcastChannel",
  "ChannelMergerNode",
  "CryptoOperation",
  "EventSource",
  "FileReader",
  "HTMLUnknownElement",
  "IDBDatabase",
  "IDBRequest",
  "IDBTransaction",
  "KeyOperation",
  "MediaController",
  "MessagePort",
  "ModalWindow",
  "Notification",
  "SVGElementInstance",
  "Screen",
  "SharedWorker",
  "TextTrack",
  "TextTrackCue",
  "TextTrackList",
  "WebSocket",
  "WebSocketWorker",
  "Worker",
  "XMLHttpRequest",
  "XMLHttpRequestEventTarget",
  "XMLHttpRequestUpload"
], tp = "BrowserApiErrors", np = (e = {}) => {
  const t = {
    XMLHttpRequest: !0,
    eventTarget: !0,
    requestAnimationFrame: !0,
    setInterval: !0,
    setTimeout: !0,
    ...e
  };
  return {
    name: tp,
    // TODO: This currently only works for the first client this is setup
    // We may want to adjust this to check for client etc.
    setupOnce() {
      t.setTimeout && ne(A, "setTimeout", So), t.setInterval && ne(A, "setInterval", So), t.requestAnimationFrame && ne(A, "requestAnimationFrame", ip), t.XMLHttpRequest && "XMLHttpRequest" in A && ne(XMLHttpRequest.prototype, "send", op);
      const n = t.eventTarget;
      n && (Array.isArray(n) ? n : ep).forEach(sp);
    }
  };
}, rp = np;
function So(e) {
  return function(...t) {
    const n = t[0];
    return t[0] = _t(n, {
      mechanism: {
        data: { function: Ae(e) },
        handled: !1,
        type: "instrument"
      }
    }), e.apply(this, t);
  };
}
function ip(e) {
  return function(t) {
    return e.apply(this, [
      _t(t, {
        mechanism: {
          data: {
            function: "requestAnimationFrame",
            handler: Ae(e)
          },
          handled: !1,
          type: "instrument"
        }
      })
    ]);
  };
}
function op(e) {
  return function(...t) {
    const n = this;
    return ["onload", "onerror", "onprogress", "onreadystatechange"].forEach((i) => {
      i in n && typeof n[i] == "function" && ne(n, i, function(o) {
        const s = {
          mechanism: {
            data: {
              function: i,
              handler: Ae(o)
            },
            handled: !1,
            type: "instrument"
          }
        }, a = Ar(o);
        return a && (s.mechanism.data.handler = Ae(a)), _t(o, s);
      });
    }), e.apply(this, t);
  };
}
function sp(e) {
  const t = A, n = t[e] && t[e].prototype;
  !n || !n.hasOwnProperty || !n.hasOwnProperty("addEventListener") || (ne(n, "addEventListener", function(r) {
    return function(i, o, s) {
      try {
        typeof o.handleEvent == "function" && (o.handleEvent = _t(o.handleEvent, {
          mechanism: {
            data: {
              function: "handleEvent",
              handler: Ae(o),
              target: e
            },
            handled: !1,
            type: "instrument"
          }
        }));
      } catch {
      }
      return r.apply(this, [
        i,
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        _t(o, {
          mechanism: {
            data: {
              function: "addEventListener",
              handler: Ae(o),
              target: e
            },
            handled: !1,
            type: "instrument"
          }
        }),
        s
      ]);
    };
  }), ne(
    n,
    "removeEventListener",
    function(r) {
      return function(i, o, s) {
        const a = o;
        try {
          const c = a && a.__sentry_wrapped__;
          c && r.call(this, i, c, s);
        } catch {
        }
        return r.call(this, i, a, s);
      };
    }
  ));
}
const ap = "GlobalHandlers", cp = (e = {}) => {
  const t = {
    onerror: !0,
    onunhandledrejection: !0,
    ...e
  };
  return {
    name: ap,
    setupOnce() {
      Error.stackTraceLimit = 50;
    },
    setup(n) {
      t.onerror && (dp(n), bo("onerror")), t.onunhandledrejection && (lp(n), bo("onunhandledrejection"));
    }
  };
}, up = cp;
function dp(e) {
  ms((t) => {
    const { stackParser: n, attachStacktrace: r } = ua();
    if (U() !== e || Ks())
      return;
    const { msg: i, url: o, line: s, column: a, error: c } = t, d = _p(
      Ur(n, c || i, void 0, r, !1),
      o,
      s,
      a
    );
    d.level = "error", js(d, {
      originalException: c,
      mechanism: {
        handled: !1,
        type: "onerror"
      }
    });
  });
}
function lp(e) {
  ys((t) => {
    const { stackParser: n, attachStacktrace: r } = ua();
    if (U() !== e || Ks())
      return;
    const i = fp(t), o = Mr(i) ? pp(i) : Ur(n, i, void 0, r, !0);
    o.level = "error", js(o, {
      originalException: i,
      mechanism: {
        handled: !1,
        type: "onunhandledrejection"
      }
    });
  });
}
function fp(e) {
  if (Mr(e))
    return e;
  try {
    if ("reason" in e)
      return e.reason;
    if ("detail" in e && "reason" in e.detail)
      return e.detail.reason;
  } catch {
  }
  return e;
}
function pp(e) {
  return {
    exception: {
      values: [
        {
          type: "UnhandledRejection",
          // String() is needed because the Primitive type includes symbols (which can't be automatically stringified)
          value: `Non-Error promise rejection captured with value: ${String(e)}`
        }
      ]
    }
  };
}
function _p(e, t, n, r) {
  const i = e.exception = e.exception || {}, o = i.values = i.values || [], s = o[0] = o[0] || {}, a = s.stacktrace = s.stacktrace || {}, c = a.frames = a.frames || [], d = isNaN(parseInt(r, 10)) ? void 0 : r, l = isNaN(parseInt(n, 10)) ? void 0 : n, u = Me(t) && t.length > 0 ? t : mu();
  return c.length === 0 && c.push({
    colno: d,
    filename: u,
    function: vt,
    in_app: !0,
    lineno: l
  }), e;
}
function bo(e) {
  ae && v.log(`Global Handler attached: ${e}`);
}
function ua() {
  const e = U();
  return e && e.getOptions() || {
    stackParser: () => [],
    attachStacktrace: !1
  };
}
const hp = () => ({
  name: "HttpContext",
  preprocessEvent(e) {
    if (!A.navigator && !A.location && !A.document)
      return;
    const t = e.request && e.request.url || A.location && A.location.href, { referrer: n } = A.document || {}, { userAgent: r } = A.navigator || {}, i = {
      ...e.request && e.request.headers,
      ...n && { Referer: n },
      ...r && { "User-Agent": r }
    }, o = { ...e.request, ...t && { url: t }, headers: i };
    e.request = o;
  }
}), gp = "cause", mp = 5, yp = "LinkedErrors", vp = (e = {}) => {
  const t = e.limit || mp, n = e.key || gp;
  return {
    name: yp,
    preprocessEvent(r, i, o) {
      const s = o.getOptions();
      pu(
        // This differs from the LinkedErrors integration in core by using a different exceptionFromError function
        Fr,
        s.stackParser,
        s.maxValueLength,
        n,
        t,
        r,
        i
      );
    }
  };
}, Sp = vp;
function bp(e) {
  return [
    ql(),
    Ul(),
    rp(),
    Wf(),
    up(),
    Sp(),
    n0(),
    hp()
  ];
}
function Ep(e = {}) {
  return { ...{
    defaultIntegrations: bp(),
    release: typeof __SENTRY_RELEASE__ == "string" ? __SENTRY_RELEASE__ : A.SENTRY_RELEASE && A.SENTRY_RELEASE.id ? A.SENTRY_RELEASE.id : void 0,
    autoSessionTracking: !0,
    sendClientReports: !0
  }, ...e };
}
function wp() {
  const e = A, t = e && e.chrome && e.chrome.runtime && e.chrome.runtime.id, n = A;
  return !!(n && n.browser && n.browser.runtime && n.browser.runtime.id) || !!t;
}
function Tp(e = {}) {
  const t = Ep(e);
  if (wp()) {
    Ht(() => {
      console.error(
        "[Sentry] You cannot run Sentry this way in a browser extension, check: https://docs.sentry.io/platforms/javascript/best-practices/browser-extensions/"
      );
    });
    return;
  }
  ae && (_s() || v.warn(
    "No Fetch API detected. The Sentry SDK requires a Fetch API compatible environment to send events. Please add a Fetch API polyfill."
  ));
  const n = {
    ...t,
    stackParser: Nu(t.stackParser || Vf),
    integrations: Cl(t),
    transport: t.transport || xf
  };
  xl(w0, n), t.autoSessionTracking && Cp();
}
function Cp() {
  if (typeof A.document > "u") {
    ae && v.warn("Session tracking in non-browser environment with @sentry/browser is not supported.");
    return;
  }
  eo({ ignoreDuration: !0 }), to(), qr(({ from: e, to: t }) => {
    e !== void 0 && e !== t && (eo({ ignoreDuration: !0 }), to());
  });
}
const vr = {
  traceFetch: !0,
  traceXHR: !0,
  enableHTTPTimings: !0
};
function kp(e) {
  const { traceFetch: t, traceXHR: n, shouldCreateSpanForRequest: r, enableHTTPTimings: i, tracePropagationTargets: o } = {
    traceFetch: vr.traceFetch,
    traceXHR: vr.traceXHR,
    ...e
  }, s = typeof r == "function" ? r : (d) => !0, a = (d) => Ap(d, o), c = {};
  t && gs((d) => {
    const l = s0(d, s, a, c);
    if (l) {
      const u = da(d.fetchData.url), p = u ? We(u).host : void 0;
      l.setAttributes({
        "http.url": u,
        "server.address": p
      });
    }
    i && l && Eo(l);
  }), n && sa((d) => {
    const l = xp(d, s, a, c);
    i && l && Eo(l);
  });
}
function Ip(e) {
  return e.entryType === "resource" && "initiatorType" in e && typeof e.nextHopProtocol == "string" && (e.initiatorType === "fetch" || e.initiatorType === "xmlhttprequest");
}
function Eo(e) {
  const { url: t } = H(e).data || {};
  if (!t || typeof t != "string")
    return;
  const n = jr("resource", ({ entries: r }) => {
    r.forEach((i) => {
      Ip(i) && i.name.endsWith(t) && (Np(i).forEach((s) => e.setAttribute(...s)), setTimeout(n));
    });
  });
}
function Mp(e) {
  let t = "unknown", n = "unknown", r = "";
  for (const i of e) {
    if (i === "/") {
      [t, n] = e.split("/");
      break;
    }
    if (!isNaN(Number(i))) {
      t = r === "h" ? "http" : r, n = e.split(r)[1];
      break;
    }
    r += i;
  }
  return r === e && (t = r), { name: t, version: n };
}
function be(e = 0) {
  return ((he || performance.timeOrigin) + e) / 1e3;
}
function Np(e) {
  const { name: t, version: n } = Mp(e.nextHopProtocol), r = [];
  return r.push(["network.protocol.version", n], ["network.protocol.name", t]), he ? [
    ...r,
    ["http.request.redirect_start", be(e.redirectStart)],
    ["http.request.fetch_start", be(e.fetchStart)],
    ["http.request.domain_lookup_start", be(e.domainLookupStart)],
    ["http.request.domain_lookup_end", be(e.domainLookupEnd)],
    ["http.request.connect_start", be(e.connectStart)],
    ["http.request.secure_connection_start", be(e.secureConnectionStart)],
    ["http.request.connection_end", be(e.connectEnd)],
    ["http.request.request_start", be(e.requestStart)],
    ["http.request.response_start", be(e.responseStart)],
    ["http.request.response_end", be(e.responseEnd)]
  ] : r;
}
function Ap(e, t) {
  const n = A.location && A.location.href;
  if (n) {
    let r, i;
    try {
      r = new URL(e, n), i = new URL(n).origin;
    } catch {
      return !1;
    }
    const o = r.origin === i;
    return t ? Ge(r.toString(), t) || o && Ge(r.pathname, t) : o;
  } else {
    const r = !!e.match(/^\/(?!\/)/);
    return t ? Ge(e, t) : r;
  }
}
function xp(e, t, n, r) {
  const i = e.xhr, o = i && i[at];
  if (!i || i.__sentry_own_request__ || !o)
    return;
  const s = Ue() && t(o.url);
  if (e.endTimestamp && s) {
    const p = i.__sentry_xhr_span_id__;
    if (!p)
      return;
    const f = r[p];
    f && o.status_code !== void 0 && (Ns(f, o.status_code), f.end(), delete r[p]);
    return;
  }
  const a = da(o.url), c = a ? We(a).host : void 0, d = !!ge(), l = s && d ? it({
    name: `${o.method} ${o.url}`,
    attributes: {
      type: "xhr",
      "http.method": o.method,
      "http.url": a,
      url: o.url,
      "server.address": c,
      [oe]: "auto.http.browser",
      [Pt]: "http.client"
    }
  }) : new bt();
  i.__sentry_xhr_span_id__ = l.spanContext().spanId, r[i.__sentry_xhr_span_id__] = l;
  const u = U();
  return i.setRequestHeader && n(o.url) && u && Rp(
    i,
    u,
    // If performance is disabled (TWP) or there's no active root span (pageload/navigation/interaction),
    // we do not want to use the span as base for the trace headers,
    // which means that the headers will be generated from the scope and the sampling decision is deferred
    Ue() && d ? l : void 0
  ), l;
}
function Rp(e, t, n) {
  const r = W(), i = xe(), { traceId: o, spanId: s, sampled: a, dsc: c } = {
    ...i.getPropagationContext(),
    ...r.getPropagationContext()
  }, d = n && Ue() ? Rs(n) : xr(o, s, a), l = ws(
    c || (n ? rt(n) : Nn(o, t))
  );
  Lp(e, d, l);
}
function Lp(e, t, n) {
  try {
    e.setRequestHeader("sentry-trace", t), n && e.setRequestHeader(sr, n);
  } catch {
  }
}
function da(e) {
  try {
    return new URL(e, A.location.origin).href;
  } catch {
    return;
  }
}
function Op() {
  A && A.document ? A.document.addEventListener("visibilitychange", () => {
    const e = ge();
    if (!e)
      return;
    const t = ue(e);
    if (A.document.hidden && t) {
      const n = "cancelled", { op: r, status: i } = H(t);
      ae && v.log(`[Tracing] Transaction: ${n} -> since tab moved to the background, op: ${r}`), i || t.setStatus({ code: ee, message: n }), t.setAttribute("sentry.cancellation_reason", "document.hidden"), t.end();
    }
  }) : ae && v.warn("[Tracing] Could not set up background tab detection due to lack of global document");
}
const Pp = "BrowserTracing", $p = {
  ...dn,
  instrumentNavigation: !0,
  instrumentPageLoad: !0,
  markBackgroundSpan: !0,
  enableLongTask: !0,
  enableInp: !0,
  _experiments: {},
  ...vr
}, Dp = (e = {}) => {
  Pd();
  const {
    enableInp: t,
    enableLongTask: n,
    _experiments: { enableInteractions: r },
    beforeStartSpan: i,
    idleTimeout: o,
    finalTimeout: s,
    childSpanTimeout: a,
    markBackgroundSpan: c,
    traceFetch: d,
    traceXHR: l,
    shouldCreateSpanForRequest: u,
    enableHTTPTimings: p,
    instrumentPageLoad: f,
    instrumentNavigation: _
  } = {
    ...$p,
    ...e
  }, S = rf();
  t && Nf(), n && of(), r && sf();
  const b = {
    name: void 0,
    source: void 0
  };
  function E(h, y) {
    const T = y.op === "pageload", w = i ? i(y) : y, m = w.attributes || {};
    y.name !== w.name && (m[Pe] = "custom", w.attributes = m), b.name = w.name, b.source = m[Pe];
    const k = Bs(w, {
      idleTimeout: o,
      finalTimeout: s,
      childSpanTimeout: a,
      // should wait for finish signal if it's a pageload transaction
      disableAutoFinish: T,
      beforeSpanEnd: (R) => {
        S(), lf(R);
      }
    });
    function N() {
      ["interactive", "complete"].includes(A.document.readyState) && h.emit("idleSpanEnableAutoFinish", k);
    }
    return T && A.document && (A.document.addEventListener("readystatechange", () => {
      N();
    }), N()), k;
  }
  return {
    name: Pp,
    afterAllSetup(h) {
      let y, T = A.location && A.location.href;
      h.on("startNavigationSpan", (w) => {
        U() === h && (y && (ae && v.log(`[Tracing] Finishing current root span with op: ${H(y).op}`), y.end()), y = E(h, {
          op: "navigation",
          ...w
        }));
      }), h.on("startPageLoadSpan", (w, m = {}) => {
        if (U() !== h)
          return;
        y && (ae && v.log(`[Tracing] Finishing current root span with op: ${H(y).op}`), y.end());
        const k = m.sentryTrace || wo("sentry-trace"), N = m.baggage || wo("baggage"), R = td(k, N);
        W().setPropagationContext(R), y = E(h, {
          op: "pageload",
          ...w
        });
      }), h.on("spanEnd", (w) => {
        const m = H(w).op;
        if (w !== ue(w) || m !== "navigation" && m !== "pageload")
          return;
        const k = W(), N = k.getPropagationContext();
        k.setPropagationContext({
          ...N,
          sampled: N.sampled !== void 0 ? N.sampled : nt(w),
          dsc: N.dsc || rt(w)
        });
      }), A.location && (f && Fp(h, {
        name: A.location.pathname,
        // pageload should always start at timeOrigin (and needs to be in s, not ms)
        startTime: he ? he / 1e3 : void 0,
        attributes: {
          [Pe]: "url",
          [oe]: "auto.pageload.browser"
        }
      }), _ && qr(({ to: w, from: m }) => {
        if (m === void 0 && T && T.indexOf(w) !== -1) {
          T = void 0;
          return;
        }
        m !== w && (T = void 0, Hp(h, {
          name: A.location.pathname,
          attributes: {
            [Pe]: "url",
            [oe]: "auto.navigation.browser"
          }
        }));
      })), c && Op(), r && Up(o, s, a, b), kp({
        traceFetch: d,
        traceXHR: l,
        tracePropagationTargets: h.getOptions().tracePropagationTargets,
        shouldCreateSpanForRequest: u,
        enableHTTPTimings: p
      });
    }
  };
};
function Fp(e, t, n) {
  e.emit("startPageLoadSpan", t, n), W().setTransactionName(t.name);
  const r = ge();
  return (r && H(r).op) === "pageload" ? r : void 0;
}
function Hp(e, t) {
  W().setPropagationContext(To()), xe().setPropagationContext(To()), e.emit("startNavigationSpan", t), W().setTransactionName(t.name);
  const n = ge();
  return (n && H(n).op) === "navigation" ? n : void 0;
}
function wo(e) {
  const t = yu(`meta[name=${e}]`);
  return t ? t.getAttribute("content") : void 0;
}
function Up(e, t, n, r) {
  let i;
  const o = () => {
    const s = "ui.action.click", a = ge(), c = a && ue(a);
    if (c) {
      const d = H(c).op;
      if (["navigation", "pageload"].includes(d)) {
        ae && v.warn(`[Tracing] Did not create ${s} span because a pageload or navigation span is in progress.`);
        return;
      }
    }
    if (i && (i.setAttribute(ur, "interactionInterrupted"), i.end(), i = void 0), !r.name) {
      ae && v.warn(`[Tracing] Did not create ${s} transaction because _latestRouteName is missing.`);
      return;
    }
    i = Bs(
      {
        name: r.name,
        op: s,
        attributes: {
          [Pe]: r.source || "url"
        }
      },
      {
        idleTimeout: e,
        finalTimeout: t,
        childSpanTimeout: n
      }
    );
  };
  A.document && addEventListener("click", o, { once: !1, capture: !0 });
}
function To() {
  return {
    traceId: V(),
    spanId: V().substring(16)
  };
}
function Bp(e, t) {
  if (t)
    return Tp({
      dsn: za,
      integrations: [Dp()],
      tracesSampleRate: 1e-3,
      enabled: !0,
      environment: Za,
      initialScope: {
        tags: {
          agentId: e
        }
      }
    }), {
      populateWithAgent: (n) => {
        var r;
        Cs().setTags({
          owner: n.owner_id,
          plan: (r = n.metadata) == null ? void 0 : r.plan
        });
      },
      onErrorSendAlert: (n, r) => {
        Lr((i) => {
          i.setExtra("error data", r), yl(n);
        });
      }
    };
}
function Co(e) {
  window.DID_AGENTS_API = {}, window.dataLayer = window.dataLayer || [];
  const {
    isOwner: t,
    enabled: n,
    onError: r,
    onClose: i,
    styles: o,
    didSocketApiUrl: s,
    didApiUrl: a,
    customMixpanelKey: c,
    offline: d,
    monitor: l = !0,
    ...u
  } = e;
  if (!e.targetElement && u.mode === "full")
    throw new Error("No target element provided for full mode");
  if (u.agentId) {
    if (!u.auth)
      throw new Error("No auth provider");
  } else
    throw new Error("No agent provider ");
  const p = typeof e.targetElement == "string" ? document.getElementById(e.targetElement) : e.targetElement, f = document.createElement("div");
  f.className = "didagent_target", document.body.appendChild(f);
  const {
    populateWithAgent: _,
    onErrorSendAlert: S
  } = Bp(u.agentId, l) ?? {}, b = (h, y) => {
    S == null || S(h.message, y), r == null || r(h, y);
  }, E = setInterval(() => {
    p && !document.body.contains(p) && (hn(null, f), f.remove(), clearInterval(E));
  }, 2e3);
  hn(g(oc, {
    initialConfigurations: {
      ...u,
      targetElement: p
    },
    children: g(au, {
      isOwner: t,
      onClose: i,
      onAgentReady: _,
      styles: o,
      offline: d,
      didApiUrl: a,
      didSocketApiUrl: s,
      customMixpanelKey: c,
      enabled: n,
      onError: b
    })
  }), f);
}
function ko(e) {
  const {
    token: t,
    username: n,
    password: r,
    clientKey: i
  } = e;
  if (!i) {
    if (!t) {
      if (!n || !r)
        throw new Error("Failed to load agent. No auth method provided");
      return {
        type: "basic",
        username: n,
        password: r
      };
    }
    return {
      type: "bearer",
      token: t
    };
  }
  return {
    type: "key",
    clientKey: i
  };
}
const se = document.querySelector('script[data-name="did-agent"]');
if (se) {
  const e = new URLSearchParams(""), t = e.get("agent_id"), n = e.get("key"), r = se.getAttribute("data-mode") ?? "fabio", i = se.getAttribute("data-target-id"), o = t || se.getAttribute("data-agent-id"), s = se.getAttribute("data-api-url"), a = se.getAttribute("data-token"), c = se.getAttribute("data-username"), d = se.getAttribute("data-password"), l = n || se.getAttribute("data-client-key"), u = se.getAttribute("data-chat-mode") ?? C.Functional, p = se.getAttribute("data-track") !== "false", f = se.getAttribute("data-monitor") !== "false", _ = se.getAttribute("data-position") ?? "right", S = se.getAttribute("data-orientation") ?? "vertical";
  if (o) {
    if (!Object.values(C).includes(u))
      throw new Error(`Invalid chat mode, must be one of: ${Object.values(C).join(", ")}`);
  } else
    throw new Error("No agent id");
  window.DID_AGENTS_API = {};
  const b = {
    didApiUrl: s,
    monitor: f
  }, E = {
    mode: r,
    targetElement: i,
    auth: ko({
      token: a,
      username: c,
      password: d,
      clientKey: l
    }),
    agentId: o,
    track: p,
    chatMode: u,
    position: _,
    orientation: S
  };
  Co({
    ...E,
    ...b
  });
} else
  window.DID_AGENT_INIT = ({
    token: e,
    username: t,
    password: n,
    clientKey: r,
    ...i
  }) => {
    Co({
      ...i,
      auth: ko({
        token: e,
        username: t,
        password: n,
        clientKey: r
      })
    });
  };
